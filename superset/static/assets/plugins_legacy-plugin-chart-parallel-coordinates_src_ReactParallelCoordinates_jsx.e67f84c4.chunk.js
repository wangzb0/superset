"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["plugins_legacy-plugin-chart-parallel-coordinates_src_ReactParallelCoordinates_jsx"],{

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js":
/*!*************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js ***!
  \*************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/SequentialSchemeRegistrySingleton.ts\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\");\n/* harmony import */ var _vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vendor/parcoords/divgrid */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n/* eslint-disable react/sort-prop-types */\n\n\n\n\n\n\n\nconst propTypes = {\n  // Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\n  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().object)),\n  width: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  height: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().number),\n  colorMetric: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  includeSeries: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool),\n  linearColorScheme: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  metrics: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().string)),\n  series: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string),\n  showDatatable: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().bool) };\n\n\nfunction ParallelCoordinates(element, props) {\n  const {\n    data,\n    width,\n    height,\n    colorMetric,\n    includeSeries,\n    linearColorScheme,\n    metrics,\n    series,\n    showDatatable } =\n  props;\n\n  const cols = includeSeries ? [series].concat(metrics) : metrics;\n\n  const ttypes = {};\n  ttypes[series] = 'string';\n  metrics.forEach((v) => {\n    ttypes[v] = 'number';\n  });\n\n  const colorScale = colorMetric ?\n  (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().\n  get(linearColorScheme).\n  createLinearScale(d3__WEBPACK_IMPORTED_MODULE_0___default().extent(data, (d) => d[colorMetric])) :\n  () => 'grey';\n  const color = (d) => colorScale(d[colorMetric]);\n  const container = d3__WEBPACK_IMPORTED_MODULE_0___default().select(element).\n  classed('superset-legacy-chart-parallel-coordinates', true);\n  container.selectAll('*').remove();\n  const effHeight = showDatatable ? height / 2 : height;\n\n  const div = container.\n  append('div').\n  style('height', `${effHeight}px`).\n  classed('parcoords', true);\n\n  const chart = (0,_vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()(div.node()).\n  width(width).\n  color(color).\n  alpha(0.5).\n  composite('darken').\n  height(effHeight).\n  data(data).\n  dimensions(cols).\n  types(ttypes).\n  render().\n  createAxes().\n  shadows().\n  reorderable().\n  brushMode('1D-axes');\n\n  if (showDatatable) {\n    // create data table, row hover highlighting\n    const grid = (0,_vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    container.\n    append('div').\n    style('height', `${effHeight}px`).\n    datum(data).\n    call(grid).\n    classed('parcoords grid', true).\n    selectAll('.row').\n    on({\n      mouseover(d) {\n        chart.highlight([d]);\n      },\n      mouseout: chart.unhighlight });\n\n    // update data table on brush event\n    chart.on('brush', (d) => {\n      d3__WEBPACK_IMPORTED_MODULE_0___default().select('.grid').\n      datum(d).\n      call(grid).\n      selectAll('.row').\n      on({\n        mouseover(dd) {\n          chart.highlight([dd]);\n        },\n        mouseout: chart.unhighlight });\n\n    });\n  }\n}\n\nParallelCoordinates.displayName = 'ParallelCoordinates';\nParallelCoordinates.propTypes = propTypes;const _default =\n\nParallelCoordinates;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(propTypes, \"propTypes\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-parallel-coordinates\\\\src\\\\ParallelCoordinates.js\");reactHotLoader.register(ParallelCoordinates, \"ParallelCoordinates\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-parallel-coordinates\\\\src\\\\ParallelCoordinates.js\");reactHotLoader.register(_default, \"default\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-parallel-coordinates\\\\src\\\\ParallelCoordinates.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1BhcmFsbGVsQ29vcmRpbmF0ZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9zcmMvUGFyYWxsZWxDb29yZGluYXRlcy5qcz9mYTA5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4gKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuICogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3NvcnQtcHJvcC10eXBlcyAqL1xyXG5pbXBvcnQgZDMgZnJvbSAnZDMnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgeyBnZXRTZXF1ZW50aWFsU2NoZW1lUmVnaXN0cnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XHJcblxyXG5pbXBvcnQgcGFyY29vcmRzIGZyb20gJy4vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMnO1xyXG5pbXBvcnQgZGl2Z3JpZCBmcm9tICcuL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgLy8gU3RhbmRhcmQgdGFidWxhciBkYXRhIFt7IGZpZWxkTmFtZTE6IHZhbHVlMSwgZmllbGROYW1lMjogdmFsdWUyIH1dXHJcbiAgZGF0YTogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9iamVjdCksXHJcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gIGNvbG9yTWV0cmljOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gIGluY2x1ZGVTZXJpZXM6IFByb3BUeXBlcy5ib29sLFxyXG4gIGxpbmVhckNvbG9yU2NoZW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gIG1ldHJpY3M6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxyXG4gIHNlcmllczogUHJvcFR5cGVzLnN0cmluZyxcclxuICBzaG93RGF0YXRhYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxufTtcclxuXHJcbmZ1bmN0aW9uIFBhcmFsbGVsQ29vcmRpbmF0ZXMoZWxlbWVudCwgcHJvcHMpIHtcclxuICBjb25zdCB7XHJcbiAgICBkYXRhLFxyXG4gICAgd2lkdGgsXHJcbiAgICBoZWlnaHQsXHJcbiAgICBjb2xvck1ldHJpYyxcclxuICAgIGluY2x1ZGVTZXJpZXMsXHJcbiAgICBsaW5lYXJDb2xvclNjaGVtZSxcclxuICAgIG1ldHJpY3MsXHJcbiAgICBzZXJpZXMsXHJcbiAgICBzaG93RGF0YXRhYmxlLFxyXG4gIH0gPSBwcm9wcztcclxuXHJcbiAgY29uc3QgY29scyA9IGluY2x1ZGVTZXJpZXMgPyBbc2VyaWVzXS5jb25jYXQobWV0cmljcykgOiBtZXRyaWNzO1xyXG5cclxuICBjb25zdCB0dHlwZXMgPSB7fTtcclxuICB0dHlwZXNbc2VyaWVzXSA9ICdzdHJpbmcnO1xyXG4gIG1ldHJpY3MuZm9yRWFjaCh2ID0+IHtcclxuICAgIHR0eXBlc1t2XSA9ICdudW1iZXInO1xyXG4gIH0pO1xyXG5cclxuICBjb25zdCBjb2xvclNjYWxlID0gY29sb3JNZXRyaWNcclxuICAgID8gZ2V0U2VxdWVudGlhbFNjaGVtZVJlZ2lzdHJ5KClcclxuICAgICAgICAuZ2V0KGxpbmVhckNvbG9yU2NoZW1lKVxyXG4gICAgICAgIC5jcmVhdGVMaW5lYXJTY2FsZShkMy5leHRlbnQoZGF0YSwgZCA9PiBkW2NvbG9yTWV0cmljXSkpXHJcbiAgICA6ICgpID0+ICdncmV5JztcclxuICBjb25zdCBjb2xvciA9IGQgPT4gY29sb3JTY2FsZShkW2NvbG9yTWV0cmljXSk7XHJcbiAgY29uc3QgY29udGFpbmVyID0gZDNcclxuICAgIC5zZWxlY3QoZWxlbWVudClcclxuICAgIC5jbGFzc2VkKCdzdXBlcnNldC1sZWdhY3ktY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMnLCB0cnVlKTtcclxuICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XHJcbiAgY29uc3QgZWZmSGVpZ2h0ID0gc2hvd0RhdGF0YWJsZSA/IGhlaWdodCAvIDIgOiBoZWlnaHQ7XHJcblxyXG4gIGNvbnN0IGRpdiA9IGNvbnRhaW5lclxyXG4gICAgLmFwcGVuZCgnZGl2JylcclxuICAgIC5zdHlsZSgnaGVpZ2h0JywgYCR7ZWZmSGVpZ2h0fXB4YClcclxuICAgIC5jbGFzc2VkKCdwYXJjb29yZHMnLCB0cnVlKTtcclxuXHJcbiAgY29uc3QgY2hhcnQgPSBwYXJjb29yZHMoKShkaXYubm9kZSgpKVxyXG4gICAgLndpZHRoKHdpZHRoKVxyXG4gICAgLmNvbG9yKGNvbG9yKVxyXG4gICAgLmFscGhhKDAuNSlcclxuICAgIC5jb21wb3NpdGUoJ2RhcmtlbicpXHJcbiAgICAuaGVpZ2h0KGVmZkhlaWdodClcclxuICAgIC5kYXRhKGRhdGEpXHJcbiAgICAuZGltZW5zaW9ucyhjb2xzKVxyXG4gICAgLnR5cGVzKHR0eXBlcylcclxuICAgIC5yZW5kZXIoKVxyXG4gICAgLmNyZWF0ZUF4ZXMoKVxyXG4gICAgLnNoYWRvd3MoKVxyXG4gICAgLnJlb3JkZXJhYmxlKClcclxuICAgIC5icnVzaE1vZGUoJzFELWF4ZXMnKTtcclxuXHJcbiAgaWYgKHNob3dEYXRhdGFibGUpIHtcclxuICAgIC8vIGNyZWF0ZSBkYXRhIHRhYmxlLCByb3cgaG92ZXIgaGlnaGxpZ2h0aW5nXHJcbiAgICBjb25zdCBncmlkID0gZGl2Z3JpZCgpO1xyXG4gICAgY29udGFpbmVyXHJcbiAgICAgIC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgIC5zdHlsZSgnaGVpZ2h0JywgYCR7ZWZmSGVpZ2h0fXB4YClcclxuICAgICAgLmRhdHVtKGRhdGEpXHJcbiAgICAgIC5jYWxsKGdyaWQpXHJcbiAgICAgIC5jbGFzc2VkKCdwYXJjb29yZHMgZ3JpZCcsIHRydWUpXHJcbiAgICAgIC5zZWxlY3RBbGwoJy5yb3cnKVxyXG4gICAgICAub24oe1xyXG4gICAgICAgIG1vdXNlb3ZlcihkKSB7XHJcbiAgICAgICAgICBjaGFydC5oaWdobGlnaHQoW2RdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vdXNlb3V0OiBjaGFydC51bmhpZ2hsaWdodCxcclxuICAgICAgfSk7XHJcbiAgICAvLyB1cGRhdGUgZGF0YSB0YWJsZSBvbiBicnVzaCBldmVudFxyXG4gICAgY2hhcnQub24oJ2JydXNoJywgZCA9PiB7XHJcbiAgICAgIGQzLnNlbGVjdCgnLmdyaWQnKVxyXG4gICAgICAgIC5kYXR1bShkKVxyXG4gICAgICAgIC5jYWxsKGdyaWQpXHJcbiAgICAgICAgLnNlbGVjdEFsbCgnLnJvdycpXHJcbiAgICAgICAgLm9uKHtcclxuICAgICAgICAgIG1vdXNlb3ZlcihkZCkge1xyXG4gICAgICAgICAgICBjaGFydC5oaWdobGlnaHQoW2RkXSk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgbW91c2VvdXQ6IGNoYXJ0LnVuaGlnaGxpZ2h0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5QYXJhbGxlbENvb3JkaW5hdGVzLmRpc3BsYXlOYW1lID0gJ1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xyXG5QYXJhbGxlbENvb3JkaW5hdGVzLnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBhcmFsbGVsQ29vcmRpbmF0ZXM7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx":
/*!*******************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx ***!
  \*******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/chart/components/reactify.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/style/index.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/utils.ts\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ParallelCoordinates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ParallelCoordinates */ \"./plugins/legacy-plugin-chart-parallel-coordinates/src/ParallelCoordinates.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\n\n\n\n\nconst ReactComponent = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_ParallelCoordinates__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n\nconst ParallelCoordianes = ({ className, ...otherProps }) =>\n(0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { className: className },\n(0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(ReactComponent, otherProps));\n\n\n\nParallelCoordianes.propTypes = {\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string.isRequired) };const _default =\n\n\n(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_5__.styled)(ParallelCoordianes)`\n  ${({ theme }) => `\n    .superset-legacy-chart-parallel-coordinates {\n      div.grid {\n        overflow: auto;\n        div.row {\n          &:hover {\n            background-color: ${theme.colors.grayscale.light2};\n          }\n        }\n      }\n    }\n    .parcoords svg,\n    .parcoords canvas {\n      font-size: ${theme.typography.sizes.s}px;\n      position: absolute;\n    }\n    .parcoords > canvas {\n      pointer-events: none;\n    }\n\n    .parcoords text.label {\n      font: 100%;\n      font-size: ${theme.typography.sizes.s}px;\n      cursor: drag;\n    }\n    .parcoords rect.background {\n      fill: transparent;\n    }\n    .parcoords rect.background:hover {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.base, 0.2)};\n    }\n    .parcoords .resize rect {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.1)};\n    }\n    .parcoords rect.extent {\n      fill: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.light5, 0.25)};\n      stroke: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.6)};\n    }\n    .parcoords .axis line,\n    .parcoords .axis path {\n      fill: none;\n      stroke: ${theme.colors.grayscale.dark1};\n      shape-rendering: crispEdges;\n    }\n    .parcoords canvas {\n      opacity: 1;\n      -moz-transition: opacity 0.3s;\n      -webkit-transition: opacity 0.3s;\n      -o-transition: opacity 0.3s;\n    }\n    .parcoords canvas.faded {\n      opacity: ${theme.opacity.mediumLight};\n    }\n    .parcoords {\n      -webkit-touch-callout: none;\n      -webkit-user-select: none;\n      -khtml-user-select: none;\n      -moz-user-select: none;\n      -ms-user-select: none;\n      user-select: none;\n      background-color: ${theme.colors.grayscale.light5};\n    }\n\n    /* data table styles */\n    .parcoords .row,\n    .parcoords .header {\n      clear: left;\n      font-size: ${theme.typography.sizes.s}px;\n      line-height: 18px;\n      height: 18px;\n      margin: 0px;\n    }\n    .parcoords .row:nth-child(odd) {\n      background: ${(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_6__.addAlpha)(theme.colors.grayscale.dark2, 0.05)};\n    }\n    .parcoords .header {\n      font-weight: ${theme.typography.weights.bold};\n    }\n    .parcoords .cell {\n      float: left;\n      overflow: hidden;\n      white-space: nowrap;\n      width: 100px;\n      height: 18px;\n    }\n    .parcoords .col-0 {\n      width: 180px;\n    }\n  `}\n`;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ReactComponent, \"ReactComponent\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-parallel-coordinates\\\\src\\\\ReactParallelCoordinates.jsx\");reactHotLoader.register(ParallelCoordianes, \"ParallelCoordianes\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-parallel-coordinates\\\\src\\\\ReactParallelCoordinates.jsx\");reactHotLoader.register(_default, \"default\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-parallel-coordinates\\\\src\\\\ReactParallelCoordinates.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qc3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qc3g/MjY2MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBzdHlsZWQsIHJlYWN0aWZ5LCBhZGRBbHBoYSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xyXG5cclxuY29uc3QgUmVhY3RDb21wb25lbnQgPSByZWFjdGlmeShDb21wb25lbnQpO1xyXG5cclxuY29uc3QgUGFyYWxsZWxDb29yZGlhbmVzID0gKHsgY2xhc3NOYW1lLCAuLi5vdGhlclByb3BzIH0pID0+IChcclxuICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cclxuICAgIDxSZWFjdENvbXBvbmVudCB7Li4ub3RoZXJQcm9wc30gLz5cclxuICA8L2Rpdj5cclxuKTtcclxuXHJcblBhcmFsbGVsQ29vcmRpYW5lcy5wcm9wVHlwZXMgPSB7XHJcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzdHlsZWQoUGFyYWxsZWxDb29yZGlhbmVzKWBcclxuICAkeyh7IHRoZW1lIH0pID0+IGBcclxuICAgIC5zdXBlcnNldC1sZWdhY3ktY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMge1xyXG4gICAgICBkaXYuZ3JpZCB7XHJcbiAgICAgICAgb3ZlcmZsb3c6IGF1dG87XHJcbiAgICAgICAgZGl2LnJvdyB7XHJcbiAgICAgICAgICAmOmhvdmVyIHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0Mn07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAucGFyY29vcmRzIHN2ZyxcclxuICAgIC5wYXJjb29yZHMgY2FudmFzIHtcclxuICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcclxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgfVxyXG4gICAgLnBhcmNvb3JkcyA+IGNhbnZhcyB7XHJcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xyXG4gICAgfVxyXG5cclxuICAgIC5wYXJjb29yZHMgdGV4dC5sYWJlbCB7XHJcbiAgICAgIGZvbnQ6IDEwMCU7XHJcbiAgICAgIGZvbnQtc2l6ZTogJHt0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnN9cHg7XHJcbiAgICAgIGN1cnNvcjogZHJhZztcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgcmVjdC5iYWNrZ3JvdW5kIHtcclxuICAgICAgZmlsbDogdHJhbnNwYXJlbnQ7XHJcbiAgICB9XHJcbiAgICAucGFyY29vcmRzIHJlY3QuYmFja2dyb3VuZDpob3ZlciB7XHJcbiAgICAgIGZpbGw6ICR7YWRkQWxwaGEodGhlbWUuY29sb3JzLmdyYXlzY2FsZS5iYXNlLCAwLjIpfTtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgLnJlc2l6ZSByZWN0IHtcclxuICAgICAgZmlsbDogJHthZGRBbHBoYSh0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsyLCAwLjEpfTtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgcmVjdC5leHRlbnQge1xyXG4gICAgICBmaWxsOiAke2FkZEFscGhhKHRoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQ1LCAwLjI1KX07XHJcbiAgICAgIHN0cm9rZTogJHthZGRBbHBoYSh0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsyLCAwLjYpfTtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgLmF4aXMgbGluZSxcclxuICAgIC5wYXJjb29yZHMgLmF4aXMgcGF0aCB7XHJcbiAgICAgIGZpbGw6IG5vbmU7XHJcbiAgICAgIHN0cm9rZTogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsxfTtcclxuICAgICAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzO1xyXG4gICAgfVxyXG4gICAgLnBhcmNvb3JkcyBjYW52YXMge1xyXG4gICAgICBvcGFjaXR5OiAxO1xyXG4gICAgICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcclxuICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XHJcbiAgICAgIC1vLXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgY2FudmFzLmZhZGVkIHtcclxuICAgICAgb3BhY2l0eTogJHt0aGVtZS5vcGFjaXR5Lm1lZGl1bUxpZ2h0fTtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMge1xyXG4gICAgICAtd2Via2l0LXRvdWNoLWNhbGxvdXQ6IG5vbmU7XHJcbiAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XHJcbiAgICAgIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xyXG4gICAgICB1c2VyLXNlbGVjdDogbm9uZTtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0NX07XHJcbiAgICB9XHJcblxyXG4gICAgLyogZGF0YSB0YWJsZSBzdHlsZXMgKi9cclxuICAgIC5wYXJjb29yZHMgLnJvdyxcclxuICAgIC5wYXJjb29yZHMgLmhlYWRlciB7XHJcbiAgICAgIGNsZWFyOiBsZWZ0O1xyXG4gICAgICBmb250LXNpemU6ICR7dGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xyXG4gICAgICBsaW5lLWhlaWdodDogMThweDtcclxuICAgICAgaGVpZ2h0OiAxOHB4O1xyXG4gICAgICBtYXJnaW46IDBweDtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgLnJvdzpudGgtY2hpbGQob2RkKSB7XHJcbiAgICAgIGJhY2tncm91bmQ6ICR7YWRkQWxwaGEodGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMiwgMC4wNSl9O1xyXG4gICAgfVxyXG4gICAgLnBhcmNvb3JkcyAuaGVhZGVyIHtcclxuICAgICAgZm9udC13ZWlnaHQ6ICR7dGhlbWUudHlwb2dyYXBoeS53ZWlnaHRzLmJvbGR9O1xyXG4gICAgfVxyXG4gICAgLnBhcmNvb3JkcyAuY2VsbCB7XHJcbiAgICAgIGZsb2F0OiBsZWZ0O1xyXG4gICAgICBvdmVyZmxvdzogaGlkZGVuO1xyXG4gICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xyXG4gICAgICB3aWR0aDogMTAwcHg7XHJcbiAgICAgIGhlaWdodDogMThweDtcclxuICAgIH1cclxuICAgIC5wYXJjb29yZHMgLmNvbC0wIHtcclxuICAgICAgd2lkdGg6IDE4MHB4O1xyXG4gICAgfVxyXG4gIGB9XHJcbmA7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/ReactParallelCoordinates.jsx\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js":
/*!***********************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js ***!
  \***********************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default =\n\nfunction (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: { top: 24, right: 0, bottom: 12, left: 0 },\n    nullValueSeparator: 'undefined', // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: { top: 8, right: 0, bottom: 8, left: 0 },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: [] };\n\n\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight;\n\n    // canvas data layers\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    });\n\n    // svg tick and brush layers\n    pc.svg = selection.\n    append('svg').\n    attr('width', __.width).\n    attr('height', __.height).\n    append('svg:g').\n    attr(\n    'transform',\n    'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n    return pc;\n  };\n  var events = d3.dispatch.apply(\n  this,\n  [\n  'render',\n  'resize',\n  'highlight',\n  'brush',\n  'brushend',\n  'axesreorder'].\n  concat(d3.keys(__))),\n\n  w = function () {\n    return __.width - __.margin.right - __.margin.left;\n  },\n  h = function () {\n    return __.height - __.margin.top - __.margin.bottom;\n  },\n  flags = {\n    brushable: false,\n    reorderable: false,\n    axes: false,\n    interactive: false,\n    debug: false },\n\n  xscale = d3.scale.ordinal(),\n  yscale = {},\n  dragging = {},\n  line = d3.svg.line(),\n  axis = d3.svg.axis().orient('left').ticks(5),\n  g, // groups for axes, brushes\n  ctx = {},\n  canvas = {},\n  clusterCentroids = [];\n\n  // side effects for setters\n  var side_effects = d3.dispatch.\n  apply(this, d3.keys(__)).\n  on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).\n  on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).\n  on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).\n  on('width', function (d) {\n    pc.resize();\n  }).\n  on('height', function (d) {\n    pc.resize();\n  }).\n  on('margin', function (d) {\n    pc.resize();\n  }).\n  on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).\n  on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).\n  on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).\n  on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  });\n\n  // expose the state of the chart\n  pc.state = __;\n  pc.flags = flags;\n\n  // create getter/setters\n  getset(pc, __, events);\n\n  // expose events\n  d3.rebind(pc, events, 'on');\n\n  // getter/setter with event firing\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, { value: x, previous: old });\n        events[key].call(pc, { value: x, previous: old });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [\n      h() +\n      1 -\n      __.nullValueSeparatorPadding.bottom -\n      __.nullValueSeparatorPadding.top,\n      1];\n\n    } else if (__.nullValueSeparator == 'top') {\n      return [\n      h() + 1,\n      1 +\n      __.nullValueSeparatorPadding.bottom +\n      __.nullValueSeparatorPadding.top];\n\n    }\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        });\n\n        // special case if single value\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n        domain = [];\n\n        // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      } };\n\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    // xscale\n    xscale.rangePoints([0, w()], 1);\n\n    // canvas sizes\n    pc.selection.\n    selectAll('canvas').\n    style('margin-top', __.margin.top + 'px').\n    style('margin-left', __.margin.left + 'px').\n    attr('width', w() + 2).\n    attr('height', h() + 2);\n\n    // default styles, needs to be set when canvas width changes\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n    if (typeof global === 'undefined') {\n      global = true;\n    }\n\n    // scales of the same type\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(\n      scales.\n      map(function (p, i) {\n        return yscale[p].domain();\n      }).\n      reduce(function (a, b) {\n        return a.concat(b);\n      }));\n\n\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(\n        d3.extent(__.data, function (d) {\n          return +d[k];\n        }));\n\n      });\n    }\n\n    // update centroids\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  };\n\n  // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n  pc.toType = function (v) {\n    return {}.toString.\n    call(v).\n    match(/\\s([a-zA-Z]+)/)[1].\n    toLowerCase();\n  };\n\n  // try to coerce to number before returning type\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n    return pc.toType(v);\n  };\n\n  // attempt to determine types of each dimension based on first row of data\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.\n  renderQueue(path_foreground).\n  rate(50).\n  clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.\n  renderQueue(path_brushed).\n  rate(50).\n  clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map();\n    // determine clusterCounts\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y]));\n\n      // centroids on 'virtual' axes\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i]);\n          var rightCentroid = __.clusterCentroids.\n          get(yscale[__.bundleDimension](row[__.bundleDimension])).\n          get(p[i + 1]);\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n\n    cps.push(centroids[0]);\n    cps.push(\n    $V([\n    centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)),\n    centroids[0].e(2)]));\n\n\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n    cps.push(\n    $V([\n    centroids[cols - 1].e(1) +\n    a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)),\n    centroids[cols - 1].e(2)]));\n\n\n    cps.push(centroids[cols - 1]);\n\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  };\n\n  // draw dots with radius r on the axis line where data intersects\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n    return this;\n  };\n\n  // draw single cubic bezier curve\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n      ctx.bezierCurveTo(\n      cps[i].e(1),\n      cps[i].e(2),\n      cps[i + 1].e(1),\n      cps[i + 1].e(2),\n      cps[i + 2].e(1),\n      cps[i + 2].e(2));\n\n    }\n  }\n\n  // draw single polyline\n  function color_path(d, ctx) {\n    ctx.beginPath();\n    if (\n    __.bundleDimension !== null && __.bundlingStrength > 0 ||\n    __.smoothness > 0)\n    {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n    ctx.stroke();\n  }\n\n  // draw many polylines of the same color\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (\n      __.bundleDimension !== null && __.bundlingStrength > 0 ||\n      __.smoothness > 0)\n      {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  }\n\n  // returns the y-position just beyond the separating null value line\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\n      \"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\");\n\n    }\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(\n        position(p),\n        typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n\n      } else {\n        ctx.lineTo(\n        position(p),\n        typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2);\n\n    // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n    return this;\n  };\n\n  d3.rebind(\n  pc,\n  axis,\n  'ticks',\n  'orient',\n  'tickValues',\n  'tickSubdivide',\n  'tickSize',\n  'tickPadding',\n  'tickFormat');\n\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n\n    pc.flip(dimension);\n\n    d3.select(this.parentElement).\n    transition().\n    duration(1100).\n    call(axis.scale(yscale[dimension]));\n\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n\n    __.dimensionTitleRotation += delta;\n    pc.svg.\n    selectAll('text.label').\n    attr(\n    'transform',\n    'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes();\n\n    // Add a group element for each dimension.\n    g = pc.svg.\n    selectAll('.dimension').\n    data(__.dimensions, function (d) {\n      return d;\n    }).\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    });\n\n    // Add an axis and title.\n    g.append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label' }).\n\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', 1 + __.nullValueSeparatorPadding.top).\n      attr('x2', w()).\n      attr('y2', 1 + __.nullValueSeparatorPadding.top).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.\n      append('line').\n      attr('x1', 0).\n      attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('x2', w()).\n      attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).\n      attr('stroke-width', 1).\n      attr('stroke', '#777').\n      attr('fill', 'none').\n      attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions);\n\n    // Enter\n    g_data.\n    enter().\n    append('svg:g').\n    attr('class', 'dimension').\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 0).\n    append('svg:g').\n    attr('class', 'axis').\n    attr('transform', 'translate(0,0)').\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).\n    append('svg:text').\n    attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label' }).\n\n    text(dimensionLabels).\n    on('dblclick', flipAxisAndUpdatePCP).\n    on('wheel', rotateLabels);\n\n    // Update\n    g_data.attr('opacity', 0);\n    g_data.\n    select('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.\n    select('.label').\n    transition().\n    duration(1100).\n    text(dimensionLabels).\n    attr(\n    'transform',\n    'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n\n\n    // Exit\n    g_data.exit().remove();\n\n    g = pc.svg.selectAll('.dimension');\n    g.transition().\n    duration(1100).\n    attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).\n    style('opacity', 1);\n\n    pc.svg.\n    selectAll('.axis').\n    transition().\n    duration(1100).\n    each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n    return this;\n  };\n\n  // Jason Davies, http://bl.ocks.org/1341281\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n\n    g.style('cursor', 'move').call(\n    d3.behavior.\n    drag().\n    on('dragstart', function (d) {\n      dragging[d] = this.__origin__ = xscale(d);\n    }).\n    on('drag', function (d) {\n      dragging[d] = Math.min(\n      w(),\n      Math.max(0, this.__origin__ += d3.event.dx));\n\n      __.dimensions.sort(function (a, b) {\n        return position(a) - position(b);\n      });\n      xscale.domain(__.dimensions);\n      pc.render();\n      g.attr('transform', function (d) {\n        return 'translate(' + position(d) + ')';\n      });\n    }).\n    on('dragend', function (d) {\n      // Let's see if the order has changed and send out an event if so.\n      var i = 0,\n      j = __.dimensions.indexOf(d),\n      elem = this,\n      parent = this.parentElement;\n\n      while ((elem = elem.previousElementSibling) != null) ++i;\n      if (i !== j) {\n        events.axesreorder.call(pc, __.dimensions);\n        // We now also want to reorder the actual dom elements that represent\n        // the axes. That is, the g.dimension elements. If we don't do this,\n        // we get a weird and confusing transition when updateAxes is called.\n        // This is due to the fact that, initially the nth g.dimension element\n        // represents the nth axis. However, after a manual reordering,\n        // without reordering the dom elements, the nth dom elements no longer\n        // necessarily represents the nth axis.\n        //\n        // i is the original index of the dom element\n        // j is the new index of the dom element\n        if (i > j) {\n          // Element moved left\n          parent.insertBefore(this, parent.children[j - 1]);\n        } else {\n          // Element moved right\n          if (j + 1 < parent.children.length) {\n            parent.insertBefore(this, parent.children[j + 1]);\n          } else {\n            parent.appendChild(this);\n          }\n        }\n      }\n\n      delete this.__origin__;\n      delete dragging[d];\n      d3.select(this).\n      transition().\n      attr('transform', 'translate(' + xscale(d) + ')');\n      pc.render();\n    }));\n\n    flags.reorderable = true;\n    return this;\n  };\n\n  // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]);\n\n      // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n      return pixelDifference;\n    });\n\n    // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n      var highlighted = __.highlighted.slice(0);\n      pc.unhighlight();\n\n      g.transition().\n      duration(1500).\n      attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render();\n\n      // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  };\n\n  // pairs of adjacent dimensions\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {}, // Nothing to be done.\n        uninstall: function (pc) {}, // Nothing to be done.\n        selected: function () {\n          return [];\n        }, // Nothing to return\n        brushState: function () {\n          return {};\n        } } },\n\n\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    } };\n\n\n  // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    }\n\n    // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      }\n\n      // Next, we need to 'uninstall' the current brushMode.\n      brush.modes[brush.mode].uninstall(pc);\n      // Finally, we can install the requested one.\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  };\n\n  // brush mode: 1D-Axes\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n      extents = actives.map(function (p) {\n        return brushes[p].extent();\n      });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return (\n              extents[dimension][0] <= yscale[p](d[p]) &&\n              yscale[p](d[p]) <= extents[dimension][1]);\n\n          } else {\n            return (\n              extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1]);\n\n          }\n        },\n        string: function (d, p, dimension) {\n          return (\n            extents[dimension][0] <= yscale[p](d[p]) &&\n            yscale[p](d[p]) <= extents[dimension][1]);\n\n        } };\n\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        });\n\n        // loop over each dimension and update appropriately (if it was passed in through extents)\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]);\n\n            //redraw the brush\n            brush(brushSelections[d]);\n\n            //fire some events\n            brush.event(brushSelections[d]);\n          }\n        });\n\n        //redraw the chart\n        pc.renderBrushed();\n      }\n    }\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents };\n\n  })();\n  // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n  (function () {\n    var strums = {},\n    strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n      id = strum.dims.i,\n      points = [strum.p1, strum.p2],\n      line = svg.selectAll('line#strum-' + id).data([strum]),\n      circles = svg.selectAll('circle#strum-' + id).data(points),\n      drag = d3.behavior.drag();\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(\n        Math.max(strum.minX + 1, ev.x),\n        strum.maxX);\n\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'strum-' + id).\n      attr('class', 'strum');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n        dims,\n        strum;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h() };\n\n\n        strums[dims.i] = strum;\n        strums.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n        strum = strums[strums.active];\n\n        // Make sure that the point is within the bounds\n        strum.p2[0] = Math.min(\n        Math.max(strum.minX + 1, ev.x - __.margin.left),\n        strum.maxX);\n\n        strum.p2[1] = Math.min(\n        Math.max(strum.minY, ev.y - __.margin.top),\n        strum.maxY);\n\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n      p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n      m1 = 1 - width / p1[0],\n      b1 = p1[1] * (1 - m1),\n      m2 = 1 - width / p2[0],\n      b2 = p2[1] * (1 - m2);\n\n      // test if point falls between lines\n      return function (p) {\n        var x = p[0],\n        y = p[1],\n        y1 = m1 * x + b1,\n        y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n      brushed = __.data;\n\n      // Get the ids of the currently active strums.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n        test = containmentTest(strum, strums.width(id)),\n        d1 = strum.dims.left,\n        d2 = strum.dims.right,\n        y1 = yscale[d1],\n        y2 = yscale[d2],\n        point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n      svg = pc.selection.select('svg').select('g#strums');\n\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n        strum = strums[strums.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (\n        strum &&\n        strum.p1[0] === strum.p2[0] &&\n        strum.p1[1] === strum.p2[1])\n        {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      strums.active = undefined;\n      // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d;\n            // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      });\n\n      // Add a new svg group in which we draw the strums.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'strums').\n      attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(strums);\n\n      drag.\n      on('dragstart', onDragStart(strums)).\n      on('drag', onDrag(strums)).\n      on('dragend', onDragEnd(strums));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#strums').\n      attr('id', 'strum-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      } };\n\n  })();\n\n  // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    }\n\n    // data within extents\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n      extents = actives.map(function (p) {\n        return brushes[p].extent();\n      });\n\n      // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n      if (actives.length === 0) return __.data;\n\n      // test if within range\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        } };\n\n\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n\n      brush.\n      y(yscale[axis]).\n      on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).\n      on('brush', function () {\n        brushUpdated(selected());\n      }).\n      on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).\n      extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).\n      resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes();\n\n      // Add and store a brush for each axis.\n      g.append('svg:g').\n      attr('class', 'brush').\n      each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).\n      selectAll('rect').\n      style('visibility', null).\n      attr('x', -15).\n      attr('width', 30);\n\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents };\n\n  })();\n  // brush mode: angular\n  // code based on 2D.strums.js\n\n  (function () {\n    var arcs = {},\n    strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n      id = arc.dims.i,\n      points = [arc.p2, arc.p3],\n      line = svg.selectAll('line#arc-' + id).data([\n      { p1: arc.p1, p2: arc.p2 },\n      { p1: arc.p1, p2: arc.p3 }]),\n\n      circles = svg.selectAll('circle#arc-' + id).data(points),\n      drag = d3.behavior.drag(),\n      path = svg.selectAll('path#arc-' + id).data([arc]);\n\n      path.\n      enter().\n      append('path').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc').\n      style('fill', 'orange').\n      style('opacity', 0.5);\n\n      path.\n      attr('d', arc.arc).\n      attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n\n      line.\n      enter().\n      append('line').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      line.\n      attr('x1', function (d) {\n        return d.p1[0];\n      }).\n      attr('y1', function (d) {\n        return d.p1[1];\n      }).\n      attr('x2', function (d) {\n        return d.p2[0];\n      }).\n      attr('y2', function (d) {\n        return d.p2[1];\n      }).\n      attr('stroke', 'black').\n      attr('stroke-width', 2);\n\n      drag.\n      on('drag', function (d, i) {\n        var ev = d3.event,\n        angle = 0;\n\n        i = i + 2;\n\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (\n        arc.startAngle < Math.PI &&\n        arc.endAngle < Math.PI &&\n        angle < Math.PI ||\n        arc.startAngle >= Math.PI &&\n        arc.endAngle >= Math.PI &&\n        angle >= Math.PI)\n        {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).\n      on('dragend', onDragEnd());\n\n      circles.\n      enter().\n      append('circle').\n      attr('id', 'arc-' + id).\n      attr('class', 'arc');\n\n      circles.\n      attr('cx', function (d) {\n        return d[0];\n      }).\n      attr('cy', function (d) {\n        return d[1];\n      }).\n      attr('r', 5).\n      style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).\n      on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).\n      on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).\n      call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = { i: -1, left: undefined, right: undefined };\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n        dims,\n        arc;\n\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n\n        dims = dimensionsForPoint(p),\n        arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0) };\n\n\n        arcs[dims.i] = arc;\n        arcs.active = dims.i;\n\n        // Make sure that the point is within the bounds\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n        arc = arcs[arcs.active];\n\n        // Make sure that the point is within the bounds\n        arc.p2[0] = Math.min(\n        Math.max(arc.minX + 1, ev.x - __.margin.left),\n        arc.maxX);\n\n        arc.p2[1] = Math.min(\n        Math.max(arc.minY, ev.y - __.margin.top),\n        arc.maxY);\n\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    }\n\n    // some helper functions\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    // [0, 2*PI] -> [-PI/2, PI/2]\n    var signedAngle = function (angle) {\n      var ret = angle;\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n      return -ret;\n    };\n\n    /**\r\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\r\n     * However, one can only select lines from 0 to PI, so we compute the\r\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\r\n     * are 12 and 6 o'clock respectively.\r\n     */\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      }\n\n      // test if segment angle is contained in angle interval\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n      brushed = __.data;\n\n      // Get the ids of the currently active arcs.\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n        test = containmentTest(arc),\n        d1 = arc.dims.left,\n        d2 = arc.dims.right,\n        y1 = yscale[d1],\n        y2 = yscale[d2],\n        a = arcs.width(id),\n        b = y1(d[d1]) - y2(d[d2]),\n        c = hypothenuse(a, b),\n        angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;}\n\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n      svg = pc.selection.select('svg').select('g#arcs');\n\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n        arc = arcs[arcs.active];\n\n        // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.\n          outerRadius(arcs.length(arcs.active)).\n          startAngle(angle).\n          endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag();\n\n      // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n      arcs.active = undefined;\n      // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      };\n\n      // returns angles in [-PI/2, PI/2]\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n        b = p1[1] - p2[1],\n        c = hypothenuse(a, b);\n\n        return Math.asin(b / c);\n      };\n\n      // returns angles in [0, 2 * PI]\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n        var sAngle = angle(arc.p1, arc.p2),\n        uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n        uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n        b = arc.p1[1] - arc.p2[1],\n        c = hypothenuse(a, b);\n\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n\n        // Checks if the first dimension is directly left of the second dimension.\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ?\n            i + i < length && __.dimensions[i + 1] === second :\n            false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d;\n            // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      });\n\n      // Add a new svg group in which we draw the arcs.\n      pc.selection.\n      select('svg').\n      append('g').\n      attr('id', 'arcs').\n      attr(\n      'transform',\n      'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n      // Install the required brushReset function\n      pc.brushReset = brushReset(arcs);\n\n      drag.\n      on('dragstart', onDragStart(arcs)).\n      on('drag', onDrag(arcs)).\n      on('dragend', onDragEnd(arcs));\n\n      // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n      strumRect = pc.selection.\n      select('svg').\n      insert('rect', 'g#arcs').\n      attr('id', 'arc-events').\n      attr('x', __.margin.left).\n      attr('y', __.margin.top).\n      attr('width', w()).\n      attr('height', h() + 2).\n      style('opacity', 0).\n      call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      } };\n\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  };\n\n  // expose a few objects\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n  pc.g = function () {\n    return g;\n  };\n\n  // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n  pc.resize = function () {\n    // selection size\n    pc.selection.\n    select('svg').\n    attr('width', __.width).\n    attr('height', __.height);\n    pc.svg.attr(\n    'transform',\n    'translate(' + __.margin.left + ',' + __.margin.top + ')');\n\n\n    // FIXME: the current brush state should pass through\n    if (flags.brushable) pc.brushReset();\n\n    // scales\n    pc.autoscale();\n\n    // axes, destroys old brushes.\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin });\n\n    return this;\n  };\n\n  // highlight an array of data\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  };\n\n  // clear highlighting\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  };\n\n  // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x:\n      ((a.x * b.y - a.y * b.x) * (c.x - d.x) -\n      (a.x - b.x) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y:\n      ((a.x * b.y - a.y * b.x) * (c.y - d.y) -\n      (a.y - b.y) * (c.x * d.y - c.y * d.x)) / (\n      (a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)) };\n\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n  pc.version = '0.7.0';\n  // this descriptive text should live with other introspective methods\n  pc.toString = function () {\n    return (\n      'Parallel Coordinates: ' +\n      __.dimensions.length +\n      ' dimensions (' +\n      d3.keys(__.data[0]).length +\n      ' total) , ' +\n      __.data.length +\n      ' rows');\n\n  };\n\n  return pc;\n}; /* [LICENSE TBD] */ /* eslint-disable *//* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);\n\nd3.renderQueue = function (func) {\n  var _queue = [], // data to be rendered\n  _rate = 10, // number of calls per frame\n  _clear = function () {}, // clearing function\n  _i = 0; // current iteration\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n    _clear();\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true;\n\n      // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n      var end = Math.min(_i + _rate, _queue.length);\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  };\n\n  // clear the canvas\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n      return rq;\n    }\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-parallel-coordinates\\\\src\\\\vendor\\\\parcoords\\\\d3.parcoords.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vcGx1Z2lucy9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL3NyYy92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5qcz9iNjRhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFtMSUNFTlNFIFRCRF0gKi9cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gIHZhciBfXyA9IHtcclxuICAgIGRhdGE6IFtdLFxyXG4gICAgaGlnaGxpZ2h0ZWQ6IFtdLFxyXG4gICAgZGltZW5zaW9uczogW10sXHJcbiAgICBkaW1lbnNpb25UaXRsZXM6IHt9LFxyXG4gICAgZGltZW5zaW9uVGl0bGVSb3RhdGlvbjogMCxcclxuICAgIHR5cGVzOiB7fSxcclxuICAgIGJydXNoZWQ6IGZhbHNlLFxyXG4gICAgYnJ1c2hlZENvbG9yOiBudWxsLFxyXG4gICAgYWxwaGFPbkJydXNoZWQ6IDAuMCxcclxuICAgIG1vZGU6ICdkZWZhdWx0JyxcclxuICAgIHJhdGU6IDIwLFxyXG4gICAgd2lkdGg6IDYwMCxcclxuICAgIGhlaWdodDogMzAwLFxyXG4gICAgbWFyZ2luOiB7IHRvcDogMjQsIHJpZ2h0OiAwLCBib3R0b206IDEyLCBsZWZ0OiAwIH0sXHJcbiAgICBudWxsVmFsdWVTZXBhcmF0b3I6ICd1bmRlZmluZWQnLCAvLyBzZXQgdG8gXCJ0b3BcIiBvciBcImJvdHRvbVwiXHJcbiAgICBudWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nOiB7IHRvcDogOCwgcmlnaHQ6IDAsIGJvdHRvbTogOCwgbGVmdDogMCB9LFxyXG4gICAgY29sb3I6ICcjMDY5JyxcclxuICAgIGNvbXBvc2l0ZTogJ3NvdXJjZS1vdmVyJyxcclxuICAgIGFscGhhOiAwLjcsXHJcbiAgICBidW5kbGluZ1N0cmVuZ3RoOiAwLjUsXHJcbiAgICBidW5kbGVEaW1lbnNpb246IG51bGwsXHJcbiAgICBzbW9vdGhuZXNzOiAwLjAsXHJcbiAgICBzaG93Q29udHJvbFBvaW50czogZmFsc2UsXHJcbiAgICBoaWRlQXhpczogW10sXHJcbiAgfTtcclxuXHJcbiAgZXh0ZW5kKF9fLCBjb25maWcpO1xyXG5cclxuICB2YXIgcGMgPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XHJcbiAgICBzZWxlY3Rpb24gPSBwYy5zZWxlY3Rpb24gPSBkMy5zZWxlY3Qoc2VsZWN0aW9uKTtcclxuXHJcbiAgICBfXy53aWR0aCA9IHNlbGVjdGlvblswXVswXS5jbGllbnRXaWR0aDtcclxuICAgIF9fLmhlaWdodCA9IHNlbGVjdGlvblswXVswXS5jbGllbnRIZWlnaHQ7XHJcblxyXG4gICAgLy8gY2FudmFzIGRhdGEgbGF5ZXJzXHJcbiAgICBbJ21hcmtzJywgJ2ZvcmVncm91bmQnLCAnYnJ1c2hlZCcsICdoaWdobGlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAgICBjYW52YXNbbGF5ZXJdID0gc2VsZWN0aW9uLmFwcGVuZCgnY2FudmFzJykuYXR0cignY2xhc3MnLCBsYXllcilbMF1bMF07XHJcbiAgICAgIGN0eFtsYXllcl0gPSBjYW52YXNbbGF5ZXJdLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBzdmcgdGljayBhbmQgYnJ1c2ggbGF5ZXJzXHJcbiAgICBwYy5zdmcgPSBzZWxlY3Rpb25cclxuICAgICAgLmFwcGVuZCgnc3ZnJylcclxuICAgICAgLmF0dHIoJ3dpZHRoJywgX18ud2lkdGgpXHJcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBfXy5oZWlnaHQpXHJcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcclxuICAgICAgLmF0dHIoXHJcbiAgICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICAgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknLFxyXG4gICAgICApO1xyXG5cclxuICAgIHJldHVybiBwYztcclxuICB9O1xyXG4gIHZhciBldmVudHMgPSBkMy5kaXNwYXRjaC5hcHBseShcclxuICAgICAgdGhpcyxcclxuICAgICAgW1xyXG4gICAgICAgICdyZW5kZXInLFxyXG4gICAgICAgICdyZXNpemUnLFxyXG4gICAgICAgICdoaWdobGlnaHQnLFxyXG4gICAgICAgICdicnVzaCcsXHJcbiAgICAgICAgJ2JydXNoZW5kJyxcclxuICAgICAgICAnYXhlc3Jlb3JkZXInLFxyXG4gICAgICBdLmNvbmNhdChkMy5rZXlzKF9fKSksXHJcbiAgICApLFxyXG4gICAgdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9fLndpZHRoIC0gX18ubWFyZ2luLnJpZ2h0IC0gX18ubWFyZ2luLmxlZnQ7XHJcbiAgICB9LFxyXG4gICAgaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIF9fLmhlaWdodCAtIF9fLm1hcmdpbi50b3AgLSBfXy5tYXJnaW4uYm90dG9tO1xyXG4gICAgfSxcclxuICAgIGZsYWdzID0ge1xyXG4gICAgICBicnVzaGFibGU6IGZhbHNlLFxyXG4gICAgICByZW9yZGVyYWJsZTogZmFsc2UsXHJcbiAgICAgIGF4ZXM6IGZhbHNlLFxyXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXHJcbiAgICAgIGRlYnVnOiBmYWxzZSxcclxuICAgIH0sXHJcbiAgICB4c2NhbGUgPSBkMy5zY2FsZS5vcmRpbmFsKCksXHJcbiAgICB5c2NhbGUgPSB7fSxcclxuICAgIGRyYWdnaW5nID0ge30sXHJcbiAgICBsaW5lID0gZDMuc3ZnLmxpbmUoKSxcclxuICAgIGF4aXMgPSBkMy5zdmcuYXhpcygpLm9yaWVudCgnbGVmdCcpLnRpY2tzKDUpLFxyXG4gICAgZywgLy8gZ3JvdXBzIGZvciBheGVzLCBicnVzaGVzXHJcbiAgICBjdHggPSB7fSxcclxuICAgIGNhbnZhcyA9IHt9LFxyXG4gICAgY2x1c3RlckNlbnRyb2lkcyA9IFtdO1xyXG5cclxuICAvLyBzaWRlIGVmZmVjdHMgZm9yIHNldHRlcnNcclxuICB2YXIgc2lkZV9lZmZlY3RzID0gZDMuZGlzcGF0Y2hcclxuICAgIC5hcHBseSh0aGlzLCBkMy5rZXlzKF9fKSlcclxuICAgIC5vbignY29tcG9zaXRlJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZC52YWx1ZTtcclxuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZC52YWx1ZTtcclxuICAgIH0pXHJcbiAgICAub24oJ2FscGhhJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQWxwaGEgPSBkLnZhbHVlO1xyXG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IGQudmFsdWU7XHJcbiAgICB9KVxyXG4gICAgLm9uKCdicnVzaGVkQ29sb3InLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IGQudmFsdWU7XHJcbiAgICB9KVxyXG4gICAgLm9uKCd3aWR0aCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIHBjLnJlc2l6ZSgpO1xyXG4gICAgfSlcclxuICAgIC5vbignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgcGMucmVzaXplKCk7XHJcbiAgICB9KVxyXG4gICAgLm9uKCdtYXJnaW4nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICBwYy5yZXNpemUoKTtcclxuICAgIH0pXHJcbiAgICAub24oJ3JhdGUnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICBicnVzaGVkUXVldWUucmF0ZShkLnZhbHVlKTtcclxuICAgICAgZm9yZWdyb3VuZFF1ZXVlLnJhdGUoZC52YWx1ZSk7XHJcbiAgICB9KVxyXG4gICAgLm9uKCdkaW1lbnNpb25zJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgeHNjYWxlLmRvbWFpbihfXy5kaW1lbnNpb25zKTtcclxuICAgICAgaWYgKGZsYWdzLmludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgcGMucmVuZGVyKCkudXBkYXRlQXhlcygpO1xyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgLm9uKCdidW5kbGVEaW1lbnNpb24nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XHJcbiAgICAgIGlmICghKF9fLmRpbWVuc2lvbnNbMF0gaW4geXNjYWxlKSkgcGMuYXV0b3NjYWxlKCk7XHJcbiAgICAgIGlmICh0eXBlb2YgZC52YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBpZiAoZC52YWx1ZSA8IF9fLmRpbWVuc2lvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBfXy5kaW1lbnNpb25zW2QudmFsdWVdO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZC52YWx1ZSA8IF9fLmhpZGVBeGlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgX18uYnVuZGxlRGltZW5zaW9uID0gX18uaGlkZUF4aXNbZC52YWx1ZV07XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIF9fLmJ1bmRsZURpbWVuc2lvbiA9IGQudmFsdWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9fLmNsdXN0ZXJDZW50cm9pZHMgPSBjb21wdXRlX2NsdXN0ZXJfY2VudHJvaWRzKF9fLmJ1bmRsZURpbWVuc2lvbik7XHJcbiAgICB9KVxyXG4gICAgLm9uKCdoaWRlQXhpcycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcclxuICAgICAgcGMuZGltZW5zaW9ucyh3aXRob3V0KF9fLmRpbWVuc2lvbnMsIGQudmFsdWUpKTtcclxuICAgIH0pO1xyXG5cclxuICAvLyBleHBvc2UgdGhlIHN0YXRlIG9mIHRoZSBjaGFydFxyXG4gIHBjLnN0YXRlID0gX187XHJcbiAgcGMuZmxhZ3MgPSBmbGFncztcclxuXHJcbiAgLy8gY3JlYXRlIGdldHRlci9zZXR0ZXJzXHJcbiAgZ2V0c2V0KHBjLCBfXywgZXZlbnRzKTtcclxuXHJcbiAgLy8gZXhwb3NlIGV2ZW50c1xyXG4gIGQzLnJlYmluZChwYywgZXZlbnRzLCAnb24nKTtcclxuXHJcbiAgLy8gZ2V0dGVyL3NldHRlciB3aXRoIGV2ZW50IGZpcmluZ1xyXG4gIGZ1bmN0aW9uIGdldHNldChvYmosIHN0YXRlLCBldmVudHMpIHtcclxuICAgIGQzLmtleXMoc3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICBvYmpba2V5XSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICByZXR1cm4gc3RhdGVba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9sZCA9IHN0YXRlW2tleV07XHJcbiAgICAgICAgc3RhdGVba2V5XSA9IHg7XHJcbiAgICAgICAgc2lkZV9lZmZlY3RzW2tleV0uY2FsbChwYywgeyB2YWx1ZTogeCwgcHJldmlvdXM6IG9sZCB9KTtcclxuICAgICAgICBldmVudHNba2V5XS5jYWxsKHBjLCB7IHZhbHVlOiB4LCBwcmV2aW91czogb2xkIH0pO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xyXG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdpdGhvdXQoYXJyLCBpdGVtKSB7XHJcbiAgICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoZWxlbSkge1xyXG4gICAgICByZXR1cm4gaXRlbS5pbmRleE9mKGVsZW0pID09PSAtMTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvKiogYWRqdXN0cyBhbiBheGlzJyBkZWZhdWx0IHJhbmdlIFtoKCkrMSwgMV0gaWYgYSBOdWxsVmFsdWVTZXBhcmF0b3IgaXMgc2V0ICovXHJcbiAgZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XHJcbiAgICBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICdib3R0b20nKSB7XHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgaCgpICtcclxuICAgICAgICAgIDEgLVxyXG4gICAgICAgICAgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20gLVxyXG4gICAgICAgICAgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3AsXHJcbiAgICAgICAgMSxcclxuICAgICAgXTtcclxuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICd0b3AnKSB7XHJcbiAgICAgIHJldHVybiBbXHJcbiAgICAgICAgaCgpICsgMSxcclxuICAgICAgICAxICtcclxuICAgICAgICAgIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tICtcclxuICAgICAgICAgIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wLFxyXG4gICAgICBdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFtoKCkgKyAxLCAxXTtcclxuICB9XHJcblxyXG4gIHBjLmF1dG9zY2FsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHlzY2FsZVxyXG4gICAgdmFyIGRlZmF1bHRTY2FsZXMgPSB7XHJcbiAgICAgIGRhdGU6IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgdmFyIGV4dGVudCA9IGQzLmV4dGVudChfXy5kYXRhLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGRba10gPyBkW2tdLmdldFRpbWUoKSA6IG51bGw7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcclxuICAgICAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcclxuICAgICAgICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkuZG9tYWluKFtleHRlbnRbMF1dKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkMy50aW1lLnNjYWxlKCkuZG9tYWluKGV4dGVudCkucmFuZ2UoZ2V0UmFuZ2UoKSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIG51bWJlcjogZnVuY3Rpb24gKGspIHtcclxuICAgICAgICB2YXIgZXh0ZW50ID0gZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gK2Rba107XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZSBpZiBzaW5nbGUgdmFsdWVcclxuICAgICAgICBpZiAoZXh0ZW50WzBdID09PSBleHRlbnRbMV0pIHtcclxuICAgICAgICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkuZG9tYWluKFtleHRlbnRbMF1dKS5yYW5nZVBvaW50cyhnZXRSYW5nZSgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBkMy5zY2FsZS5saW5lYXIoKS5kb21haW4oZXh0ZW50KS5yYW5nZShnZXRSYW5nZSgpKTtcclxuICAgICAgfSxcclxuICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoaykge1xyXG4gICAgICAgIHZhciBjb3VudHMgPSB7fSxcclxuICAgICAgICAgIGRvbWFpbiA9IFtdO1xyXG5cclxuICAgICAgICAvLyBMZXQncyBnZXQgdGhlIGNvdW50IGZvciBlYWNoIHZhbHVlIHNvIHRoYXQgd2UgY2FuIHNvcnQgdGhlIGRvbWFpbiBiYXNlZFxyXG4gICAgICAgIC8vIG9uIHRoZSBudW1iZXIgb2YgaXRlbXMgZm9yIGVhY2ggdmFsdWUuXHJcbiAgICAgICAgX18uZGF0YS5tYXAoZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgIGlmIChwW2tdID09PSB1bmRlZmluZWQgJiYgX18ubnVsbFZhbHVlU2VwYXJhdG9yICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIG51bGwgdmFsdWVzIHdpbGwgYmUgZHJhd24gYmV5b25kIHRoZSBob3Jpem9udGFsIG51bGwgdmFsdWUgc2VwYXJhdG9yIVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKGNvdW50c1twW2tdXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvdW50c1twW2tdXSA9IDE7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb3VudHNbcFtrXV0gPSBjb3VudHNbcFtrXV0gKyAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBkb21haW4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb3VudHMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICAgIHJldHVybiBjb3VudHNbYV0gLSBjb3VudHNbYl07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkuZG9tYWluKGRvbWFpbikucmFuZ2VQb2ludHMoZ2V0UmFuZ2UoKSk7XHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xyXG4gICAgICB5c2NhbGVba10gPSBkZWZhdWx0U2NhbGVzW19fLnR5cGVzW2tdXShrKTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9fLmhpZGVBeGlzLmZvckVhY2goZnVuY3Rpb24gKGspIHtcclxuICAgICAgeXNjYWxlW2tdID0gZGVmYXVsdFNjYWxlc1tfXy50eXBlc1trXV0oayk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyB4c2NhbGVcclxuICAgIHhzY2FsZS5yYW5nZVBvaW50cyhbMCwgdygpXSwgMSk7XHJcblxyXG4gICAgLy8gY2FudmFzIHNpemVzXHJcbiAgICBwYy5zZWxlY3Rpb25cclxuICAgICAgLnNlbGVjdEFsbCgnY2FudmFzJylcclxuICAgICAgLnN0eWxlKCdtYXJnaW4tdG9wJywgX18ubWFyZ2luLnRvcCArICdweCcpXHJcbiAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCBfXy5tYXJnaW4ubGVmdCArICdweCcpXHJcbiAgICAgIC5hdHRyKCd3aWR0aCcsIHcoKSArIDIpXHJcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBoKCkgKyAyKTtcclxuXHJcbiAgICAvLyBkZWZhdWx0IHN0eWxlcywgbmVlZHMgdG8gYmUgc2V0IHdoZW4gY2FudmFzIHdpZHRoIGNoYW5nZXNcclxuICAgIGN0eC5mb3JlZ3JvdW5kLnN0cm9rZVN0eWxlID0gX18uY29sb3I7XHJcbiAgICBjdHguZm9yZWdyb3VuZC5saW5lV2lkdGggPSAxLjQ7XHJcbiAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBfXy5jb21wb3NpdGU7XHJcbiAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xyXG4gICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBfXy5icnVzaGVkQ29sb3I7XHJcbiAgICBjdHguYnJ1c2hlZC5saW5lV2lkdGggPSAxLjQ7XHJcbiAgICBjdHguYnJ1c2hlZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBfXy5jb21wb3NpdGU7XHJcbiAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xyXG4gICAgY3R4LmhpZ2hsaWdodC5saW5lV2lkdGggPSAzO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIHBjLnNjYWxlID0gZnVuY3Rpb24gKGQsIGRvbWFpbikge1xyXG4gICAgeXNjYWxlW2RdLmRvbWFpbihkb21haW4pO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIHBjLmZsaXAgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgLy95c2NhbGVbZF0uZG9tYWluKCkucmV2ZXJzZSgpOyAgICAgICAgIC8vIGRvZXMgbm90IHdvcmtcclxuICAgIHlzY2FsZVtkXS5kb21haW4oeXNjYWxlW2RdLmRvbWFpbigpLnJldmVyc2UoKSk7IC8vIHdvcmtzXHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgcGMuY29tbW9uU2NhbGUgPSBmdW5jdGlvbiAoZ2xvYmFsLCB0eXBlKSB7XHJcbiAgICB2YXIgdCA9IHR5cGUgfHwgJ251bWJlcic7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgZ2xvYmFsID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBzY2FsZXMgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgdmFyIHNjYWxlcyA9IF9fLmRpbWVuc2lvbnMuY29uY2F0KF9fLmhpZGVBeGlzKS5maWx0ZXIoZnVuY3Rpb24gKHApIHtcclxuICAgICAgcmV0dXJuIF9fLnR5cGVzW3BdID09IHQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoZ2xvYmFsKSB7XHJcbiAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoXHJcbiAgICAgICAgc2NhbGVzXHJcbiAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwLCBpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB5c2NhbGVbcF0uZG9tYWluKCk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgKTtcclxuXHJcbiAgICAgIHNjYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgeXNjYWxlW2RdLmRvbWFpbihleHRlbnQpO1xyXG4gICAgICB9KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNjYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgeXNjYWxlW2tdLmRvbWFpbihcclxuICAgICAgICAgIGQzLmV4dGVudChfXy5kYXRhLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gK2Rba107XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB1cGRhdGUgY2VudHJvaWRzXHJcbiAgICBpZiAoX18uYnVuZGxlRGltZW5zaW9uICE9PSBudWxsKSB7XHJcbiAgICAgIHBjLmJ1bmRsZURpbWVuc2lvbihfXy5idW5kbGVEaW1lbnNpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcbiAgcGMuZGV0ZWN0RGltZW5zaW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHBjLnR5cGVzKHBjLmRldGVjdERpbWVuc2lvblR5cGVzKF9fLmRhdGEpKTtcclxuICAgIHBjLmRpbWVuc2lvbnMoZDMua2V5cyhwYy50eXBlcygpKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBhIGJldHRlciBcInR5cGVvZlwiIGZyb20gdGhpcyBwb3N0OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczOTA0MjYvYmV0dGVyLXdheS10by1nZXQtdHlwZS1vZi1hLWphdmFzY3JpcHQtdmFyaWFibGVcclxuICBwYy50b1R5cGUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nXHJcbiAgICAgIC5jYWxsKHYpXHJcbiAgICAgIC5tYXRjaCgvXFxzKFthLXpBLVpdKykvKVsxXVxyXG4gICAgICAudG9Mb3dlckNhc2UoKTtcclxuICB9O1xyXG5cclxuICAvLyB0cnkgdG8gY29lcmNlIHRvIG51bWJlciBiZWZvcmUgcmV0dXJuaW5nIHR5cGVcclxuICBwYy50b1R5cGVDb2VyY2VOdW1iZXJzID0gZnVuY3Rpb24gKHYpIHtcclxuICAgIGlmIChwYXJzZUZsb2F0KHYpID09IHYgJiYgdiAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiAnbnVtYmVyJztcclxuICAgIH1cclxuICAgIHJldHVybiBwYy50b1R5cGUodik7XHJcbiAgfTtcclxuXHJcbiAgLy8gYXR0ZW1wdCB0byBkZXRlcm1pbmUgdHlwZXMgb2YgZWFjaCBkaW1lbnNpb24gYmFzZWQgb24gZmlyc3Qgcm93IG9mIGRhdGFcclxuICBwYy5kZXRlY3REaW1lbnNpb25UeXBlcyA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICB2YXIgdHlwZXMgPSB7fTtcclxuICAgIGQzLmtleXMoZGF0YVswXSkuZm9yRWFjaChmdW5jdGlvbiAoY29sKSB7XHJcbiAgICAgIHR5cGVzW2NvbF0gPSBwYy50b1R5cGVDb2VyY2VOdW1iZXJzKGRhdGFbMF1bY29sXSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0eXBlcztcclxuICB9O1xyXG4gIHBjLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHRyeSB0byBhdXRvZGV0ZWN0IGRpbWVuc2lvbnMgYW5kIGNyZWF0ZSBzY2FsZXNcclxuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcclxuICAgIGlmICghKF9fLmRpbWVuc2lvbnNbMF0gaW4geXNjYWxlKSkgcGMuYXV0b3NjYWxlKCk7XHJcblxyXG4gICAgcGMucmVuZGVyW19fLm1vZGVdKCk7XHJcblxyXG4gICAgZXZlbnRzLnJlbmRlci5jYWxsKHRoaXMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgcGMucmVuZGVyQnJ1c2hlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcclxuICAgIGlmICghKF9fLmRpbWVuc2lvbnNbMF0gaW4geXNjYWxlKSkgcGMuYXV0b3NjYWxlKCk7XHJcblxyXG4gICAgcGMucmVuZGVyQnJ1c2hlZFtfXy5tb2RlXSgpO1xyXG5cclxuICAgIGV2ZW50cy5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGlzQnJ1c2hlZCgpIHtcclxuICAgIGlmIChfXy5icnVzaGVkICYmIF9fLmJydXNoZWQubGVuZ3RoICE9PSBfXy5kYXRhLmxlbmd0aCkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgdmFyIG9iamVjdCA9IGJydXNoLmN1cnJlbnRNb2RlKCkuYnJ1c2hTdGF0ZSgpO1xyXG5cclxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcclxuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHBjLnJlbmRlci5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcGMuY2xlYXIoJ2ZvcmVncm91bmQnKTtcclxuICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcclxuXHJcbiAgICBwYy5yZW5kZXJCcnVzaGVkLmRlZmF1bHQoKTtcclxuXHJcbiAgICBfXy5kYXRhLmZvckVhY2gocGF0aF9mb3JlZ3JvdW5kKTtcclxuICB9O1xyXG5cclxuICB2YXIgZm9yZWdyb3VuZFF1ZXVlID0gZDNcclxuICAgIC5yZW5kZXJRdWV1ZShwYXRoX2ZvcmVncm91bmQpXHJcbiAgICAucmF0ZSg1MClcclxuICAgIC5jbGVhcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHBjLmNsZWFyKCdmb3JlZ3JvdW5kJyk7XHJcbiAgICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcclxuICAgIH0pO1xyXG5cclxuICBwYy5yZW5kZXIucXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBwYy5yZW5kZXJCcnVzaGVkLnF1ZXVlKCk7XHJcblxyXG4gICAgZm9yZWdyb3VuZFF1ZXVlKF9fLmRhdGEpO1xyXG4gIH07XHJcblxyXG4gIHBjLnJlbmRlckJydXNoZWQuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHBjLmNsZWFyKCdicnVzaGVkJyk7XHJcblxyXG4gICAgaWYgKGlzQnJ1c2hlZCgpKSB7XHJcbiAgICAgIF9fLmJydXNoZWQuZm9yRWFjaChwYXRoX2JydXNoZWQpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBicnVzaGVkUXVldWUgPSBkM1xyXG4gICAgLnJlbmRlclF1ZXVlKHBhdGhfYnJ1c2hlZClcclxuICAgIC5yYXRlKDUwKVxyXG4gICAgLmNsZWFyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcGMuY2xlYXIoJ2JydXNoZWQnKTtcclxuICAgIH0pO1xyXG5cclxuICBwYy5yZW5kZXJCcnVzaGVkLnF1ZXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKGlzQnJ1c2hlZCgpKSB7XHJcbiAgICAgIGJydXNoZWRRdWV1ZShfXy5icnVzaGVkKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJydXNoZWRRdWV1ZShbXSk7IC8vIFRoaXMgaXMgbmVlZGVkIHRvIGNsZWFyIHRoZSBjdXJyZW50bHkgYnJ1c2hlZCBpdGVtc1xyXG4gICAgfVxyXG4gIH07XHJcbiAgZnVuY3Rpb24gY29tcHV0ZV9jbHVzdGVyX2NlbnRyb2lkcyhkKSB7XHJcbiAgICB2YXIgY2x1c3RlckNlbnRyb2lkcyA9IGQzLm1hcCgpO1xyXG4gICAgdmFyIGNsdXN0ZXJDb3VudHMgPSBkMy5tYXAoKTtcclxuICAgIC8vIGRldGVybWluZSBjbHVzdGVyQ291bnRzXHJcbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICB2YXIgc2NhbGVkID0geXNjYWxlW2RdKHJvd1tkXSk7XHJcbiAgICAgIGlmICghY2x1c3RlckNvdW50cy5oYXMoc2NhbGVkKSkge1xyXG4gICAgICAgIGNsdXN0ZXJDb3VudHMuc2V0KHNjYWxlZCwgMCk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGNvdW50ID0gY2x1c3RlckNvdW50cy5nZXQoc2NhbGVkKTtcclxuICAgICAgY2x1c3RlckNvdW50cy5zZXQoc2NhbGVkLCBjb3VudCArIDEpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgX18uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgX18uZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcclxuICAgICAgICB2YXIgc2NhbGVkID0geXNjYWxlW2RdKHJvd1tkXSk7XHJcbiAgICAgICAgaWYgKCFjbHVzdGVyQ2VudHJvaWRzLmhhcyhzY2FsZWQpKSB7XHJcbiAgICAgICAgICB2YXIgbWFwID0gZDMubWFwKCk7XHJcbiAgICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLnNldChzY2FsZWQsIG1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5oYXMocCkpIHtcclxuICAgICAgICAgIGNsdXN0ZXJDZW50cm9pZHMuZ2V0KHNjYWxlZCkuc2V0KHAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmFsdWUgPSBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLmdldChwKTtcclxuICAgICAgICB2YWx1ZSArPSB5c2NhbGVbcF0ocm93W3BdKSAvIGNsdXN0ZXJDb3VudHMuZ2V0KHNjYWxlZCk7XHJcbiAgICAgICAgY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5zZXQocCwgdmFsdWUpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBjbHVzdGVyQ2VudHJvaWRzO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcHV0ZV9jZW50cm9pZHMocm93KSB7XHJcbiAgICB2YXIgY2VudHJvaWRzID0gW107XHJcblxyXG4gICAgdmFyIHAgPSBfXy5kaW1lbnNpb25zO1xyXG4gICAgdmFyIGNvbHMgPSBwLmxlbmd0aDtcclxuICAgIHZhciBhID0gMC41OyAvLyBjZW50ZXIgYmV0d2VlbiBheGVzXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHM7ICsraSkge1xyXG4gICAgICAvLyBjZW50cm9pZHMgb24gJ3JlYWwnIGF4ZXNcclxuICAgICAgdmFyIHggPSBwb3NpdGlvbihwW2ldKTtcclxuICAgICAgdmFyIHkgPSB5c2NhbGVbcFtpXV0ocm93W3BbaV1dKTtcclxuICAgICAgY2VudHJvaWRzLnB1c2goJFYoW3gsIHldKSk7XHJcblxyXG4gICAgICAvLyBjZW50cm9pZHMgb24gJ3ZpcnR1YWwnIGF4ZXNcclxuICAgICAgaWYgKGkgPCBjb2xzIC0gMSkge1xyXG4gICAgICAgIHZhciBjeCA9IHggKyBhICogKHBvc2l0aW9uKHBbaSArIDFdKSAtIHgpO1xyXG4gICAgICAgIHZhciBjeSA9IHkgKyBhICogKHlzY2FsZVtwW2kgKyAxXV0ocm93W3BbaSArIDFdXSkgLSB5KTtcclxuICAgICAgICBpZiAoX18uYnVuZGxlRGltZW5zaW9uICE9PSBudWxsKSB7XHJcbiAgICAgICAgICB2YXIgbGVmdENlbnRyb2lkID0gX18uY2x1c3RlckNlbnRyb2lkc1xyXG4gICAgICAgICAgICAuZ2V0KHlzY2FsZVtfXy5idW5kbGVEaW1lbnNpb25dKHJvd1tfXy5idW5kbGVEaW1lbnNpb25dKSlcclxuICAgICAgICAgICAgLmdldChwW2ldKTtcclxuICAgICAgICAgIHZhciByaWdodENlbnRyb2lkID0gX18uY2x1c3RlckNlbnRyb2lkc1xyXG4gICAgICAgICAgICAuZ2V0KHlzY2FsZVtfXy5idW5kbGVEaW1lbnNpb25dKHJvd1tfXy5idW5kbGVEaW1lbnNpb25dKSlcclxuICAgICAgICAgICAgLmdldChwW2kgKyAxXSk7XHJcbiAgICAgICAgICB2YXIgY2VudHJvaWQgPSAwLjUgKiAobGVmdENlbnRyb2lkICsgcmlnaHRDZW50cm9pZCk7XHJcbiAgICAgICAgICBjeSA9IGNlbnRyb2lkICsgKDEgLSBfXy5idW5kbGluZ1N0cmVuZ3RoKSAqIChjeSAtIGNlbnRyb2lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2VudHJvaWRzLnB1c2goJFYoW2N4LCBjeV0pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjZW50cm9pZHM7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21wdXRlX2NvbnRyb2xfcG9pbnRzKGNlbnRyb2lkcykge1xyXG4gICAgdmFyIGNvbHMgPSBjZW50cm9pZHMubGVuZ3RoO1xyXG4gICAgdmFyIGEgPSBfXy5zbW9vdGhuZXNzO1xyXG4gICAgdmFyIGNwcyA9IFtdO1xyXG5cclxuICAgIGNwcy5wdXNoKGNlbnRyb2lkc1swXSk7XHJcbiAgICBjcHMucHVzaChcclxuICAgICAgJFYoW1xyXG4gICAgICAgIGNlbnRyb2lkc1swXS5lKDEpICsgYSAqIDIgKiAoY2VudHJvaWRzWzFdLmUoMSkgLSBjZW50cm9pZHNbMF0uZSgxKSksXHJcbiAgICAgICAgY2VudHJvaWRzWzBdLmUoMiksXHJcbiAgICAgIF0pLFxyXG4gICAgKTtcclxuICAgIGZvciAodmFyIGNvbCA9IDE7IGNvbCA8IGNvbHMgLSAxOyArK2NvbCkge1xyXG4gICAgICB2YXIgbWlkID0gY2VudHJvaWRzW2NvbF07XHJcbiAgICAgIHZhciBsZWZ0ID0gY2VudHJvaWRzW2NvbCAtIDFdO1xyXG4gICAgICB2YXIgcmlnaHQgPSBjZW50cm9pZHNbY29sICsgMV07XHJcblxyXG4gICAgICB2YXIgZGlmZiA9IGxlZnQuc3VidHJhY3QocmlnaHQpO1xyXG4gICAgICBjcHMucHVzaChtaWQuYWRkKGRpZmYueChhKSkpO1xyXG4gICAgICBjcHMucHVzaChtaWQpO1xyXG4gICAgICBjcHMucHVzaChtaWQuc3VidHJhY3QoZGlmZi54KGEpKSk7XHJcbiAgICB9XHJcbiAgICBjcHMucHVzaChcclxuICAgICAgJFYoW1xyXG4gICAgICAgIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgxKSArXHJcbiAgICAgICAgICBhICogMiAqIChjZW50cm9pZHNbY29scyAtIDJdLmUoMSkgLSBjZW50cm9pZHNbY29scyAtIDFdLmUoMSkpLFxyXG4gICAgICAgIGNlbnRyb2lkc1tjb2xzIC0gMV0uZSgyKSxcclxuICAgICAgXSksXHJcbiAgICApO1xyXG4gICAgY3BzLnB1c2goY2VudHJvaWRzW2NvbHMgLSAxXSk7XHJcblxyXG4gICAgcmV0dXJuIGNwcztcclxuICB9XHJcblxyXG4gIHBjLnNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBmbGFncy5zaGFkb3dzID0gdHJ1ZTtcclxuICAgIHBjLmFscGhhT25CcnVzaGVkKDAuMSk7XHJcbiAgICBwYy5yZW5kZXIoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIGRyYXcgZG90cyB3aXRoIHJhZGl1cyByIG9uIHRoZSBheGlzIGxpbmUgd2hlcmUgZGF0YSBpbnRlcnNlY3RzXHJcbiAgcGMuYXhpc0RvdHMgPSBmdW5jdGlvbiAocikge1xyXG4gICAgdmFyIHIgPSByIHx8IDAuMTtcclxuICAgIHZhciBjdHggPSBwYy5jdHgubWFya3M7XHJcbiAgICB2YXIgc3RhcnRBbmdsZSA9IDA7XHJcbiAgICB2YXIgZW5kQW5nbGUgPSAyICogTWF0aC5QSTtcclxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IGQzLm1pbihbMSAvIE1hdGgucG93KF9fLmRhdGEubGVuZ3RoLCAxIC8gMiksIDFdKTtcclxuICAgIF9fLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICBfXy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocCwgaSkge1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguYXJjKHBvc2l0aW9uKHApLCB5c2NhbGVbcF0oZFtwXSksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIGRyYXcgc2luZ2xlIGN1YmljIGJlemllciBjdXJ2ZVxyXG4gIGZ1bmN0aW9uIHNpbmdsZV9jdXJ2ZShkLCBjdHgpIHtcclxuICAgIHZhciBjZW50cm9pZHMgPSBjb21wdXRlX2NlbnRyb2lkcyhkKTtcclxuICAgIHZhciBjcHMgPSBjb21wdXRlX2NvbnRyb2xfcG9pbnRzKGNlbnRyb2lkcyk7XHJcblxyXG4gICAgY3R4Lm1vdmVUbyhjcHNbMF0uZSgxKSwgY3BzWzBdLmUoMikpO1xyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjcHMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgICAgaWYgKF9fLnNob3dDb250cm9sUG9pbnRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqICs9IDEpIHtcclxuICAgICAgICAgIGN0eC5maWxsUmVjdChjcHNbaSArIGpdLmUoMSksIGNwc1tpICsgal0uZSgyKSwgMiwgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxyXG4gICAgICAgIGNwc1tpXS5lKDEpLFxyXG4gICAgICAgIGNwc1tpXS5lKDIpLFxyXG4gICAgICAgIGNwc1tpICsgMV0uZSgxKSxcclxuICAgICAgICBjcHNbaSArIDFdLmUoMiksXHJcbiAgICAgICAgY3BzW2kgKyAyXS5lKDEpLFxyXG4gICAgICAgIGNwc1tpICsgMl0uZSgyKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIGRyYXcgc2luZ2xlIHBvbHlsaW5lXHJcbiAgZnVuY3Rpb24gY29sb3JfcGF0aChkLCBjdHgpIHtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGlmIChcclxuICAgICAgKF9fLmJ1bmRsZURpbWVuc2lvbiAhPT0gbnVsbCAmJiBfXy5idW5kbGluZ1N0cmVuZ3RoID4gMCkgfHxcclxuICAgICAgX18uc21vb3RobmVzcyA+IDBcclxuICAgICkge1xyXG4gICAgICBzaW5nbGVfY3VydmUoZCwgY3R4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHNpbmdsZV9wYXRoKGQsIGN0eCk7XHJcbiAgICB9XHJcbiAgICBjdHguc3Ryb2tlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBkcmF3IG1hbnkgcG9seWxpbmVzIG9mIHRoZSBzYW1lIGNvbG9yXHJcbiAgZnVuY3Rpb24gcGF0aHMoZGF0YSwgY3R4KSB7XHJcbiAgICBjdHguY2xlYXJSZWN0KC0xLCAtMSwgdygpICsgMiwgaCgpICsgMik7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwgJiYgX18uYnVuZGxpbmdTdHJlbmd0aCA+IDApIHx8XHJcbiAgICAgICAgX18uc21vb3RobmVzcyA+IDBcclxuICAgICAgKSB7XHJcbiAgICAgICAgc2luZ2xlX2N1cnZlKGQsIGN0eCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2luZ2xlX3BhdGgoZCwgY3R4KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjdHguc3Ryb2tlKCk7XHJcbiAgfVxyXG5cclxuICAvLyByZXR1cm5zIHRoZSB5LXBvc2l0aW9uIGp1c3QgYmV5b25kIHRoZSBzZXBhcmF0aW5nIG51bGwgdmFsdWUgbGluZVxyXG4gIGZ1bmN0aW9uIGdldE51bGxQb3NpdGlvbigpIHtcclxuICAgIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ2JvdHRvbScpIHtcclxuICAgICAgcmV0dXJuIGgoKSArIDE7XHJcbiAgICB9IGVsc2UgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgIFwiQSB2YWx1ZSBpcyBOVUxMLCBidXQgbnVsbFZhbHVlU2VwYXJhdG9yIGlzIG5vdCBzZXQ7IHNldCBpdCB0byAnYm90dG9tJyBvciAndG9wJy5cIixcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoKCkgKyAxO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2luZ2xlX3BhdGgoZCwgY3R4KSB7XHJcbiAgICBfXy5kaW1lbnNpb25zLm1hcChmdW5jdGlvbiAocCwgaSkge1xyXG4gICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhcclxuICAgICAgICAgIHBvc2l0aW9uKHApLFxyXG4gICAgICAgICAgdHlwZW9mIGRbcF0gPT0gJ3VuZGVmaW5lZCcgPyBnZXROdWxsUG9zaXRpb24oKSA6IHlzY2FsZVtwXShkW3BdKSxcclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN0eC5saW5lVG8oXHJcbiAgICAgICAgICBwb3NpdGlvbihwKSxcclxuICAgICAgICAgIHR5cGVvZiBkW3BdID09ICd1bmRlZmluZWQnID8gZ2V0TnVsbFBvc2l0aW9uKCkgOiB5c2NhbGVbcF0oZFtwXSksXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXRoX2JydXNoZWQoZCwgaSkge1xyXG4gICAgaWYgKF9fLmJydXNoZWRDb2xvciAhPT0gbnVsbCkge1xyXG4gICAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uYnJ1c2hlZENvbG9yKShkLCBpKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5jb2xvcikoZCwgaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29sb3JfcGF0aChkLCBjdHguYnJ1c2hlZCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwYXRoX2ZvcmVncm91bmQoZCwgaSkge1xyXG4gICAgY3R4LmZvcmVncm91bmQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmNvbG9yKShkLCBpKTtcclxuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5mb3JlZ3JvdW5kKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBhdGhfaGlnaGxpZ2h0KGQsIGkpIHtcclxuICAgIGN0eC5oaWdobGlnaHQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmNvbG9yKShkLCBpKTtcclxuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5oaWdobGlnaHQpO1xyXG4gIH1cclxuICBwYy5jbGVhciA9IGZ1bmN0aW9uIChsYXllcikge1xyXG4gICAgY3R4W2xheWVyXS5jbGVhclJlY3QoMCwgMCwgdygpICsgMiwgaCgpICsgMik7XHJcblxyXG4gICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSBmb3JlZ3JvdW5kIGl0ZW1zIGFyZSB0cmFuc3BhcmVudFxyXG4gICAgLy8gd2l0aG91dCB0aGUgbmVlZCBmb3IgY2hhbmdpbmcgdGhlIG9wYWNpdHkgc3R5bGUgb2YgdGhlIGZvcmVncm91bmQgY2FudmFzXHJcbiAgICAvLyBhcyB0aGlzIHdvdWxkIHN0b3AgdGhlIGNzcyBzdHlsaW5nIGZyb20gd29ya2luZ1xyXG4gICAgaWYgKGxheWVyID09PSAnYnJ1c2hlZCcgJiYgaXNCcnVzaGVkKCkpIHtcclxuICAgICAgY3R4LmJydXNoZWQuZmlsbFN0eWxlID0gcGMuc2VsZWN0aW9uLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XHJcbiAgICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gMSAtIF9fLmFscGhhT25CcnVzaGVkO1xyXG4gICAgICBjdHguYnJ1c2hlZC5maWxsUmVjdCgwLCAwLCB3KCkgKyAyLCBoKCkgKyAyKTtcclxuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSBfXy5hbHBoYTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIGQzLnJlYmluZChcclxuICAgIHBjLFxyXG4gICAgYXhpcyxcclxuICAgICd0aWNrcycsXHJcbiAgICAnb3JpZW50JyxcclxuICAgICd0aWNrVmFsdWVzJyxcclxuICAgICd0aWNrU3ViZGl2aWRlJyxcclxuICAgICd0aWNrU2l6ZScsXHJcbiAgICAndGlja1BhZGRpbmcnLFxyXG4gICAgJ3RpY2tGb3JtYXQnLFxyXG4gICk7XHJcblxyXG4gIGZ1bmN0aW9uIGZsaXBBeGlzQW5kVXBkYXRlUENQKGRpbWVuc2lvbikge1xyXG4gICAgdmFyIGcgPSBwYy5zdmcuc2VsZWN0QWxsKCcuZGltZW5zaW9uJyk7XHJcblxyXG4gICAgcGMuZmxpcChkaW1lbnNpb24pO1xyXG5cclxuICAgIGQzLnNlbGVjdCh0aGlzLnBhcmVudEVsZW1lbnQpXHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKDExMDApXHJcbiAgICAgIC5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RpbWVuc2lvbl0pKTtcclxuXHJcbiAgICBwYy5yZW5kZXIoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJvdGF0ZUxhYmVscygpIHtcclxuICAgIHZhciBkZWx0YSA9IGQzLmV2ZW50LmRlbHRhWTtcclxuICAgIGRlbHRhID0gZGVsdGEgPCAwID8gLTUgOiBkZWx0YTtcclxuICAgIGRlbHRhID0gZGVsdGEgPiAwID8gNSA6IGRlbHRhO1xyXG5cclxuICAgIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKz0gZGVsdGE7XHJcbiAgICBwYy5zdmdcclxuICAgICAgLnNlbGVjdEFsbCgndGV4dC5sYWJlbCcpXHJcbiAgICAgIC5hdHRyKFxyXG4gICAgICAgICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICd0cmFuc2xhdGUoMCwtNSkgcm90YXRlKCcgKyBfXy5kaW1lbnNpb25UaXRsZVJvdGF0aW9uICsgJyknLFxyXG4gICAgICApO1xyXG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRpbWVuc2lvbkxhYmVscyhkKSB7XHJcbiAgICByZXR1cm4gZCBpbiBfXy5kaW1lbnNpb25UaXRsZXMgPyBfXy5kaW1lbnNpb25UaXRsZXNbZF0gOiBkOyAvLyBkaW1lbnNpb24gZGlzcGxheSBuYW1lc1xyXG4gIH1cclxuXHJcbiAgcGMuY3JlYXRlQXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmIChnKSBwYy5yZW1vdmVBeGVzKCk7XHJcblxyXG4gICAgLy8gQWRkIGEgZ3JvdXAgZWxlbWVudCBmb3IgZWFjaCBkaW1lbnNpb24uXHJcbiAgICBnID0gcGMuc3ZnXHJcbiAgICAgIC5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKVxyXG4gICAgICAuZGF0YShfXy5kaW1lbnNpb25zLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBkO1xyXG4gICAgICB9KVxyXG4gICAgICAuZW50ZXIoKVxyXG4gICAgICAuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdkaW1lbnNpb24nKVxyXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAvLyBBZGQgYW4gYXhpcyBhbmQgdGl0bGUuXHJcbiAgICBnLmFwcGVuZCgnc3ZnOmcnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCAnYXhpcycpXHJcbiAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKVxyXG4gICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5hcHBlbmQoJ3N2Zzp0ZXh0JylcclxuICAgICAgLmF0dHIoe1xyXG4gICAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxyXG4gICAgICAgIHk6IDAsXHJcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyxcclxuICAgICAgICB4OiAwLFxyXG4gICAgICAgIGNsYXNzOiAnbGFiZWwnLFxyXG4gICAgICB9KVxyXG4gICAgICAudGV4dChkaW1lbnNpb25MYWJlbHMpXHJcbiAgICAgIC5vbignZGJsY2xpY2snLCBmbGlwQXhpc0FuZFVwZGF0ZVBDUClcclxuICAgICAgLm9uKCd3aGVlbCcsIHJvdGF0ZUxhYmVscyk7XHJcblxyXG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAndG9wJykge1xyXG4gICAgICBwYy5zdmdcclxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgIC5hdHRyKCd5MScsIDEgKyBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcClcclxuICAgICAgICAuYXR0cigneDInLCB3KCkpXHJcbiAgICAgICAgLmF0dHIoJ3kyJywgMSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnIzc3NycpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgLmF0dHIoJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyk7XHJcbiAgICB9IGVsc2UgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xyXG4gICAgICBwYy5zdmdcclxuICAgICAgICAuYXBwZW5kKCdsaW5lJylcclxuICAgICAgICAuYXR0cigneDEnLCAwKVxyXG4gICAgICAgIC5hdHRyKCd5MScsIGgoKSArIDEgLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSlcclxuICAgICAgICAuYXR0cigneDInLCB3KCkpXHJcbiAgICAgICAgLmF0dHIoJ3kyJywgaCgpICsgMSAtIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAxKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnIzc3NycpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnbm9uZScpXHJcbiAgICAgICAgLmF0dHIoJ3NoYXBlLXJlbmRlcmluZycsICdjcmlzcEVkZ2VzJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZmxhZ3MuYXhlcyA9IHRydWU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICBwYy5yZW1vdmVBeGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgZy5yZW1vdmUoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIHBjLnVwZGF0ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZ19kYXRhID0gcGMuc3ZnLnNlbGVjdEFsbCgnLmRpbWVuc2lvbicpLmRhdGEoX18uZGltZW5zaW9ucyk7XHJcblxyXG4gICAgLy8gRW50ZXJcclxuICAgIGdfZGF0YVxyXG4gICAgICAuZW50ZXIoKVxyXG4gICAgICAuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdkaW1lbnNpb24nKVxyXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKHApIHtcclxuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgcG9zaXRpb24ocCkgKyAnKSc7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDApXHJcbiAgICAgIC5hcHBlbmQoJ3N2ZzpnJylcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMnKVxyXG4gICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDApJylcclxuICAgICAgLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkXSkpO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXBwZW5kKCdzdmc6dGV4dCcpXHJcbiAgICAgIC5hdHRyKHtcclxuICAgICAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcclxuICAgICAgICB5OiAwLFxyXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScsXHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICBjbGFzczogJ2xhYmVsJyxcclxuICAgICAgfSlcclxuICAgICAgLnRleHQoZGltZW5zaW9uTGFiZWxzKVxyXG4gICAgICAub24oJ2RibGNsaWNrJywgZmxpcEF4aXNBbmRVcGRhdGVQQ1ApXHJcbiAgICAgIC5vbignd2hlZWwnLCByb3RhdGVMYWJlbHMpO1xyXG5cclxuICAgIC8vIFVwZGF0ZVxyXG4gICAgZ19kYXRhLmF0dHIoJ29wYWNpdHknLCAwKTtcclxuICAgIGdfZGF0YVxyXG4gICAgICAuc2VsZWN0KCcuYXhpcycpXHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKDExMDApXHJcbiAgICAgIC5lYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZF0pKTtcclxuICAgICAgfSk7XHJcbiAgICBnX2RhdGFcclxuICAgICAgLnNlbGVjdCgnLmxhYmVsJylcclxuICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAuZHVyYXRpb24oMTEwMClcclxuICAgICAgLnRleHQoZGltZW5zaW9uTGFiZWxzKVxyXG4gICAgICAuYXR0cihcclxuICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyxcclxuICAgICAgKTtcclxuXHJcbiAgICAvLyBFeGl0XHJcbiAgICBnX2RhdGEuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuICAgIGcgPSBwYy5zdmcuc2VsZWN0QWxsKCcuZGltZW5zaW9uJyk7XHJcbiAgICBnLnRyYW5zaXRpb24oKVxyXG4gICAgICAuZHVyYXRpb24oMTEwMClcclxuICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKHApICsgJyknO1xyXG4gICAgICB9KVxyXG4gICAgICAuc3R5bGUoJ29wYWNpdHknLCAxKTtcclxuXHJcbiAgICBwYy5zdmdcclxuICAgICAgLnNlbGVjdEFsbCgnLmF4aXMnKVxyXG4gICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgIC5kdXJhdGlvbigxMTAwKVxyXG4gICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIGlmIChmbGFncy5icnVzaGFibGUpIHBjLmJydXNoYWJsZSgpO1xyXG4gICAgaWYgKGZsYWdzLnJlb3JkZXJhYmxlKSBwYy5yZW9yZGVyYWJsZSgpO1xyXG4gICAgaWYgKHBjLmJydXNoTW9kZSgpICE9PSAnTm9uZScpIHtcclxuICAgICAgdmFyIG1vZGUgPSBwYy5icnVzaE1vZGUoKTtcclxuICAgICAgcGMuYnJ1c2hNb2RlKCdOb25lJyk7XHJcbiAgICAgIHBjLmJydXNoTW9kZShtb2RlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIEphc29uIERhdmllcywgaHR0cDovL2JsLm9ja3Mub3JnLzEzNDEyODFcclxuICBwYy5yZW9yZGVyYWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghZykgcGMuY3JlYXRlQXhlcygpO1xyXG5cclxuICAgIGcuc3R5bGUoJ2N1cnNvcicsICdtb3ZlJykuY2FsbChcclxuICAgICAgZDMuYmVoYXZpb3JcclxuICAgICAgICAuZHJhZygpXHJcbiAgICAgICAgLm9uKCdkcmFnc3RhcnQnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgZHJhZ2dpbmdbZF0gPSB0aGlzLl9fb3JpZ2luX18gPSB4c2NhbGUoZCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgZHJhZ2dpbmdbZF0gPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgdygpLFxyXG4gICAgICAgICAgICBNYXRoLm1heCgwLCAodGhpcy5fX29yaWdpbl9fICs9IGQzLmV2ZW50LmR4KSksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgX18uZGltZW5zaW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbihhKSAtIHBvc2l0aW9uKGIpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICB4c2NhbGUuZG9tYWluKF9fLmRpbWVuc2lvbnMpO1xyXG4gICAgICAgICAgcGMucmVuZGVyKCk7XHJcbiAgICAgICAgICBnLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBwb3NpdGlvbihkKSArICcpJztcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdkcmFnZW5kJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIC8vIExldCdzIHNlZSBpZiB0aGUgb3JkZXIgaGFzIGNoYW5nZWQgYW5kIHNlbmQgb3V0IGFuIGV2ZW50IGlmIHNvLlxyXG4gICAgICAgICAgdmFyIGkgPSAwLFxyXG4gICAgICAgICAgICBqID0gX18uZGltZW5zaW9ucy5pbmRleE9mKGQpLFxyXG4gICAgICAgICAgICBlbGVtID0gdGhpcyxcclxuICAgICAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnRFbGVtZW50O1xyXG5cclxuICAgICAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZykgIT0gbnVsbCkgKytpO1xyXG4gICAgICAgICAgaWYgKGkgIT09IGopIHtcclxuICAgICAgICAgICAgZXZlbnRzLmF4ZXNyZW9yZGVyLmNhbGwocGMsIF9fLmRpbWVuc2lvbnMpO1xyXG4gICAgICAgICAgICAvLyBXZSBub3cgYWxzbyB3YW50IHRvIHJlb3JkZXIgdGhlIGFjdHVhbCBkb20gZWxlbWVudHMgdGhhdCByZXByZXNlbnRcclxuICAgICAgICAgICAgLy8gdGhlIGF4ZXMuIFRoYXQgaXMsIHRoZSBnLmRpbWVuc2lvbiBlbGVtZW50cy4gSWYgd2UgZG9uJ3QgZG8gdGhpcyxcclxuICAgICAgICAgICAgLy8gd2UgZ2V0IGEgd2VpcmQgYW5kIGNvbmZ1c2luZyB0cmFuc2l0aW9uIHdoZW4gdXBkYXRlQXhlcyBpcyBjYWxsZWQuXHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZHVlIHRvIHRoZSBmYWN0IHRoYXQsIGluaXRpYWxseSB0aGUgbnRoIGcuZGltZW5zaW9uIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgbnRoIGF4aXMuIEhvd2V2ZXIsIGFmdGVyIGEgbWFudWFsIHJlb3JkZXJpbmcsXHJcbiAgICAgICAgICAgIC8vIHdpdGhvdXQgcmVvcmRlcmluZyB0aGUgZG9tIGVsZW1lbnRzLCB0aGUgbnRoIGRvbSBlbGVtZW50cyBubyBsb25nZXJcclxuICAgICAgICAgICAgLy8gbmVjZXNzYXJpbHkgcmVwcmVzZW50cyB0aGUgbnRoIGF4aXMuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIGkgaXMgdGhlIG9yaWdpbmFsIGluZGV4IG9mIHRoZSBkb20gZWxlbWVudFxyXG4gICAgICAgICAgICAvLyBqIGlzIHRoZSBuZXcgaW5kZXggb2YgdGhlIGRvbSBlbGVtZW50XHJcbiAgICAgICAgICAgIGlmIChpID4gaikge1xyXG4gICAgICAgICAgICAgIC8vIEVsZW1lbnQgbW92ZWQgbGVmdFxyXG4gICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgcGFyZW50LmNoaWxkcmVuW2ogLSAxXSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy8gRWxlbWVudCBtb3ZlZCByaWdodFxyXG4gICAgICAgICAgICAgIGlmIChqICsgMSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodGhpcywgcGFyZW50LmNoaWxkcmVuW2ogKyAxXSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5fX29yaWdpbl9fO1xyXG4gICAgICAgICAgZGVsZXRlIGRyYWdnaW5nW2RdO1xyXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpXHJcbiAgICAgICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHhzY2FsZShkKSArICcpJyk7XHJcbiAgICAgICAgICBwYy5yZW5kZXIoKTtcclxuICAgICAgICB9KSxcclxuICAgICk7XHJcbiAgICBmbGFncy5yZW9yZGVyYWJsZSA9IHRydWU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBSZW9yZGVyIGRpbWVuc2lvbnMsIHN1Y2ggdGhhdCB0aGUgaGlnaGVzdCB2YWx1ZSAodmlzdWFsbHkpIGlzIG9uIHRoZSBsZWZ0IGFuZFxyXG4gIC8vIHRoZSBsb3dlc3Qgb24gdGhlIHJpZ2h0LiBWaXN1YWwgdmFsdWVzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBkYXRhIHZhbHVlcyBpblxyXG4gIC8vIHRoZSBnaXZlbiByb3cuXHJcbiAgcGMucmVvcmRlciA9IGZ1bmN0aW9uIChyb3dkYXRhKSB7XHJcbiAgICB2YXIgZGltcyA9IF9fLmRpbWVuc2lvbnMuc2xpY2UoMCk7XHJcbiAgICBfXy5kaW1lbnNpb25zLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgdmFyIHBpeGVsRGlmZmVyZW5jZSA9IHlzY2FsZVthXShyb3dkYXRhW2FdKSAtIHlzY2FsZVtiXShyb3dkYXRhW2JdKTtcclxuXHJcbiAgICAgIC8vIEFycmF5LnNvcnQgaXMgbm90IG5lY2Vzc2FyaWx5IHN0YWJsZSwgdGhpcyBtZWFucyB0aGF0IGlmIHBpeGVsRGlmZmVyZW5jZSBpcyB6ZXJvXHJcbiAgICAgIC8vIHRoZSBvcmRlcmluZyBvZiBkaW1lbnNpb25zIG1pZ2h0IGNoYW5nZSB1bmV4cGVjdGVkbHkuIFRoaXMgaXMgc29sdmVkIGJ5IHNvcnRpbmcgb25cclxuICAgICAgLy8gdmFyaWFibGUgbmFtZSBpbiB0aGF0IGNhc2UuXHJcbiAgICAgIGlmIChwaXhlbERpZmZlcmVuY2UgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gYS5sb2NhbGVDb21wYXJlKGIpO1xyXG4gICAgICB9IC8vIGVsc2VcclxuICAgICAgcmV0dXJuIHBpeGVsRGlmZmVyZW5jZTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIE5PVEU6IHRoaXMgaXMgcmVsYXRpdmVseSBjaGVhcCBnaXZlbiB0aGF0OlxyXG4gICAgLy8gbnVtYmVyIG9mIGRpbWVuc2lvbnMgPCBudW1iZXIgb2YgZGF0YSBpdGVtc1xyXG4gICAgLy8gVGh1cyB3ZSBjaGVjayBlcXVhbGl0eSBvZiBvcmRlciB0byBwcmV2ZW50IHJlcmVuZGVyaW5nIHdoZW4gdGhpcyBpcyB0aGUgY2FzZS5cclxuICAgIHZhciByZW9yZGVyZWQgPSBmYWxzZTtcclxuICAgIGRpbXMuc29tZShmdW5jdGlvbiAodmFsLCBpbmRleCkge1xyXG4gICAgICByZW9yZGVyZWQgPSB2YWwgIT09IF9fLmRpbWVuc2lvbnNbaW5kZXhdO1xyXG4gICAgICByZXR1cm4gcmVvcmRlcmVkO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHJlb3JkZXJlZCkge1xyXG4gICAgICB4c2NhbGUuZG9tYWluKF9fLmRpbWVuc2lvbnMpO1xyXG4gICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBfXy5oaWdobGlnaHRlZC5zbGljZSgwKTtcclxuICAgICAgcGMudW5oaWdobGlnaHQoKTtcclxuXHJcbiAgICAgIGcudHJhbnNpdGlvbigpXHJcbiAgICAgICAgLmR1cmF0aW9uKDE1MDApXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeHNjYWxlKGQpICsgJyknO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICBwYy5yZW5kZXIoKTtcclxuXHJcbiAgICAgIC8vIHBjLmhpZ2hsaWdodCgpIGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgaGlnaGxpZ2h0ZWQgaXMgbGVuZ3RoIHplcm8sIHNvIHdlIGRvIHRoYXQgaGVyZS5cclxuICAgICAgaWYgKGhpZ2hsaWdodGVkLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIHBjLmhpZ2hsaWdodChoaWdobGlnaHRlZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBwYWlycyBvZiBhZGphY2VudCBkaW1lbnNpb25zXHJcbiAgcGMuYWRqYWNlbnRfcGFpcnMgPSBmdW5jdGlvbiAoYXJyKSB7XHJcbiAgICB2YXIgcmV0ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGggLSAxOyBpICs9IDEpIHtcclxuICAgICAgcmV0LnB1c2goW2FycltpXSwgYXJyW2kgKyAxXV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9O1xyXG5cclxuICB2YXIgYnJ1c2ggPSB7XHJcbiAgICBtb2Rlczoge1xyXG4gICAgICBOb25lOiB7XHJcbiAgICAgICAgaW5zdGFsbDogZnVuY3Rpb24gKHBjKSB7fSwgLy8gTm90aGluZyB0byBiZSBkb25lLlxyXG4gICAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKHBjKSB7fSwgLy8gTm90aGluZyB0byBiZSBkb25lLlxyXG4gICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfSwgLy8gTm90aGluZyB0byByZXR1cm5cclxuICAgICAgICBicnVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBtb2RlOiAnTm9uZScsXHJcbiAgICBwcmVkaWNhdGU6ICdBTkQnLFxyXG4gICAgY3VycmVudE1vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubW9kZXNbdGhpcy5tb2RlXTtcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCBmb3IgJ2xpdmUnIHVwZGF0ZXMgb2YgYnJ1c2hlcy4gVGhhdCBpcywgZHVyaW5nIHRoZVxyXG4gIC8vIHNwZWNpZmljYXRpb24gb2YgYSBicnVzaCwgdGhpcyBtZXRob2QgY2FuIGJlIGNhbGxlZCB0byB1cGRhdGUgdGhlIHZpZXcuXHJcbiAgLy9cclxuICAvLyBAcGFyYW0gbmV3U2VsZWN0aW9uIC0gVGhlIG5ldyBzZXQgb2YgZGF0YSBpdGVtcyB0aGF0IGlzIGN1cnJlbnRseSBjb250YWluZWRcclxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgYnkgdGhlIGJydXNoZXNcclxuICBmdW5jdGlvbiBicnVzaFVwZGF0ZWQobmV3U2VsZWN0aW9uKSB7XHJcbiAgICBfXy5icnVzaGVkID0gbmV3U2VsZWN0aW9uO1xyXG4gICAgZXZlbnRzLmJydXNoLmNhbGwocGMsIF9fLmJydXNoZWQpO1xyXG4gICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYnJ1c2hQcmVkaWNhdGUocHJlZGljYXRlKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGJydXNoLnByZWRpY2F0ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcmVkaWNhdGUgPSBTdHJpbmcocHJlZGljYXRlKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgaWYgKHByZWRpY2F0ZSAhPT0gJ0FORCcgJiYgcHJlZGljYXRlICE9PSAnT1InKSB7XHJcbiAgICAgIHRocm93ICdJbnZhbGlkIHByZWRpY2F0ZSAnICsgcHJlZGljYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGJydXNoLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcclxuICAgIF9fLmJydXNoZWQgPSBicnVzaC5jdXJyZW50TW9kZSgpLnNlbGVjdGVkKCk7XHJcbiAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XHJcbiAgICByZXR1cm4gcGM7XHJcbiAgfVxyXG5cclxuICBwYy5icnVzaE1vZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJydXNoLm1vZGVzKTtcclxuICB9O1xyXG5cclxuICBwYy5icnVzaE1vZGUgPSBmdW5jdGlvbiAobW9kZSkge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIGJydXNoLm1vZGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHBjLmJydXNoTW9kZXMoKS5pbmRleE9mKG1vZGUpID09PSAtMSkge1xyXG4gICAgICB0aHJvdyAncGMuYnJ1c2htb2RlOiBVbnN1cHBvcnRlZCBicnVzaCBtb2RlOiAnICsgbW9kZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCB0cmlnZ2VyIHVubmVjZXNzYXJ5IGV2ZW50cyBieSBjaGVja2luZyBpZiB0aGUgbW9kZVxyXG4gICAgLy8gYWN0dWFsbHkgY2hhbmdlcy5cclxuICAgIGlmIChtb2RlICE9PSBicnVzaC5tb2RlKSB7XHJcbiAgICAgIC8vIFdoZW4gY2hhbmdpbmcgYnJ1c2ggbW9kZXMsIHRoZSBmaXJzdCB0aGluZyB3ZSBuZWVkIHRvIGRvIGlzIGNsZWFyaW5nIGFueVxyXG4gICAgICAvLyBicnVzaGVzIGZyb20gdGhlIGN1cnJlbnQgbW9kZSwgaWYgYW55LlxyXG4gICAgICBpZiAoYnJ1c2gubW9kZSAhPT0gJ05vbmUnKSB7XHJcbiAgICAgICAgcGMuYnJ1c2hSZXNldCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBOZXh0LCB3ZSBuZWVkIHRvICd1bmluc3RhbGwnIHRoZSBjdXJyZW50IGJydXNoTW9kZS5cclxuICAgICAgYnJ1c2gubW9kZXNbYnJ1c2gubW9kZV0udW5pbnN0YWxsKHBjKTtcclxuICAgICAgLy8gRmluYWxseSwgd2UgY2FuIGluc3RhbGwgdGhlIHJlcXVlc3RlZCBvbmUuXHJcbiAgICAgIGJydXNoLm1vZGUgPSBtb2RlO1xyXG4gICAgICBicnVzaC5tb2Rlc1ticnVzaC5tb2RlXS5pbnN0YWxsKCk7XHJcbiAgICAgIGlmIChtb2RlID09PSAnTm9uZScpIHtcclxuICAgICAgICBkZWxldGUgcGMuYnJ1c2hQcmVkaWNhdGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcGMuYnJ1c2hQcmVkaWNhdGUgPSBicnVzaFByZWRpY2F0ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYztcclxuICB9O1xyXG5cclxuICAvLyBicnVzaCBtb2RlOiAxRC1BeGVzXHJcblxyXG4gIChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgYnJ1c2hlcyA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzX2JydXNoZWQocCkge1xyXG4gICAgICByZXR1cm4gIWJydXNoZXNbcF0uZW1wdHkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkYXRhIHdpdGhpbiBleHRlbnRzXHJcbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcclxuICAgICAgdmFyIGFjdGl2ZXMgPSBfXy5kaW1lbnNpb25zLmZpbHRlcihpc19icnVzaGVkKSxcclxuICAgICAgICBleHRlbnRzID0gYWN0aXZlcy5tYXAoZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgIHJldHVybiBicnVzaGVzW3BdLmV4dGVudCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gdGhlIGZ1bGwgZGF0YSBzZXQgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLlxyXG4gICAgICAvLyBBY3R1YWxseSwgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLCBieSBkZWZpbml0aW9uLCBubyBpdGVtcyBhcmVcclxuICAgICAgLy8gc2VsZWN0ZWQuIFNvLCBsZXQncyBhdm9pZCB0aGUgZmlsdGVyaW5nIGFuZCBqdXN0IHJldHVybiBmYWxzZS5cclxuICAgICAgLy9pZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIC8vIFJlc29sdmVzIGJyb2tlbiBleGFtcGxlcyBmb3Igbm93LiBUaGV5IGV4cGVjdCB0byBnZXQgdGhlIGZ1bGwgZGF0YXNldCBiYWNrIGZyb20gZW1wdHkgYnJ1c2hlc1xyXG4gICAgICBpZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBfXy5kYXRhO1xyXG5cclxuICAgICAgLy8gdGVzdCBpZiB3aXRoaW4gcmFuZ2VcclxuICAgICAgdmFyIHdpdGhpbiA9IHtcclxuICAgICAgICBkYXRlOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJlxyXG4gICAgICAgICAgICAgIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgZXh0ZW50c1tkaW1lbnNpb25dWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG51bWJlcjogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbikge1xyXG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgb3JkaW5hbFxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiZcclxuICAgICAgICAgICAgICB5c2NhbGVbcF0oZFtwXSkgPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSBkW3BdICYmIGRbcF0gPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24pIHtcclxuICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiZcclxuICAgICAgICAgICAgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIF9fLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcclxuICAgICAgICAgIGNhc2UgJ0FORCc6XHJcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLmV2ZXJ5KGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcclxuICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNhc2UgJ09SJzpcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuc29tZShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpbltfXy50eXBlc1twXV0oZCwgcCwgZGltZW5zaW9uKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnJ1c2hFeHRlbnRzKGV4dGVudHMpIHtcclxuICAgICAgaWYgKHR5cGVvZiBleHRlbnRzID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHZhciBleHRlbnRzID0ge307XHJcbiAgICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICB2YXIgYnJ1c2ggPSBicnVzaGVzW2RdO1xyXG4gICAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQgJiYgIWJydXNoLmVtcHR5KCkpIHtcclxuICAgICAgICAgICAgdmFyIGV4dGVudCA9IGJydXNoLmV4dGVudCgpO1xyXG4gICAgICAgICAgICBleHRlbnQuc29ydChkMy5hc2NlbmRpbmcpO1xyXG4gICAgICAgICAgICBleHRlbnRzW2RdID0gZXh0ZW50O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBleHRlbnRzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vZmlyc3QgZ2V0IGFsbCB0aGUgYnJ1c2ggc2VsZWN0aW9uc1xyXG4gICAgICAgIHZhciBicnVzaFNlbGVjdGlvbnMgPSB7fTtcclxuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgYnJ1c2hTZWxlY3Rpb25zW2RdID0gZDMuc2VsZWN0KHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBsb29wIG92ZXIgZWFjaCBkaW1lbnNpb24gYW5kIHVwZGF0ZSBhcHByb3ByaWF0ZWx5IChpZiBpdCB3YXMgcGFzc2VkIGluIHRocm91Z2ggZXh0ZW50cylcclxuICAgICAgICBfXy5kaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIGlmIChleHRlbnRzW2RdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XHJcbiAgICAgICAgICBpZiAoYnJ1c2ggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvL3VwZGF0ZSB0aGUgZXh0ZW50XHJcbiAgICAgICAgICAgIGJydXNoLmV4dGVudChleHRlbnRzW2RdKTtcclxuXHJcbiAgICAgICAgICAgIC8vcmVkcmF3IHRoZSBicnVzaFxyXG4gICAgICAgICAgICBicnVzaChicnVzaFNlbGVjdGlvbnNbZF0pO1xyXG5cclxuICAgICAgICAgICAgLy9maXJlIHNvbWUgZXZlbnRzXHJcbiAgICAgICAgICAgIGJydXNoLmV2ZW50KGJydXNoU2VsZWN0aW9uc1tkXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vcmVkcmF3IHRoZSBjaGFydFxyXG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYnJ1c2hGb3IoYXhpcykge1xyXG4gICAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKTtcclxuXHJcbiAgICAgIGJydXNoXHJcbiAgICAgICAgLnkoeXNjYWxlW2F4aXNdKVxyXG4gICAgICAgIC5vbignYnJ1c2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGlmIChkMy5ldmVudC5zb3VyY2VFdmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkMy5ldmVudC5zb3VyY2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignYnJ1c2gnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBicnVzaFVwZGF0ZWQoc2VsZWN0ZWQoKSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oJ2JydXNoZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgYnJ1c2hlc1theGlzXSA9IGJydXNoO1xyXG4gICAgICByZXR1cm4gYnJ1c2g7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGRpbWVuc2lvbikge1xyXG4gICAgICBfXy5icnVzaGVkID0gZmFsc2U7XHJcbiAgICAgIGlmIChnKSB7XHJcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoZXNbZF0uY2xlYXIoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XHJcbiAgICAgIGlmICghZykgcGMuY3JlYXRlQXhlcygpO1xyXG5cclxuICAgICAgLy8gQWRkIGFuZCBzdG9yZSBhIGJydXNoIGZvciBlYWNoIGF4aXMuXHJcbiAgICAgIGcuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoJylcclxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hGb3IoZCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnNlbGVjdEFsbCgncmVjdCcpXHJcbiAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbClcclxuICAgICAgICAuYXR0cigneCcsIC0xNSlcclxuICAgICAgICAuYXR0cignd2lkdGgnLCAzMCk7XHJcblxyXG4gICAgICBwYy5icnVzaEV4dGVudHMgPSBicnVzaEV4dGVudHM7XHJcbiAgICAgIHBjLmJydXNoUmVzZXQgPSBicnVzaFJlc2V0O1xyXG4gICAgICByZXR1cm4gcGM7XHJcbiAgICB9XHJcblxyXG4gICAgYnJ1c2gubW9kZXNbJzFELWF4ZXMnXSA9IHtcclxuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcclxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLnJlbW92ZSgpO1xyXG4gICAgICAgIGJydXNoZXMgPSB7fTtcclxuICAgICAgICBkZWxldGUgcGMuYnJ1c2hFeHRlbnRzO1xyXG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFJlc2V0O1xyXG4gICAgICB9LFxyXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXHJcbiAgICAgIGJydXNoU3RhdGU6IGJydXNoRXh0ZW50cyxcclxuICAgIH07XHJcbiAgfSkoKTtcclxuICAvLyBicnVzaCBtb2RlOiAyRC1zdHJ1bXNcclxuICAvLyBibC5vY2tzLm9yZy9zeW50YWdtYXRpYy81NDQxMDIyXHJcblxyXG4gIChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgc3RydW1zID0ge30sXHJcbiAgICAgIHN0cnVtUmVjdDtcclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RydW0oc3RydW0sIGFjdGl2ZVBvaW50KSB7XHJcbiAgICAgIHZhciBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjc3RydW1zJyksXHJcbiAgICAgICAgaWQgPSBzdHJ1bS5kaW1zLmksXHJcbiAgICAgICAgcG9pbnRzID0gW3N0cnVtLnAxLCBzdHJ1bS5wMl0sXHJcbiAgICAgICAgbGluZSA9IHN2Zy5zZWxlY3RBbGwoJ2xpbmUjc3RydW0tJyArIGlkKS5kYXRhKFtzdHJ1bV0pLFxyXG4gICAgICAgIGNpcmNsZXMgPSBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjc3RydW0tJyArIGlkKS5kYXRhKHBvaW50cyksXHJcbiAgICAgICAgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKTtcclxuXHJcbiAgICAgIGxpbmVcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2xpbmUnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdHJ1bS0nICsgaWQpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3N0cnVtJyk7XHJcblxyXG4gICAgICBsaW5lXHJcbiAgICAgICAgLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkLnAxWzBdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkLnAxWzFdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3gyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkLnAyWzBdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBkLnAyWzFdO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZScsICdibGFjaycpXHJcbiAgICAgICAgLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xyXG5cclxuICAgICAgZHJhZ1xyXG4gICAgICAgIC5vbignZHJhZycsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgICB2YXIgZXYgPSBkMy5ldmVudDtcclxuICAgICAgICAgIGkgPSBpICsgMTtcclxuICAgICAgICAgIHN0cnVtWydwJyArIGldWzBdID0gTWF0aC5taW4oXHJcbiAgICAgICAgICAgIE1hdGgubWF4KHN0cnVtLm1pblggKyAxLCBldi54KSxcclxuICAgICAgICAgICAgc3RydW0ubWF4WCxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBzdHJ1bVsncCcgKyBpXVsxXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblksIGV2LnkpLCBzdHJ1bS5tYXhZKTtcclxuICAgICAgICAgIGRyYXdTdHJ1bShzdHJ1bSwgaSAtIDEpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKCkpO1xyXG5cclxuICAgICAgY2lyY2xlc1xyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAuYXR0cignaWQnLCAnc3RydW0tJyArIGlkKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdzdHJ1bScpO1xyXG5cclxuICAgICAgY2lyY2xlc1xyXG4gICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZFswXTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZFsxXTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZVBvaW50ICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gYWN0aXZlUG9pbnQgPyAwLjggOiAwO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwLjgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDApO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhbGwoZHJhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGltZW5zaW9uc0ZvclBvaW50KHApIHtcclxuICAgICAgdmFyIGRpbXMgPSB7IGk6IC0xLCBsZWZ0OiB1bmRlZmluZWQsIHJpZ2h0OiB1bmRlZmluZWQgfTtcclxuICAgICAgX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkaW0sIGkpIHtcclxuICAgICAgICBpZiAoeHNjYWxlKGRpbSkgPCBwWzBdKSB7XHJcbiAgICAgICAgICB2YXIgbmV4dCA9IF9fLmRpbWVuc2lvbnNbaSArIDFdO1xyXG4gICAgICAgICAgZGltcy5pID0gaTtcclxuICAgICAgICAgIGRpbXMubGVmdCA9IGRpbTtcclxuICAgICAgICAgIGRpbXMucmlnaHQgPSBuZXh0O1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoZGltcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBFdmVudCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBmaXJzdCBheGlzLlxyXG4gICAgICAgIGRpbXMuaSA9IDA7XHJcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1swXTtcclxuICAgICAgICBkaW1zLnJpZ2h0ID0gX18uZGltZW5zaW9uc1sxXTtcclxuICAgICAgfSBlbHNlIGlmIChkaW1zLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBFdmVudCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbGFzdCBheGlzXHJcbiAgICAgICAgZGltcy5pID0gX18uZGltZW5zaW9ucy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGRpbXMucmlnaHQgPSBkaW1zLmxlZnQ7XHJcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1tfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDJdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGltcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcclxuICAgICAgLy8gRmlyc3Qgd2UgbmVlZCB0byBkZXRlcm1pbmUgYmV0d2VlbiB3aGljaCB0d28gYXhlcyB0aGUgc3R1cm0gd2FzIHN0YXJ0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd2lsbCBkZXRlcm1pbmUgdGhlIGZyZWVkb20gb2YgbW92ZW1lbnQsIGJlY2F1c2UgYSBzdHJ1bSBjYW5cclxuICAgICAgLy8gbG9naWNhbGx5IG9ubHkgaGFwcGVuIGJldHdlZW4gdHdvIGF4ZXMsIHNvIG5vIG1vdmVtZW50IG91dHNpZGUgdGhlc2UgYXhlc1xyXG4gICAgICAvLyBzaG91bGQgYmUgYWxsb3dlZC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcCA9IGQzLm1vdXNlKHN0cnVtUmVjdFswXVswXSksXHJcbiAgICAgICAgICBkaW1zLFxyXG4gICAgICAgICAgc3RydW07XHJcblxyXG4gICAgICAgIHBbMF0gPSBwWzBdIC0gX18ubWFyZ2luLmxlZnQ7XHJcbiAgICAgICAgcFsxXSA9IHBbMV0gLSBfXy5tYXJnaW4udG9wO1xyXG5cclxuICAgICAgICAoZGltcyA9IGRpbWVuc2lvbnNGb3JQb2ludChwKSksXHJcbiAgICAgICAgICAoc3RydW0gPSB7XHJcbiAgICAgICAgICAgIHAxOiBwLFxyXG4gICAgICAgICAgICBkaW1zOiBkaW1zLFxyXG4gICAgICAgICAgICBtaW5YOiB4c2NhbGUoZGltcy5sZWZ0KSxcclxuICAgICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxyXG4gICAgICAgICAgICBtaW5ZOiAwLFxyXG4gICAgICAgICAgICBtYXhZOiBoKCksXHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc3RydW1zW2RpbXMuaV0gPSBzdHJ1bTtcclxuICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZGltcy5pO1xyXG5cclxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHNcclxuICAgICAgICBzdHJ1bS5wMVswXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblgsIHBbMF0pLCBzdHJ1bS5tYXhYKTtcclxuICAgICAgICBzdHJ1bS5wMiA9IHN0cnVtLnAxLnNsaWNlKCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25EcmFnKCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxyXG4gICAgICAgICAgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICAgIHN0cnVtLnAyWzBdID0gTWF0aC5taW4oXHJcbiAgICAgICAgICBNYXRoLm1heChzdHJ1bS5taW5YICsgMSwgZXYueCAtIF9fLm1hcmdpbi5sZWZ0KSxcclxuICAgICAgICAgIHN0cnVtLm1heFgsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBzdHJ1bS5wMlsxXSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgTWF0aC5tYXgoc3RydW0ubWluWSwgZXYueSAtIF9fLm1hcmdpbi50b3ApLFxyXG4gICAgICAgICAgc3RydW0ubWF4WSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGRyYXdTdHJ1bShzdHJ1bSwgMSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29udGFpbm1lbnRUZXN0KHN0cnVtLCB3aWR0aCkge1xyXG4gICAgICB2YXIgcDEgPSBbc3RydW0ucDFbMF0gLSBzdHJ1bS5taW5YLCBzdHJ1bS5wMVsxXSAtIHN0cnVtLm1pblhdLFxyXG4gICAgICAgIHAyID0gW3N0cnVtLnAyWzBdIC0gc3RydW0ubWluWCwgc3RydW0ucDJbMV0gLSBzdHJ1bS5taW5YXSxcclxuICAgICAgICBtMSA9IDEgLSB3aWR0aCAvIHAxWzBdLFxyXG4gICAgICAgIGIxID0gcDFbMV0gKiAoMSAtIG0xKSxcclxuICAgICAgICBtMiA9IDEgLSB3aWR0aCAvIHAyWzBdLFxyXG4gICAgICAgIGIyID0gcDJbMV0gKiAoMSAtIG0yKTtcclxuXHJcbiAgICAgIC8vIHRlc3QgaWYgcG9pbnQgZmFsbHMgYmV0d2VlbiBsaW5lc1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICB2YXIgeCA9IHBbMF0sXHJcbiAgICAgICAgICB5ID0gcFsxXSxcclxuICAgICAgICAgIHkxID0gbTEgKiB4ICsgYjEsXHJcbiAgICAgICAgICB5MiA9IG0yICogeCArIGIyO1xyXG5cclxuICAgICAgICBpZiAoeSA+IE1hdGgubWluKHkxLCB5MikgJiYgeSA8IE1hdGgubWF4KHkxLCB5MikpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xyXG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RydW1zKSxcclxuICAgICAgICBicnVzaGVkID0gX18uZGF0YTtcclxuXHJcbiAgICAgIC8vIEdldCB0aGUgaWRzIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHN0cnVtcy5cclxuICAgICAgaWRzID0gaWRzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiAhaXNOYU4oZCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY3Jvc3Nlc1N0cnVtKGQsIGlkKSB7XHJcbiAgICAgICAgdmFyIHN0cnVtID0gc3RydW1zW2lkXSxcclxuICAgICAgICAgIHRlc3QgPSBjb250YWlubWVudFRlc3Qoc3RydW0sIHN0cnVtcy53aWR0aChpZCkpLFxyXG4gICAgICAgICAgZDEgPSBzdHJ1bS5kaW1zLmxlZnQsXHJcbiAgICAgICAgICBkMiA9IHN0cnVtLmRpbXMucmlnaHQsXHJcbiAgICAgICAgICB5MSA9IHlzY2FsZVtkMV0sXHJcbiAgICAgICAgICB5MiA9IHlzY2FsZVtkMl0sXHJcbiAgICAgICAgICBwb2ludCA9IFt5MShkW2QxXSkgLSBzdHJ1bS5taW5YLCB5MihkW2QyXSkgLSBzdHJ1bS5taW5YXTtcclxuICAgICAgICByZXR1cm4gdGVzdChwb2ludCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGJydXNoZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBicnVzaGVkLmZpbHRlcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XHJcbiAgICAgICAgICBjYXNlICdBTkQnOlxyXG4gICAgICAgICAgICByZXR1cm4gaWRzLmV2ZXJ5KGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNhc2UgJ09SJzpcclxuICAgICAgICAgICAgcmV0dXJuIGlkcy5zb21lKGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZW1vdmVTdHJ1bSgpIHtcclxuICAgICAgdmFyIHN0cnVtID0gc3RydW1zW3N0cnVtcy5hY3RpdmVdLFxyXG4gICAgICAgIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKTtcclxuXHJcbiAgICAgIGRlbGV0ZSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07XHJcbiAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2xpbmUjc3RydW0tJyArIHN0cnVtLmRpbXMuaSkucmVtb3ZlKCk7XHJcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNzdHJ1bS0nICsgc3RydW0uZGltcy5pKS5yZW1vdmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkRyYWdFbmQoKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJydXNoZWQgPSBfXy5kYXRhLFxyXG4gICAgICAgICAgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07XHJcblxyXG4gICAgICAgIC8vIE9rYXksIHNvbWV3aGF0IHVuZXhwZWN0ZWQsIGJ1dCBub3QgdG90YWxseSB1bnN1cnByaXNpbmcsIGEgbW91c2NsaWNrIGlzXHJcbiAgICAgICAgLy8gY29uc2lkZXJlZCBhIGRyYWcgd2l0aG91dCBtb3ZlLiBTbyB3ZSBoYXZlIHRvIGRlYWwgd2l0aCB0aGF0IGNhc2VcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBzdHJ1bSAmJlxyXG4gICAgICAgICAgc3RydW0ucDFbMF0gPT09IHN0cnVtLnAyWzBdICYmXHJcbiAgICAgICAgICBzdHJ1bS5wMVsxXSA9PT0gc3RydW0ucDJbMV1cclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBicnVzaGVkID0gc2VsZWN0ZWQoc3RydW1zKTtcclxuICAgICAgICBzdHJ1bXMuYWN0aXZlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF9fLmJydXNoZWQgPSBicnVzaGVkO1xyXG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcclxuICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChzdHJ1bXMpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RydW1zKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZDtcclxuICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgb25EcmFnRW5kKHN0cnVtcykoKTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xyXG4gICAgICB2YXIgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKTtcclxuXHJcbiAgICAgIC8vIE1hcCBvZiBjdXJyZW50IHN0cnVtcy4gU3RydW1zIGFyZSBzdG9yZWQgcGVyIHNlZ21lbnQgb2YgdGhlIFBDLiBBIHNlZ21lbnQsXHJcbiAgICAgIC8vIGJlaW5nIHRoZSBhcmVhIGJldHdlZW4gdHdvIGF4ZXMuIFRoZSBsZWZ0IG1vc3QgYXJlYSBpcyBpbmRleGVkIGF0IDAuXHJcbiAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIC8vIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBQQyBzZWdtZW50IHdoZXJlIGN1cnJlbnRseSBhIHN0cnVtIGlzIGJlaW5nXHJcbiAgICAgIC8vIHBsYWNlZC4gTk9URTogZXZlbiB0aG91Z2ggdGhleSBhcmUgZXZlbmx5IHNwYWNlZCBpbiBvdXIgY3VycmVudFxyXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgd2Uga2VlcCBmb3Igd2hlbiBub24tZXZlbiBzcGFjZWQgc2VnbWVudHMgYXJlIHN1cHBvcnRlZCBhc1xyXG4gICAgICAvLyB3ZWxsLlxyXG4gICAgICBzdHJ1bXMud2lkdGggPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbaWRdO1xyXG5cclxuICAgICAgICBpZiAoc3RydW0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzdHJ1bS5tYXhYIC0gc3RydW0ubWluWDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5zdHJ1bXMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGZpcnN0IGRpbWVuc2lvbiBpcyBkaXJlY3RseSBsZWZ0IG9mIHRoZSBzZWNvbmQgZGltZW5zaW9uLlxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnNlY3V0aXZlKGZpcnN0LCBzZWNvbmQpIHtcclxuICAgICAgICAgIHZhciBsZW5ndGggPSBfXy5kaW1lbnNpb25zLmxlbmd0aDtcclxuICAgICAgICAgIHJldHVybiBfXy5kaW1lbnNpb25zLnNvbWUoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGQgPT09IGZpcnN0XHJcbiAgICAgICAgICAgICAgPyBpICsgaSA8IGxlbmd0aCAmJiBfXy5kaW1lbnNpb25zW2kgKyAxXSA9PT0gc2Vjb25kXHJcbiAgICAgICAgICAgICAgOiBmYWxzZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlkcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyBXZSBoYXZlIHNvbWUgc3RydW1zLCB3aGljaCBtaWdodCBuZWVkIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgZGltcyA9IHN0cnVtc1tkXS5kaW1zO1xyXG4gICAgICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZDtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHR3byBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IHN0cnVtIGFyZSBub3QgbmV4dCB0byBlYWNoIG90aGVyXHJcbiAgICAgICAgICAgIC8vIGFueSBtb3JlLCB0aGFuIHdlJ2xsIG5lZWQgdG8gcmVtb3ZlIHRoZSBzdHJ1bS4gT3RoZXJ3aXNlIHdlIGtlZXAgaXQuXHJcbiAgICAgICAgICAgIGlmICghY29uc2VjdXRpdmUoZGltcy5sZWZ0LCBkaW1zLnJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgb25EcmFnRW5kKHN0cnVtcykoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gQWRkIGEgbmV3IHN2ZyBncm91cCBpbiB3aGljaCB3ZSBkcmF3IHRoZSBzdHJ1bXMuXHJcbiAgICAgIHBjLnNlbGVjdGlvblxyXG4gICAgICAgIC5zZWxlY3QoJ3N2ZycpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ3N0cnVtcycpXHJcbiAgICAgICAgLmF0dHIoXHJcbiAgICAgICAgICAndHJhbnNmb3JtJyxcclxuICAgICAgICAgICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgLy8gSW5zdGFsbCB0aGUgcmVxdWlyZWQgYnJ1c2hSZXNldCBmdW5jdGlvblxyXG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldChzdHJ1bXMpO1xyXG5cclxuICAgICAgZHJhZ1xyXG4gICAgICAgIC5vbignZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQoc3RydW1zKSlcclxuICAgICAgICAub24oJ2RyYWcnLCBvbkRyYWcoc3RydW1zKSlcclxuICAgICAgICAub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoc3RydW1zKSk7XHJcblxyXG4gICAgICAvLyBOT1RFOiBUaGUgc3R5bGluZyBuZWVkcyB0byBiZSBkb25lIGhlcmUgYW5kIG5vdCBpbiB0aGUgY3NzLiBUaGlzIGlzIGJlY2F1c2VcclxuICAgICAgLy8gICAgICAgZm9yIDFEIGJydXNoaW5nLCB0aGUgY2FudmFzIGxheWVycyBzaG91bGQgbm90IGxpc3RlbiB0b1xyXG4gICAgICAvLyAgICAgICBwb2ludGVyLWV2ZW50cy5cclxuICAgICAgc3RydW1SZWN0ID0gcGMuc2VsZWN0aW9uXHJcbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcclxuICAgICAgICAuaW5zZXJ0KCdyZWN0JywgJ2cjc3RydW1zJylcclxuICAgICAgICAuYXR0cignaWQnLCAnc3RydW0tZXZlbnRzJylcclxuICAgICAgICAuYXR0cigneCcsIF9fLm1hcmdpbi5sZWZ0KVxyXG4gICAgICAgIC5hdHRyKCd5JywgX18ubWFyZ2luLnRvcClcclxuICAgICAgICAuYXR0cignd2lkdGgnLCB3KCkpXHJcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGgoKSArIDIpXHJcbiAgICAgICAgLnN0eWxlKCdvcGFjaXR5JywgMClcclxuICAgICAgICAuY2FsbChkcmFnKTtcclxuICAgIH1cclxuXHJcbiAgICBicnVzaC5tb2Rlc1snMkQtc3RydW1zJ10gPSB7XHJcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXHJcbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKS5yZW1vdmUoKTtcclxuICAgICAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ3JlY3Qjc3RydW0tZXZlbnRzJykucmVtb3ZlKCk7XHJcbiAgICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLnN0cnVtcycsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XHJcblxyXG4gICAgICAgIHN0cnVtUmVjdCA9IHVuZGVmaW5lZDtcclxuICAgICAgfSxcclxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxyXG4gICAgICBicnVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cnVtcztcclxuICAgICAgfSxcclxuICAgIH07XHJcbiAgfSkoKTtcclxuXHJcbiAgLy8gYnJ1c2ggbW9kZTogMUQtQXhlcyB3aXRoIG11bHRpcGxlIGV4dGVudHNcclxuICAvLyByZXF1aXJlcyBkMy5zdmcubXVsdGlicnVzaFxyXG5cclxuICAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBkMy5zdmcubXVsdGlicnVzaCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgYnJ1c2hlcyA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGlzX2JydXNoZWQocCkge1xyXG4gICAgICByZXR1cm4gIWJydXNoZXNbcF0uZW1wdHkoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkYXRhIHdpdGhpbiBleHRlbnRzXHJcbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcclxuICAgICAgdmFyIGFjdGl2ZXMgPSBfXy5kaW1lbnNpb25zLmZpbHRlcihpc19icnVzaGVkKSxcclxuICAgICAgICBleHRlbnRzID0gYWN0aXZlcy5tYXAoZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgIHJldHVybiBicnVzaGVzW3BdLmV4dGVudCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gdGhlIGZ1bGwgZGF0YSBzZXQgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLlxyXG4gICAgICAvLyBBY3R1YWxseSwgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLCBieSBkZWZpbml0aW9uLCBubyBpdGVtcyBhcmVcclxuICAgICAgLy8gc2VsZWN0ZWQuIFNvLCBsZXQncyBhdm9pZCB0aGUgZmlsdGVyaW5nIGFuZCBqdXN0IHJldHVybiBmYWxzZS5cclxuICAgICAgLy9pZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICAgIC8vIFJlc29sdmVzIGJyb2tlbiBleGFtcGxlcyBmb3Igbm93LiBUaGV5IGV4cGVjdCB0byBnZXQgdGhlIGZ1bGwgZGF0YXNldCBiYWNrIGZyb20gZW1wdHkgYnJ1c2hlc1xyXG4gICAgICBpZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBfXy5kYXRhO1xyXG5cclxuICAgICAgLy8gdGVzdCBpZiB3aXRoaW4gcmFuZ2VcclxuICAgICAgdmFyIHdpdGhpbiA9IHtcclxuICAgICAgICBkYXRlOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uLCBiKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXHJcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gYlsxXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBiWzFdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uLCBiKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXHJcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IHlzY2FsZVtwXShkW3BdKSAmJiB5c2NhbGVbcF0oZFtwXSkgPD0gYlsxXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBiWzFdO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uLCBiKSB7XHJcbiAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XHJcbiAgICAgICAgfSxcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHJldHVybiBfXy5kYXRhLmZpbHRlcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XHJcbiAgICAgICAgICBjYXNlICdBTkQnOlxyXG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5ldmVyeShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXS5zb21lKGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24sIGIpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIGNhc2UgJ09SJzpcclxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuc29tZShmdW5jdGlvbiAocCwgZGltZW5zaW9uKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXS5zb21lKGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24sIGIpO1xyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBicnVzaEV4dGVudHMoKSB7XHJcbiAgICAgIHZhciBleHRlbnRzID0ge307XHJcbiAgICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHZhciBicnVzaCA9IGJydXNoZXNbZF07XHJcbiAgICAgICAgaWYgKGJydXNoICE9PSB1bmRlZmluZWQgJiYgIWJydXNoLmVtcHR5KCkpIHtcclxuICAgICAgICAgIHZhciBleHRlbnQgPSBicnVzaC5leHRlbnQoKTtcclxuICAgICAgICAgIGV4dGVudHNbZF0gPSBleHRlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIGV4dGVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnJ1c2hGb3IoYXhpcykge1xyXG4gICAgICB2YXIgYnJ1c2ggPSBkMy5zdmcubXVsdGlicnVzaCgpO1xyXG5cclxuICAgICAgYnJ1c2hcclxuICAgICAgICAueSh5c2NhbGVbYXhpc10pXHJcbiAgICAgICAgLm9uKCdicnVzaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdicnVzaCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignYnJ1c2hlbmQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAvLyBkMy5zdmcubXVsdGlicnVzaCBjbGVhcnMgZXh0ZW50cyBqdXN0IGJlZm9yZSBjYWxsaW5nICdicnVzaGVuZCdcclxuICAgICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gdXBkYXRlIGhlcmUgYWdhaW4uXHJcbiAgICAgICAgICAvLyBUaGlzIGZpeGVzIGlzc3VlICMxMDMgZm9yIG5vdywgYnV0IHNob3VsZCBiZSBjaGFuZ2VkIGluIGQzLnN2Zy5tdWx0aWJydXNoXHJcbiAgICAgICAgICAvLyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb21wdXRhdGlvbi5cclxuICAgICAgICAgIGJydXNoVXBkYXRlZChzZWxlY3RlZCgpKTtcclxuICAgICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5leHRlbnRBZGFwdGlvbihmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICBzZWxlY3Rpb24uc3R5bGUoJ3Zpc2liaWxpdHknLCBudWxsKS5hdHRyKCd4JywgLTE1KS5hdHRyKCd3aWR0aCcsIDMwKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5yZXNpemVBZGFwdGlvbihmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCdyZWN0JykuYXR0cigneCcsIC0xNSkuYXR0cignd2lkdGgnLCAzMCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICBicnVzaGVzW2F4aXNdID0gYnJ1c2g7XHJcbiAgICAgIHJldHVybiBicnVzaDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGRpbWVuc2lvbikge1xyXG4gICAgICBfXy5icnVzaGVkID0gZmFsc2U7XHJcbiAgICAgIGlmIChnKSB7XHJcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoZXNbZF0uY2xlYXIoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XHJcbiAgICAgIGlmICghZykgcGMuY3JlYXRlQXhlcygpO1xyXG5cclxuICAgICAgLy8gQWRkIGFuZCBzdG9yZSBhIGJydXNoIGZvciBlYWNoIGF4aXMuXHJcbiAgICAgIGcuYXBwZW5kKCdzdmc6ZycpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2JydXNoJylcclxuICAgICAgICAuZWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hGb3IoZCkpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLnNlbGVjdEFsbCgncmVjdCcpXHJcbiAgICAgICAgLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbClcclxuICAgICAgICAuYXR0cigneCcsIC0xNSlcclxuICAgICAgICAuYXR0cignd2lkdGgnLCAzMCk7XHJcblxyXG4gICAgICBwYy5icnVzaEV4dGVudHMgPSBicnVzaEV4dGVudHM7XHJcbiAgICAgIHBjLmJydXNoUmVzZXQgPSBicnVzaFJlc2V0O1xyXG4gICAgICByZXR1cm4gcGM7XHJcbiAgICB9XHJcblxyXG4gICAgYnJ1c2gubW9kZXNbJzFELWF4ZXMtbXVsdGknXSA9IHtcclxuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcclxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLnJlbW92ZSgpO1xyXG4gICAgICAgIGJydXNoZXMgPSB7fTtcclxuICAgICAgICBkZWxldGUgcGMuYnJ1c2hFeHRlbnRzO1xyXG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFJlc2V0O1xyXG4gICAgICB9LFxyXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXHJcbiAgICAgIGJydXNoU3RhdGU6IGJydXNoRXh0ZW50cyxcclxuICAgIH07XHJcbiAgfSkoKTtcclxuICAvLyBicnVzaCBtb2RlOiBhbmd1bGFyXHJcbiAgLy8gY29kZSBiYXNlZCBvbiAyRC5zdHJ1bXMuanNcclxuXHJcbiAgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBhcmNzID0ge30sXHJcbiAgICAgIHN0cnVtUmVjdDtcclxuXHJcbiAgICBmdW5jdGlvbiBkcmF3U3RydW0oYXJjLCBhY3RpdmVQb2ludCkge1xyXG4gICAgICB2YXIgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKSxcclxuICAgICAgICBpZCA9IGFyYy5kaW1zLmksXHJcbiAgICAgICAgcG9pbnRzID0gW2FyYy5wMiwgYXJjLnAzXSxcclxuICAgICAgICBsaW5lID0gc3ZnLnNlbGVjdEFsbCgnbGluZSNhcmMtJyArIGlkKS5kYXRhKFtcclxuICAgICAgICAgIHsgcDE6IGFyYy5wMSwgcDI6IGFyYy5wMiB9LFxyXG4gICAgICAgICAgeyBwMTogYXJjLnAxLCBwMjogYXJjLnAzIH0sXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgY2lyY2xlcyA9IHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNhcmMtJyArIGlkKS5kYXRhKHBvaW50cyksXHJcbiAgICAgICAgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKSxcclxuICAgICAgICBwYXRoID0gc3ZnLnNlbGVjdEFsbCgncGF0aCNhcmMtJyArIGlkKS5kYXRhKFthcmNdKTtcclxuXHJcbiAgICAgIHBhdGhcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdhcmMtJyArIGlkKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdhcmMnKVxyXG4gICAgICAgIC5zdHlsZSgnZmlsbCcsICdvcmFuZ2UnKVxyXG4gICAgICAgIC5zdHlsZSgnb3BhY2l0eScsIDAuNSk7XHJcblxyXG4gICAgICBwYXRoXHJcbiAgICAgICAgLmF0dHIoJ2QnLCBhcmMuYXJjKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBhcmMucDFbMF0gKyAnLCcgKyBhcmMucDFbMV0gKyAnKScpO1xyXG5cclxuICAgICAgbGluZVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnbGluZScpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyYy0nICsgaWQpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2FyYycpO1xyXG5cclxuICAgICAgbGluZVxyXG4gICAgICAgIC5hdHRyKCd4MScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZC5wMVswXTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCd5MScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZC5wMVsxXTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZC5wMlswXTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCd5MicsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZC5wMlsxXTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2UnLCAnYmxhY2snKVxyXG4gICAgICAgIC5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcclxuXHJcbiAgICAgIGRyYWdcclxuICAgICAgICAub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgdmFyIGV2ID0gZDMuZXZlbnQsXHJcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcclxuXHJcbiAgICAgICAgICBpID0gaSArIDI7XHJcblxyXG4gICAgICAgICAgYXJjWydwJyArIGldWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblggKyAxLCBldi54KSwgYXJjLm1heFgpO1xyXG4gICAgICAgICAgYXJjWydwJyArIGldWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblksIGV2LnkpLCBhcmMubWF4WSk7XHJcblxyXG4gICAgICAgICAgYW5nbGUgPSBpID09PSAzID8gYXJjcy5zdGFydEFuZ2xlKGlkKSA6IGFyY3MuZW5kQW5nbGUoaWQpO1xyXG5cclxuICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgKGFyYy5zdGFydEFuZ2xlIDwgTWF0aC5QSSAmJlxyXG4gICAgICAgICAgICAgIGFyYy5lbmRBbmdsZSA8IE1hdGguUEkgJiZcclxuICAgICAgICAgICAgICBhbmdsZSA8IE1hdGguUEkpIHx8XHJcbiAgICAgICAgICAgIChhcmMuc3RhcnRBbmdsZSA+PSBNYXRoLlBJICYmXHJcbiAgICAgICAgICAgICAgYXJjLmVuZEFuZ2xlID49IE1hdGguUEkgJiZcclxuICAgICAgICAgICAgICBhbmdsZSA+PSBNYXRoLlBJKVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgYXJjLmVuZEFuZ2xlID0gYW5nbGU7XHJcbiAgICAgICAgICAgICAgYXJjLmFyYy5lbmRBbmdsZShhbmdsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xyXG4gICAgICAgICAgICAgIGFyYy5zdGFydEFuZ2xlID0gYW5nbGU7XHJcbiAgICAgICAgICAgICAgYXJjLmFyYy5zdGFydEFuZ2xlKGFuZ2xlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGRyYXdTdHJ1bShhcmMsIGkgLSAyKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZCgpKTtcclxuXHJcbiAgICAgIGNpcmNsZXNcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyYy0nICsgaWQpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2FyYycpO1xyXG5cclxuICAgICAgY2lyY2xlc1xyXG4gICAgICAgIC5hdHRyKCdjeCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZFswXTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdjeScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gZFsxXTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCdyJywgNSlcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgcmV0dXJuIGFjdGl2ZVBvaW50ICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gYWN0aXZlUG9pbnQgPyAwLjggOiAwO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ29wYWNpdHknLCAwLjgpO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnb3BhY2l0eScsIDApO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmNhbGwoZHJhZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGltZW5zaW9uc0ZvclBvaW50KHApIHtcclxuICAgICAgdmFyIGRpbXMgPSB7IGk6IC0xLCBsZWZ0OiB1bmRlZmluZWQsIHJpZ2h0OiB1bmRlZmluZWQgfTtcclxuICAgICAgX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkaW0sIGkpIHtcclxuICAgICAgICBpZiAoeHNjYWxlKGRpbSkgPCBwWzBdKSB7XHJcbiAgICAgICAgICB2YXIgbmV4dCA9IF9fLmRpbWVuc2lvbnNbaSArIDFdO1xyXG4gICAgICAgICAgZGltcy5pID0gaTtcclxuICAgICAgICAgIGRpbXMubGVmdCA9IGRpbTtcclxuICAgICAgICAgIGRpbXMucmlnaHQgPSBuZXh0O1xyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpZiAoZGltcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBFdmVudCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBmaXJzdCBheGlzLlxyXG4gICAgICAgIGRpbXMuaSA9IDA7XHJcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1swXTtcclxuICAgICAgICBkaW1zLnJpZ2h0ID0gX18uZGltZW5zaW9uc1sxXTtcclxuICAgICAgfSBlbHNlIGlmIChkaW1zLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBFdmVudCBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbGFzdCBheGlzXHJcbiAgICAgICAgZGltcy5pID0gX18uZGltZW5zaW9ucy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGRpbXMucmlnaHQgPSBkaW1zLmxlZnQ7XHJcbiAgICAgICAgZGltcy5sZWZ0ID0gX18uZGltZW5zaW9uc1tfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDJdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGltcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHtcclxuICAgICAgLy8gRmlyc3Qgd2UgbmVlZCB0byBkZXRlcm1pbmUgYmV0d2VlbiB3aGljaCB0d28gYXhlcyB0aGUgYXJjIHdhcyBzdGFydGVkLlxyXG4gICAgICAvLyBUaGlzIHdpbGwgZGV0ZXJtaW5lIHRoZSBmcmVlZG9tIG9mIG1vdmVtZW50LCBiZWNhdXNlIGEgYXJjIGNhblxyXG4gICAgICAvLyBsb2dpY2FsbHkgb25seSBoYXBwZW4gYmV0d2VlbiB0d28gYXhlcywgc28gbm8gbW92ZW1lbnQgb3V0c2lkZSB0aGVzZSBheGVzXHJcbiAgICAgIC8vIHNob3VsZCBiZSBhbGxvd2VkLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwID0gZDMubW91c2Uoc3RydW1SZWN0WzBdWzBdKSxcclxuICAgICAgICAgIGRpbXMsXHJcbiAgICAgICAgICBhcmM7XHJcblxyXG4gICAgICAgIHBbMF0gPSBwWzBdIC0gX18ubWFyZ2luLmxlZnQ7XHJcbiAgICAgICAgcFsxXSA9IHBbMV0gLSBfXy5tYXJnaW4udG9wO1xyXG5cclxuICAgICAgICAoZGltcyA9IGRpbWVuc2lvbnNGb3JQb2ludChwKSksXHJcbiAgICAgICAgICAoYXJjID0ge1xyXG4gICAgICAgICAgICBwMTogcCxcclxuICAgICAgICAgICAgZGltczogZGltcyxcclxuICAgICAgICAgICAgbWluWDogeHNjYWxlKGRpbXMubGVmdCksXHJcbiAgICAgICAgICAgIG1heFg6IHhzY2FsZShkaW1zLnJpZ2h0KSxcclxuICAgICAgICAgICAgbWluWTogMCxcclxuICAgICAgICAgICAgbWF4WTogaCgpLFxyXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGVuZEFuZ2xlOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGFyYzogZDMuc3ZnLmFyYygpLmlubmVyUmFkaXVzKDApLFxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGFyY3NbZGltcy5pXSA9IGFyYztcclxuICAgICAgICBhcmNzLmFjdGl2ZSA9IGRpbXMuaTtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgYm91bmRzXHJcbiAgICAgICAgYXJjLnAxWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblgsIHBbMF0pLCBhcmMubWF4WCk7XHJcbiAgICAgICAgYXJjLnAyID0gYXJjLnAxLnNsaWNlKCk7XHJcbiAgICAgICAgYXJjLnAzID0gYXJjLnAxLnNsaWNlKCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gb25EcmFnKCkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxyXG4gICAgICAgICAgYXJjID0gYXJjc1thcmNzLmFjdGl2ZV07XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xyXG4gICAgICAgIGFyYy5wMlswXSA9IE1hdGgubWluKFxyXG4gICAgICAgICAgTWF0aC5tYXgoYXJjLm1pblggKyAxLCBldi54IC0gX18ubWFyZ2luLmxlZnQpLFxyXG4gICAgICAgICAgYXJjLm1heFgsXHJcbiAgICAgICAgKTtcclxuICAgICAgICBhcmMucDJbMV0gPSBNYXRoLm1pbihcclxuICAgICAgICAgIE1hdGgubWF4KGFyYy5taW5ZLCBldi55IC0gX18ubWFyZ2luLnRvcCksXHJcbiAgICAgICAgICBhcmMubWF4WSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGFyYy5wMyA9IGFyYy5wMi5zbGljZSgpO1xyXG4gICAgICAgIGRyYXdTdHJ1bShhcmMsIDEpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNvbWUgaGVscGVyIGZ1bmN0aW9uc1xyXG4gICAgZnVuY3Rpb24gaHlwb3RoZW51c2UoYSwgYikge1xyXG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciByYWQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYyA9IE1hdGguUEkgLyAxODA7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5nbGUpIHtcclxuICAgICAgICByZXR1cm4gYW5nbGUgKiBjO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICB2YXIgZGVnID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGMgPSAxODAgLyBNYXRoLlBJO1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFuZ2xlICogYztcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gWzAsIDIqUEldIC0+IFstUEkvMiwgUEkvMl1cclxuICAgIHZhciBzaWduZWRBbmdsZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xyXG4gICAgICB2YXIgcmV0ID0gYW5nbGU7XHJcbiAgICAgIGlmIChhbmdsZSA+IE1hdGguUEkpIHtcclxuICAgICAgICByZXQgPSBhbmdsZSAtIDEuNSAqIE1hdGguUEk7XHJcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAxLjUgKiBNYXRoLlBJO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMC41ICogTWF0aC5QSTtcclxuICAgICAgICByZXQgPSBhbmdsZSAtIDAuNSAqIE1hdGguUEk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIC1yZXQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogYW5nbGVzIGFyZSBzdG9yZWQgaW4gcmFkaWFucyBmcm9tIGluIFswLCAyKlBJXSwgd2hlcmUgMCBpbiAxMiBvJ2Nsb2NrLlxyXG4gICAgICogSG93ZXZlciwgb25lIGNhbiBvbmx5IHNlbGVjdCBsaW5lcyBmcm9tIDAgdG8gUEksIHNvIHdlIGNvbXB1dGUgdGhlXHJcbiAgICAgKiAnc2lnbmVkJyBhbmdsZSwgd2hlcmUgMCBpcyB0aGUgaG9yaXpvbnRhbCBsaW5lICgzIG8nY2xvY2spLCBhbmQgKy8tIFBJLzJcclxuICAgICAqIGFyZSAxMiBhbmQgNiBvJ2Nsb2NrIHJlc3BlY3RpdmVseS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gY29udGFpbm1lbnRUZXN0KGFyYykge1xyXG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IHNpZ25lZEFuZ2xlKGFyYy5zdGFydEFuZ2xlKTtcclxuICAgICAgdmFyIGVuZEFuZ2xlID0gc2lnbmVkQW5nbGUoYXJjLmVuZEFuZ2xlKTtcclxuXHJcbiAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcclxuICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcclxuICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XHJcbiAgICAgICAgZW5kQW5nbGUgPSB0bXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHRlc3QgaWYgc2VnbWVudCBhbmdsZSBpcyBjb250YWluZWQgaW4gYW5nbGUgaW50ZXJ2YWxcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgaWYgKGEgPj0gc3RhcnRBbmdsZSAmJiBhIDw9IGVuZEFuZ2xlKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZWxlY3RlZCgpIHtcclxuICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyY3MpLFxyXG4gICAgICAgIGJydXNoZWQgPSBfXy5kYXRhO1xyXG5cclxuICAgICAgLy8gR2V0IHRoZSBpZHMgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgYXJjcy5cclxuICAgICAgaWRzID0gaWRzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiAhaXNOYU4oZCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZnVuY3Rpb24gY3Jvc3Nlc1N0cnVtKGQsIGlkKSB7XHJcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdLFxyXG4gICAgICAgICAgdGVzdCA9IGNvbnRhaW5tZW50VGVzdChhcmMpLFxyXG4gICAgICAgICAgZDEgPSBhcmMuZGltcy5sZWZ0LFxyXG4gICAgICAgICAgZDIgPSBhcmMuZGltcy5yaWdodCxcclxuICAgICAgICAgIHkxID0geXNjYWxlW2QxXSxcclxuICAgICAgICAgIHkyID0geXNjYWxlW2QyXSxcclxuICAgICAgICAgIGEgPSBhcmNzLndpZHRoKGlkKSxcclxuICAgICAgICAgIGIgPSB5MShkW2QxXSkgLSB5MihkW2QyXSksXHJcbiAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYiksXHJcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXNpbihiIC8gYyk7IC8vIHJhZCBpbiBbLVBJLzIsIFBJLzJdXHJcbiAgICAgICAgcmV0dXJuIHRlc3QoYW5nbGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBicnVzaGVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYnJ1c2hlZC5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBzd2l0Y2ggKGJydXNoLnByZWRpY2F0ZSkge1xyXG4gICAgICAgICAgY2FzZSAnQU5EJzpcclxuICAgICAgICAgICAgcmV0dXJuIGlkcy5ldmVyeShmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICBjYXNlICdPUic6XHJcbiAgICAgICAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gY3Jvc3Nlc1N0cnVtKGQsIGlkKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlU3RydW0oKSB7XHJcbiAgICAgIHZhciBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXSxcclxuICAgICAgICBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjYXJjcycpO1xyXG5cclxuICAgICAgZGVsZXRlIGFyY3NbYXJjcy5hY3RpdmVdO1xyXG4gICAgICBhcmNzLmFjdGl2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgc3ZnLnNlbGVjdEFsbCgnbGluZSNhcmMtJyArIGFyYy5kaW1zLmkpLnJlbW92ZSgpO1xyXG4gICAgICBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjYXJjLScgKyBhcmMuZGltcy5pKS5yZW1vdmUoKTtcclxuICAgICAgc3ZnLnNlbGVjdEFsbCgncGF0aCNhcmMtJyArIGFyYy5kaW1zLmkpLnJlbW92ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG9uRHJhZ0VuZCgpIHtcclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYnJ1c2hlZCA9IF9fLmRhdGEsXHJcbiAgICAgICAgICBhcmMgPSBhcmNzW2FyY3MuYWN0aXZlXTtcclxuXHJcbiAgICAgICAgLy8gT2theSwgc29tZXdoYXQgdW5leHBlY3RlZCwgYnV0IG5vdCB0b3RhbGx5IHVuc3VycHJpc2luZywgYSBtb3VzY2xpY2sgaXNcclxuICAgICAgICAvLyBjb25zaWRlcmVkIGEgZHJhZyB3aXRob3V0IG1vdmUuIFNvIHdlIGhhdmUgdG8gZGVhbCB3aXRoIHRoYXQgY2FzZVxyXG4gICAgICAgIGlmIChhcmMgJiYgYXJjLnAxWzBdID09PSBhcmMucDJbMF0gJiYgYXJjLnAxWzFdID09PSBhcmMucDJbMV0pIHtcclxuICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGFyYykge1xyXG4gICAgICAgICAgdmFyIGFuZ2xlID0gYXJjcy5zdGFydEFuZ2xlKGFyY3MuYWN0aXZlKTtcclxuXHJcbiAgICAgICAgICBhcmMuc3RhcnRBbmdsZSA9IGFuZ2xlO1xyXG4gICAgICAgICAgYXJjLmVuZEFuZ2xlID0gYW5nbGU7XHJcbiAgICAgICAgICBhcmMuYXJjXHJcbiAgICAgICAgICAgIC5vdXRlclJhZGl1cyhhcmNzLmxlbmd0aChhcmNzLmFjdGl2ZSkpXHJcbiAgICAgICAgICAgIC5zdGFydEFuZ2xlKGFuZ2xlKVxyXG4gICAgICAgICAgICAuZW5kQW5nbGUoYW5nbGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJ1c2hlZCA9IHNlbGVjdGVkKGFyY3MpO1xyXG4gICAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF9fLmJydXNoZWQgPSBicnVzaGVkO1xyXG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcclxuICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChhcmNzKSB7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFyY3MpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIGFyY3MuYWN0aXZlID0gZDtcclxuICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIG9uRHJhZ0VuZChhcmNzKSgpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XHJcbiAgICAgIHZhciBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpO1xyXG5cclxuICAgICAgLy8gTWFwIG9mIGN1cnJlbnQgYXJjcy4gYXJjcyBhcmUgc3RvcmVkIHBlciBzZWdtZW50IG9mIHRoZSBQQy4gQSBzZWdtZW50LFxyXG4gICAgICAvLyBiZWluZyB0aGUgYXJlYSBiZXR3ZWVuIHR3byBheGVzLiBUaGUgbGVmdCBtb3N0IGFyZWEgaXMgaW5kZXhlZCBhdCAwLlxyXG4gICAgICBhcmNzLmFjdGl2ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgLy8gUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIFBDIHNlZ21lbnQgd2hlcmUgY3VycmVudGx5IGEgYXJjIGlzIGJlaW5nXHJcbiAgICAgIC8vIHBsYWNlZC4gTk9URTogZXZlbiB0aG91Z2ggdGhleSBhcmUgZXZlbmx5IHNwYWNlZCBpbiBvdXIgY3VycmVudFxyXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgd2Uga2VlcCBmb3Igd2hlbiBub24tZXZlbiBzcGFjZWQgc2VnbWVudHMgYXJlIHN1cHBvcnRlZCBhc1xyXG4gICAgICAvLyB3ZWxsLlxyXG4gICAgICBhcmNzLndpZHRoID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdO1xyXG5cclxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJjLm1heFggLSBhcmMubWluWDtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIHJldHVybnMgYW5nbGVzIGluIFstUEkvMiwgUEkvMl1cclxuICAgICAgYW5nbGUgPSBmdW5jdGlvbiAocDEsIHAyKSB7XHJcbiAgICAgICAgdmFyIGEgPSBwMVswXSAtIHAyWzBdLFxyXG4gICAgICAgICAgYiA9IHAxWzFdIC0gcDJbMV0sXHJcbiAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYik7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLmFzaW4oYiAvIGMpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gcmV0dXJucyBhbmdsZXMgaW4gWzAsIDIgKiBQSV1cclxuICAgICAgYXJjcy5lbmRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcclxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzQW5nbGUgPSBhbmdsZShhcmMucDEsIGFyYy5wMiksXHJcbiAgICAgICAgICB1QW5nbGUgPSAtc0FuZ2xlICsgTWF0aC5QSSAvIDI7XHJcblxyXG4gICAgICAgIGlmIChhcmMucDFbMF0gPiBhcmMucDJbMF0pIHtcclxuICAgICAgICAgIHVBbmdsZSA9IDIgKiBNYXRoLlBJIC0gdUFuZ2xlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVBbmdsZTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGFyY3Muc3RhcnRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcclxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgc0FuZ2xlID0gYW5nbGUoYXJjLnAxLCBhcmMucDMpLFxyXG4gICAgICAgICAgdUFuZ2xlID0gLXNBbmdsZSArIE1hdGguUEkgLyAyO1xyXG5cclxuICAgICAgICBpZiAoYXJjLnAxWzBdID4gYXJjLnAzWzBdKSB7XHJcbiAgICAgICAgICB1QW5nbGUgPSAyICogTWF0aC5QSSAtIHVBbmdsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1QW5nbGU7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBhcmNzLmxlbmd0aCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcclxuXHJcbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGEgPSBhcmMucDFbMF0gLSBhcmMucDJbMF0sXHJcbiAgICAgICAgICBiID0gYXJjLnAxWzFdIC0gYXJjLnAyWzFdLFxyXG4gICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpO1xyXG5cclxuICAgICAgICByZXR1cm4gYztcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmNzKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZmlyc3QgZGltZW5zaW9uIGlzIGRpcmVjdGx5IGxlZnQgb2YgdGhlIHNlY29uZCBkaW1lbnNpb24uXHJcbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xyXG4gICAgICAgICAgdmFyIGxlbmd0aCA9IF9fLmRpbWVuc2lvbnMubGVuZ3RoO1xyXG4gICAgICAgICAgcmV0dXJuIF9fLmRpbWVuc2lvbnMuc29tZShmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3RcclxuICAgICAgICAgICAgICA/IGkgKyBpIDwgbGVuZ3RoICYmIF9fLmRpbWVuc2lvbnNbaSArIDFdID09PSBzZWNvbmRcclxuICAgICAgICAgICAgICA6IGZhbHNlO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIC8vIFdlIGhhdmUgc29tZSBhcmNzLCB3aGljaCBtaWdodCBuZWVkIHRvIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgZGltcyA9IGFyY3NbZF0uZGltcztcclxuICAgICAgICAgICAgYXJjcy5hY3RpdmUgPSBkO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgdHdvIGRpbWVuc2lvbnMgb2YgdGhlIGN1cnJlbnQgYXJjIGFyZSBub3QgbmV4dCB0byBlYWNoIG90aGVyXHJcbiAgICAgICAgICAgIC8vIGFueSBtb3JlLCB0aGFuIHdlJ2xsIG5lZWQgdG8gcmVtb3ZlIHRoZSBhcmMuIE90aGVyd2lzZSB3ZSBrZWVwIGl0LlxyXG4gICAgICAgICAgICBpZiAoIWNvbnNlY3V0aXZlKGRpbXMubGVmdCwgZGltcy5yaWdodCkpIHtcclxuICAgICAgICAgICAgICByZW1vdmVTdHJ1bShhcmNzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBvbkRyYWdFbmQoYXJjcykoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gQWRkIGEgbmV3IHN2ZyBncm91cCBpbiB3aGljaCB3ZSBkcmF3IHRoZSBhcmNzLlxyXG4gICAgICBwYy5zZWxlY3Rpb25cclxuICAgICAgICAuc2VsZWN0KCdzdmcnKVxyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdpZCcsICdhcmNzJylcclxuICAgICAgICAuYXR0cihcclxuICAgICAgICAgICd0cmFuc2Zvcm0nLFxyXG4gICAgICAgICAgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknLFxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAvLyBJbnN0YWxsIHRoZSByZXF1aXJlZCBicnVzaFJlc2V0IGZ1bmN0aW9uXHJcbiAgICAgIHBjLmJydXNoUmVzZXQgPSBicnVzaFJlc2V0KGFyY3MpO1xyXG5cclxuICAgICAgZHJhZ1xyXG4gICAgICAgIC5vbignZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQoYXJjcykpXHJcbiAgICAgICAgLm9uKCdkcmFnJywgb25EcmFnKGFyY3MpKVxyXG4gICAgICAgIC5vbignZHJhZ2VuZCcsIG9uRHJhZ0VuZChhcmNzKSk7XHJcblxyXG4gICAgICAvLyBOT1RFOiBUaGUgc3R5bGluZyBuZWVkcyB0byBiZSBkb25lIGhlcmUgYW5kIG5vdCBpbiB0aGUgY3NzLiBUaGlzIGlzIGJlY2F1c2VcclxuICAgICAgLy8gICAgICAgZm9yIDFEIGJydXNoaW5nLCB0aGUgY2FudmFzIGxheWVycyBzaG91bGQgbm90IGxpc3RlbiB0b1xyXG4gICAgICAvLyAgICAgICBwb2ludGVyLWV2ZW50cy5cclxuICAgICAgc3RydW1SZWN0ID0gcGMuc2VsZWN0aW9uXHJcbiAgICAgICAgLnNlbGVjdCgnc3ZnJylcclxuICAgICAgICAuaW5zZXJ0KCdyZWN0JywgJ2cjYXJjcycpXHJcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2FyYy1ldmVudHMnKVxyXG4gICAgICAgIC5hdHRyKCd4JywgX18ubWFyZ2luLmxlZnQpXHJcbiAgICAgICAgLmF0dHIoJ3knLCBfXy5tYXJnaW4udG9wKVxyXG4gICAgICAgIC5hdHRyKCd3aWR0aCcsIHcoKSlcclxuICAgICAgICAuYXR0cignaGVpZ2h0JywgaCgpICsgMilcclxuICAgICAgICAuc3R5bGUoJ29wYWNpdHknLCAwKVxyXG4gICAgICAgIC5jYWxsKGRyYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIGJydXNoLm1vZGVzWydhbmd1bGFyJ10gPSB7XHJcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXHJcbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJykucmVtb3ZlKCk7XHJcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdyZWN0I2FyYy1ldmVudHMnKS5yZW1vdmUoKTtcclxuICAgICAgICBwYy5vbignYXhlc3Jlb3JkZXIuYXJjcycsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XHJcblxyXG4gICAgICAgIHN0cnVtUmVjdCA9IHVuZGVmaW5lZDtcclxuICAgICAgfSxcclxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxyXG4gICAgICBicnVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyY3M7XHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG4gIHBjLmludGVyYWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgZmxhZ3MuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gZXhwb3NlIGEgZmV3IG9iamVjdHNcclxuICBwYy54c2NhbGUgPSB4c2NhbGU7XHJcbiAgcGMueXNjYWxlID0geXNjYWxlO1xyXG4gIHBjLmN0eCA9IGN0eDtcclxuICBwYy5jYW52YXMgPSBjYW52YXM7XHJcbiAgcGMuZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBnO1xyXG4gIH07XHJcblxyXG4gIC8vIHJlc2NhbGUgZm9yIGhlaWdodCwgd2lkdGggYW5kIG1hcmdpbnNcclxuICAvLyBUT0RPIGN1cnJlbnRseSBhc3N1bWVzIGNoYXJ0IGlzIGJydXNoYWJsZSwgYW5kIGRlc3Ryb3lzIG9sZCBicnVzaGVzXHJcbiAgcGMucmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gc2VsZWN0aW9uIHNpemVcclxuICAgIHBjLnNlbGVjdGlvblxyXG4gICAgICAuc2VsZWN0KCdzdmcnKVxyXG4gICAgICAuYXR0cignd2lkdGgnLCBfXy53aWR0aClcclxuICAgICAgLmF0dHIoJ2hlaWdodCcsIF9fLmhlaWdodCk7XHJcbiAgICBwYy5zdmcuYXR0cihcclxuICAgICAgJ3RyYW5zZm9ybScsXHJcbiAgICAgICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyxcclxuICAgICk7XHJcblxyXG4gICAgLy8gRklYTUU6IHRoZSBjdXJyZW50IGJydXNoIHN0YXRlIHNob3VsZCBwYXNzIHRocm91Z2hcclxuICAgIGlmIChmbGFncy5icnVzaGFibGUpIHBjLmJydXNoUmVzZXQoKTtcclxuXHJcbiAgICAvLyBzY2FsZXNcclxuICAgIHBjLmF1dG9zY2FsZSgpO1xyXG5cclxuICAgIC8vIGF4ZXMsIGRlc3Ryb3lzIG9sZCBicnVzaGVzLlxyXG4gICAgaWYgKGcpIHBjLmNyZWF0ZUF4ZXMoKTtcclxuICAgIGlmIChmbGFncy5icnVzaGFibGUpIHBjLmJydXNoYWJsZSgpO1xyXG4gICAgaWYgKGZsYWdzLnJlb3JkZXJhYmxlKSBwYy5yZW9yZGVyYWJsZSgpO1xyXG5cclxuICAgIGV2ZW50cy5yZXNpemUuY2FsbCh0aGlzLCB7XHJcbiAgICAgIHdpZHRoOiBfXy53aWR0aCxcclxuICAgICAgaGVpZ2h0OiBfXy5oZWlnaHQsXHJcbiAgICAgIG1hcmdpbjogX18ubWFyZ2luLFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBoaWdobGlnaHQgYW4gYXJyYXkgb2YgZGF0YVxyXG4gIHBjLmhpZ2hsaWdodCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gX18uaGlnaGxpZ2h0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgX18uaGlnaGxpZ2h0ZWQgPSBkYXRhO1xyXG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xyXG4gICAgZDMuc2VsZWN0QWxsKFtjYW52YXMuZm9yZWdyb3VuZCwgY2FudmFzLmJydXNoZWRdKS5jbGFzc2VkKCdmYWRlZCcsIHRydWUpO1xyXG4gICAgZGF0YS5mb3JFYWNoKHBhdGhfaGlnaGxpZ2h0KTtcclxuICAgIGV2ZW50cy5oaWdobGlnaHQuY2FsbCh0aGlzLCBkYXRhKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIGNsZWFyIGhpZ2hsaWdodGluZ1xyXG4gIHBjLnVuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgX18uaGlnaGxpZ2h0ZWQgPSBbXTtcclxuICAgIHBjLmNsZWFyKCdoaWdobGlnaHQnKTtcclxuICAgIGQzLnNlbGVjdEFsbChbY2FudmFzLmZvcmVncm91bmQsIGNhbnZhcy5icnVzaGVkXSkuY2xhc3NlZCgnZmFkZWQnLCBmYWxzZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBjYWxjdWxhdGUgMmQgaW50ZXJzZWN0aW9uIG9mIGxpbmUgYS0+YiB3aXRoIGxpbmUgYy0+ZFxyXG4gIC8vIHBvaW50cyBhcmUgb2JqZWN0cyB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xyXG4gIHBjLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OlxyXG4gICAgICAgICgoYS54ICogYi55IC0gYS55ICogYi54KSAqIChjLnggLSBkLngpIC1cclxuICAgICAgICAgIChhLnggLSBiLngpICogKGMueCAqIGQueSAtIGMueSAqIGQueCkpIC9cclxuICAgICAgICAoKGEueCAtIGIueCkgKiAoYy55IC0gZC55KSAtIChhLnkgLSBiLnkpICogKGMueCAtIGQueCkpLFxyXG4gICAgICB5OlxyXG4gICAgICAgICgoYS54ICogYi55IC0gYS55ICogYi54KSAqIChjLnkgLSBkLnkpIC1cclxuICAgICAgICAgIChhLnkgLSBiLnkpICogKGMueCAqIGQueSAtIGMueSAqIGQueCkpIC9cclxuICAgICAgICAoKGEueCAtIGIueCkgKiAoYy55IC0gZC55KSAtIChhLnkgLSBiLnkpICogKGMueCAtIGQueCkpLFxyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBwb3NpdGlvbihkKSB7XHJcbiAgICB2YXIgdiA9IGRyYWdnaW5nW2RdO1xyXG4gICAgcmV0dXJuIHYgPT0gbnVsbCA/IHhzY2FsZShkKSA6IHY7XHJcbiAgfVxyXG4gIHBjLnZlcnNpb24gPSAnMC43LjAnO1xyXG4gIC8vIHRoaXMgZGVzY3JpcHRpdmUgdGV4dCBzaG91bGQgbGl2ZSB3aXRoIG90aGVyIGludHJvc3BlY3RpdmUgbWV0aG9kc1xyXG4gIHBjLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgJ1BhcmFsbGVsIENvb3JkaW5hdGVzOiAnICtcclxuICAgICAgX18uZGltZW5zaW9ucy5sZW5ndGggK1xyXG4gICAgICAnIGRpbWVuc2lvbnMgKCcgK1xyXG4gICAgICBkMy5rZXlzKF9fLmRhdGFbMF0pLmxlbmd0aCArXHJcbiAgICAgICcgdG90YWwpICwgJyArXHJcbiAgICAgIF9fLmRhdGEubGVuZ3RoICtcclxuICAgICAgJyByb3dzJ1xyXG4gICAgKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gcGM7XHJcbn1cclxuXHJcbmQzLnJlbmRlclF1ZXVlID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICB2YXIgX3F1ZXVlID0gW10sIC8vIGRhdGEgdG8gYmUgcmVuZGVyZWRcclxuICAgIF9yYXRlID0gMTAsIC8vIG51bWJlciBvZiBjYWxscyBwZXIgZnJhbWVcclxuICAgIF9jbGVhciA9IGZ1bmN0aW9uICgpIHt9LCAvLyBjbGVhcmluZyBmdW5jdGlvblxyXG4gICAgX2kgPSAwOyAvLyBjdXJyZW50IGl0ZXJhdGlvblxyXG5cclxuICB2YXIgcnEgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgaWYgKGRhdGEpIHJxLmRhdGEoZGF0YSk7XHJcbiAgICBycS5pbnZhbGlkYXRlKCk7XHJcbiAgICBfY2xlYXIoKTtcclxuICAgIHJxLnJlbmRlcigpO1xyXG4gIH07XHJcblxyXG4gIHJxLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIF9pID0gMDtcclxuICAgIHZhciB2YWxpZCA9IHRydWU7XHJcbiAgICBycS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBkb0ZyYW1lKCkge1xyXG4gICAgICBpZiAoIXZhbGlkKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgaWYgKF9pID4gX3F1ZXVlLmxlbmd0aCkgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAvLyBUeXBpY2FsIGQzIGJlaGF2aW9yIGlzIHRvIHBhc3MgYSBkYXRhIGl0ZW0gKmFuZCogaXRzIGluZGV4LiBBcyB0aGVcclxuICAgICAgLy8gcmVuZGVyIHF1ZXVlIHNwbGl0cyB0aGUgb3JpZ2luYWwgZGF0YSBzZXQsIHdlJ2xsIGhhdmUgdG8gYmUgc2xpZ2h0bHlcclxuICAgICAgLy8gbW9yZSBjYXJlZnVsbCBhYm91dCBwYXNzaW5nIHRoZSBjb3JyZWN0IGluZGV4IHdpdGggdGhlIGRhdGEgaXRlbS5cclxuICAgICAgdmFyIGVuZCA9IE1hdGgubWluKF9pICsgX3JhdGUsIF9xdWV1ZS5sZW5ndGgpO1xyXG4gICAgICBmb3IgKHZhciBpID0gX2k7IGkgPCBlbmQ7IGkgKz0gMSkge1xyXG4gICAgICAgIGZ1bmMoX3F1ZXVlW2ldLCBpKTtcclxuICAgICAgfVxyXG4gICAgICBfaSArPSBfcmF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBkMy50aW1lcihkb0ZyYW1lKTtcclxuICB9O1xyXG5cclxuICBycS5kYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJxLmludmFsaWRhdGUoKTtcclxuICAgIF9xdWV1ZSA9IGRhdGEuc2xpY2UoMCk7XHJcbiAgICByZXR1cm4gcnE7XHJcbiAgfTtcclxuXHJcbiAgcnEucmF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gX3JhdGU7XHJcbiAgICBfcmF0ZSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIHJxO1xyXG4gIH07XHJcblxyXG4gIHJxLnJlbWFpbmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBfcXVldWUubGVuZ3RoIC0gX2k7XHJcbiAgfTtcclxuXHJcbiAgLy8gY2xlYXIgdGhlIGNhbnZhc1xyXG4gIHJxLmNsZWFyID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICBfY2xlYXIoKTtcclxuICAgICAgcmV0dXJuIHJxO1xyXG4gICAgfVxyXG4gICAgX2NsZWFyID0gZnVuYztcclxuICAgIHJldHVybiBycTtcclxuICB9O1xyXG5cclxuICBycS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG4gIHJldHVybiBycTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/d3.parcoords.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js":
/*!******************************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default =\n\n\nfunction (config) {\n  var columns = [];\n\n  var dg = function (selection) {\n    if (columns.length == 0) columns = d3.keys(selection.data()[0][0]);\n\n    // header\n    selection.\n    selectAll('.header').\n    data([true]).\n    enter().\n    append('div').\n    attr('class', 'header');\n\n    var header = selection.select('.header').selectAll('.cell').data(columns);\n\n    header.\n    enter().\n    append('div').\n    attr('class', function (d, i) {\n      return 'col-' + i;\n    }).\n    classed('cell', true);\n\n    selection.selectAll('.header .cell').text(function (d) {\n      return d;\n    });\n\n    header.exit().remove();\n\n    // rows\n    var rows = selection.selectAll('.row').data(function (d) {\n      return d;\n    });\n\n    rows.enter().append('div').attr('class', 'row');\n\n    rows.exit().remove();\n\n    var cells = selection.\n    selectAll('.row').\n    selectAll('.cell').\n    data(function (d) {\n      return columns.map(function (col) {\n        return d[col];\n      });\n    });\n\n    // cells\n    cells.\n    enter().\n    append('div').\n    attr('class', function (d, i) {\n      return 'col-' + i;\n    }).\n    classed('cell', true);\n\n    cells.exit().remove();\n\n    selection.selectAll('.cell').text(function (d) {\n      return d;\n    });\n\n    return dg;\n  };\n\n  dg.columns = function (_) {\n    if (!arguments.length) return columns;\n    columns = _;\n    return this;\n  };\n\n  return dg;\n}; /* [LICENSE TBD] */ /* eslint-disable */ // from http://bl.ocks.org/3687826\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-parallel-coordinates\\\\src\\\\vendor\\\\parcoords\\\\divgrid.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBekVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvc3JjL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcz80MDQxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFtMSUNFTlNFIFRCRF0gKi9cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuLy8gZnJvbSBodHRwOi8vYmwub2Nrcy5vcmcvMzY4NzgyNlxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgdmFyIGNvbHVtbnMgPSBbXTtcclxuXHJcbiAgdmFyIGRnID0gZnVuY3Rpb24gKHNlbGVjdGlvbikge1xyXG4gICAgaWYgKGNvbHVtbnMubGVuZ3RoID09IDApIGNvbHVtbnMgPSBkMy5rZXlzKHNlbGVjdGlvbi5kYXRhKClbMF1bMF0pO1xyXG5cclxuICAgIC8vIGhlYWRlclxyXG4gICAgc2VsZWN0aW9uXHJcbiAgICAgIC5zZWxlY3RBbGwoJy5oZWFkZXInKVxyXG4gICAgICAuZGF0YShbdHJ1ZV0pXHJcbiAgICAgIC5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdoZWFkZXInKTtcclxuXHJcbiAgICB2YXIgaGVhZGVyID0gc2VsZWN0aW9uLnNlbGVjdCgnLmhlYWRlcicpLnNlbGVjdEFsbCgnLmNlbGwnKS5kYXRhKGNvbHVtbnMpO1xyXG5cclxuICAgIGhlYWRlclxyXG4gICAgICAuZW50ZXIoKVxyXG4gICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgIHJldHVybiAnY29sLScgKyBpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2xhc3NlZCgnY2VsbCcsIHRydWUpO1xyXG5cclxuICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5oZWFkZXIgLmNlbGwnKS50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIHJldHVybiBkO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaGVhZGVyLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcbiAgICAvLyByb3dzXHJcbiAgICB2YXIgcm93cyA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoJy5yb3cnKS5kYXRhKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIHJldHVybiBkO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcm93cy5lbnRlcigpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAncm93Jyk7XHJcblxyXG4gICAgcm93cy5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG4gICAgdmFyIGNlbGxzID0gc2VsZWN0aW9uXHJcbiAgICAgIC5zZWxlY3RBbGwoJy5yb3cnKVxyXG4gICAgICAuc2VsZWN0QWxsKCcuY2VsbCcpXHJcbiAgICAgIC5kYXRhKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uIChjb2wpIHtcclxuICAgICAgICAgIHJldHVybiBkW2NvbF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIC8vIGNlbGxzXHJcbiAgICBjZWxsc1xyXG4gICAgICAuZW50ZXIoKVxyXG4gICAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgIHJldHVybiAnY29sLScgKyBpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2xhc3NlZCgnY2VsbCcsIHRydWUpO1xyXG5cclxuICAgIGNlbGxzLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCcuY2VsbCcpLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgcmV0dXJuIGQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gZGc7XHJcbiAgfTtcclxuXHJcbiAgZGcuY29sdW1ucyA9IGZ1bmN0aW9uIChfKSB7XHJcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2x1bW5zO1xyXG4gICAgY29sdW1ucyA9IF87XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICByZXR1cm4gZGc7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-parallel-coordinates/src/vendor/parcoords/divgrid.js\n");

/***/ }),

/***/ "./packages/superset-ui-core/src/chart/components/reactify.tsx":
/*!*********************************************************************!*\
  !*** ./packages/superset-ui-core/src/chart/components/reactify.tsx ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reactify)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\nfunction reactify(renderFn, callbacks) {\n  class ReactifiedComponent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n\n    constructor(props) {\n      super(props);this.container = void 0;\n      this.setContainerRef = this.setContainerRef.bind(this);\n    }\n    componentDidMount() {\n      this.execute();\n    }\n    componentDidUpdate() {\n      this.execute();\n    }\n    componentWillUnmount() {\n      this.container = undefined;\n      if (callbacks != null && callbacks.componentWillUnmount) {\n        callbacks.componentWillUnmount.bind(this)();\n      }\n    }\n    setContainerRef(ref) {\n      this.container = ref;\n    }\n    execute() {\n      if (this.container) {\n        renderFn(this.container, this.props);\n      }\n    }\n    render() {\n      const { id, className } = this.props;\n      return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: this.setContainerRef, id: id, className: className });\n    } // @ts-ignore\n    __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n      this[key] = eval(code);}}const ReactifiedClass = ReactifiedComponent;\n  if (renderFn.displayName) {\n    ReactifiedClass.displayName = renderFn.displayName;\n  }\n  // eslint-disable-next-line react/forbid-foreign-prop-types\n  if (renderFn.propTypes) {\n    ReactifiedClass.propTypes = {\n      ...ReactifiedClass.propTypes,\n      ...renderFn.propTypes };\n\n  }\n  if (renderFn.defaultProps) {\n    ReactifiedClass.defaultProps = renderFn.defaultProps;\n  }\n  return ReactifiedComponent;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(reactify, \"reactify\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\packages\\\\superset-ui-core\\\\src\\\\chart\\\\components\\\\reactify.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWNrYWdlcy9zdXBlcnNldC11aS1jb3JlL3NyYy9jaGFydC9jb21wb25lbnRzL3JlYWN0aWZ5LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFFQTtBQStCQTtBQUlBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBckNBO0FBQUE7QUEyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BhY2thZ2VzL3N1cGVyc2V0LXVpLWNvcmUvc3JjL2NoYXJ0L2NvbXBvbmVudHMvcmVhY3RpZnkudHN4P2VjYTQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbi8vIFRPRE86IE5vdGUgdGhhdCBpZCBhbmQgY2xhc3NOYW1lIGNhbiBjb2xsaWRlIGJldHdlZW4gUHJvcHMgYW5kIFJlYWN0aWZ5UHJvcHNcclxuLy8gbGVhZGluZyB0byAobGlrZWx5KSB1bmV4cGVjdGVkIGJlaGF2aW9ycy4gV2Ugc2hvdWxkIGVpdGhlciByZXF1aXJlIFByb3BzIHRvIG5vdFxyXG4vLyBjb250YWluIGFuIGlkL2NsYXNzTmFtZSwgb3Igbm90IGNvbWJpbmUgdGhlbSAodmlhIGludGVyc2VjdGlvbiksIGluc3RlYWQgcHJlZmVycmluZ1xyXG4vLyB3cmFwcGluZyAoY29tcG9zaXRpb24pLiBBcyBhbiBleGFtcGxlOlxyXG4vLyBpbnRlcmZhY2UgTXlQcm9wcyB7XHJcbi8vICAgaWQ6IG51bWJlcjtcclxuLy8gfVxyXG4vLyBmdW5jdGlvbiBteVJlbmRlcihjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBwcm9wczogUmVhZG9ubHk8TXlQcm9wcz4pOiB2b2lkIHtcclxuLy8gICBwcm9wcy5pZCAvLyB1bnVzYWJsZTogaWQgaXMgc3RyaW5nICYgbnVtYmVyXHJcbi8vIH1cclxuLy8gbmV3IChyZWFjdGlmeShteVJlbmRlcikpKHsgaWQ6IDUgfSk7IC8vIGVycm9yOiBpZCBoYXMgdG8gYmUgc3RyaW5nICYgbnVtYmVyXHJcblxyXG5leHBvcnQgdHlwZSBSZWFjdGlmeVByb3BzID0ge1xyXG4gIGlkPzogc3RyaW5nO1xyXG4gIGNsYXNzTmFtZT86IHN0cmluZztcclxufTtcclxuXHJcbi8vIFRPRE86IGFkZCBtb3JlIFJlYWN0IGxpZmVjeWNsZSBjYWxsYmFja3MgYXMgbmVlZGVkXHJcbmV4cG9ydCB0eXBlIExpZmVDeWNsZUNhbGxiYWNrcyA9IHtcclxuICBjb21wb25lbnRXaWxsVW5tb3VudD86ICgpID0+IHZvaWQ7XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlckZ1bmNUeXBlPFByb3BzPiB7XHJcbiAgKGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIHByb3BzOiBSZWFkb25seTxQcm9wcyAmIFJlYWN0aWZ5UHJvcHM+KTogdm9pZDtcclxuICBkaXNwbGF5TmFtZT86IHN0cmluZztcclxuICBkZWZhdWx0UHJvcHM/OiBQYXJ0aWFsPFByb3BzICYgUmVhY3RpZnlQcm9wcz47XHJcbiAgcHJvcFR5cGVzPzogUmVhY3QuV2Vha1ZhbGlkYXRpb25NYXA8UHJvcHMgJiBSZWFjdGlmeVByb3BzPjtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhY3RpZnk8UHJvcHMgZXh0ZW5kcyBvYmplY3Q+KFxyXG4gIHJlbmRlckZuOiBSZW5kZXJGdW5jVHlwZTxQcm9wcz4sXHJcbiAgY2FsbGJhY2tzPzogTGlmZUN5Y2xlQ2FsbGJhY2tzLFxyXG4pOiBSZWFjdC5Db21wb25lbnRDbGFzczxQcm9wcyAmIFJlYWN0aWZ5UHJvcHM+IHtcclxuICBjbGFzcyBSZWFjdGlmaWVkQ29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzICYgUmVhY3RpZnlQcm9wcz4ge1xyXG4gICAgY29udGFpbmVyPzogSFRNTERpdkVsZW1lbnQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzICYgUmVhY3RpZnlQcm9wcykge1xyXG4gICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyUmVmID0gdGhpcy5zZXRDb250YWluZXJSZWYuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgdGhpcy5leGVjdXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgdGhpcy5jb250YWluZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGlmIChjYWxsYmFja3M/LmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XHJcbiAgICAgICAgY2FsbGJhY2tzLmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQodGhpcykoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldENvbnRhaW5lclJlZihyZWY6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyID0gcmVmO1xyXG4gICAgfVxyXG5cclxuICAgIGV4ZWN1dGUoKSB7XHJcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xyXG4gICAgICAgIHJlbmRlckZuKHRoaXMuY29udGFpbmVyLCB0aGlzLnByb3BzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgY29uc3QgeyBpZCwgY2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgcmV0dXJuIDxkaXYgcmVmPXt0aGlzLnNldENvbnRhaW5lclJlZn0gaWQ9e2lkfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gLz47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBSZWFjdGlmaWVkQ2xhc3M6IFJlYWN0LkNvbXBvbmVudENsYXNzPFByb3BzICYgUmVhY3RpZnlQcm9wcz4gPVxyXG4gICAgUmVhY3RpZmllZENvbXBvbmVudDtcclxuXHJcbiAgaWYgKHJlbmRlckZuLmRpc3BsYXlOYW1lKSB7XHJcbiAgICBSZWFjdGlmaWVkQ2xhc3MuZGlzcGxheU5hbWUgPSByZW5kZXJGbi5kaXNwbGF5TmFtZTtcclxuICB9XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2ZvcmJpZC1mb3JlaWduLXByb3AtdHlwZXNcclxuICBpZiAocmVuZGVyRm4ucHJvcFR5cGVzKSB7XHJcbiAgICBSZWFjdGlmaWVkQ2xhc3MucHJvcFR5cGVzID0ge1xyXG4gICAgICAuLi5SZWFjdGlmaWVkQ2xhc3MucHJvcFR5cGVzLFxyXG4gICAgICAuLi5yZW5kZXJGbi5wcm9wVHlwZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAocmVuZGVyRm4uZGVmYXVsdFByb3BzKSB7XHJcbiAgICBSZWFjdGlmaWVkQ2xhc3MuZGVmYXVsdFByb3BzID0gcmVuZGVyRm4uZGVmYXVsdFByb3BzO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFJlYWN0aWZpZWRDb21wb25lbnQ7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./packages/superset-ui-core/src/chart/components/reactify.tsx\n");

/***/ })

}]);