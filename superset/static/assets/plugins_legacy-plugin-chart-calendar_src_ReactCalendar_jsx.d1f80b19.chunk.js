"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["plugins_legacy-plugin-chart-calendar_src_ReactCalendar_jsx"],{

/***/ "./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/extent.js":
/*!**********************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/extent.js ***!
  \**********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default = function (values, valueof) {\n  let min;\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null) {\n        if (min === undefined) {\n          if (value >= value) min = max = value;\n        } else {\n          if (min > value) min = value;\n          if (max < value) max = value;\n        }\n      }\n    }\n  }\n  return [min, max];\n};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\node_modules\\\\d3-array\\\\src\\\\extent.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9leHRlbnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1jYWxlbmRhci9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL2V4dGVudC5qcz82NWYzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICBsZXQgbWluO1xuICBsZXQgbWF4O1xuICBpZiAodmFsdWVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh2YWx1ZSA+PSB2YWx1ZSkgbWluID0gbWF4ID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICBpZiAobWF4IDwgdmFsdWUpIG1heCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGZvciAobGV0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWUsICsraW5kZXgsIHZhbHVlcykpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID49IHZhbHVlKSBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/extent.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/range.js":
/*!*********************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/range.js ***!
  \*********************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};const _default = function (start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n  n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n  range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n};/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(_default, \"default\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\node_modules\\\\d3-array\\\\src\\\\range.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvbm9kZV9tb2R1bGVzL2QzLWFycmF5L3NyYy9yYW5nZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1jYWxlbmRhci9ub2RlX21vZHVsZXMvZDMtYXJyYXkvc3JjL3JhbmdlLmpzP2I3N2QiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuXG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/range.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-calendar/src/Calendar.js":
/*!**************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/src/Calendar.js ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ \"./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/extent.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ \"./plugins/legacy-plugin-chart-calendar/node_modules/d3-array/src/range.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-selection */ \"./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/SequentialSchemeRegistrySingleton.ts\");\n/* harmony import */ var _vendor_cal_heatmap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vendor/cal-heatmap */ \"./plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\n\n\n\n\n\nconst propTypes = {\n  data: prop_types__WEBPACK_IMPORTED_MODULE_0___default().shape({\n    // Object hashed by metric name,\n    // then hashed by timestamp (in seconds, not milliseconds) as float\n    // the innermost value is count\n    // e.g. { count_distinct_something: { 1535034236.0: 3 } }\n    data: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().object),\n    domain: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string),\n    range: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number),\n    // timestamp in milliseconds\n    start: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number),\n    subdomain: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string) }),\n\n  height: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number),\n  // eslint-disable-next-line react/sort-prop-types\n  cellPadding: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number),\n  // eslint-disable-next-line react/sort-prop-types\n  cellRadius: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number),\n  // eslint-disable-next-line react/sort-prop-types\n  cellSize: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number),\n  linearColorScheme: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().string),\n  showLegend: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().bool),\n  showMetricName: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().bool),\n  showValues: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().bool),\n  steps: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().number),\n  timeFormatter: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func),\n  valueFormatter: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().func),\n  verboseMap: (prop_types__WEBPACK_IMPORTED_MODULE_0___default().object) };\n\n\nfunction Calendar(element, props) {\n  const {\n    data,\n    height,\n    cellPadding = 3,\n    cellRadius = 0,\n    cellSize = 10,\n    domainGranularity,\n    linearColorScheme,\n    showLegend,\n    showMetricName,\n    showValues,\n    steps,\n    subdomainGranularity,\n    timeFormatter,\n    valueFormatter,\n    verboseMap } =\n  props;\n\n  const container = (0,d3_selection__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element).\n  classed('superset-legacy-chart-calendar', true).\n  style('height', height);\n  container.selectAll('*').remove();\n  const div = container.append('div');\n\n  const subDomainTextFormat = showValues ?\n  (date, value) => valueFormatter(value) :\n  null;\n\n  const metricsData = data.data;\n\n  Object.keys(metricsData).forEach((metric) => {\n    const calContainer = div.append('div');\n    if (showMetricName) {\n      calContainer.text(`Metric: ${verboseMap[metric] || metric}`);\n    }\n    const timestamps = metricsData[metric];\n    const extents = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(Object.keys(timestamps), (key) => timestamps[key]);\n    const step = (extents[1] - extents[0]) / (steps - 1);\n    const colorScale = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_4__[\"default\"])().\n    get(linearColorScheme).\n    createLinearScale(extents);\n\n    const legend = (0,d3_array__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(steps).map((i) => extents[0] + step * i);\n    const legendColors = legend.map((x) => colorScale(x));\n\n    const cal = new _vendor_cal_heatmap__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    cal.init({\n      start: data.start,\n      data: timestamps,\n      itemSelector: calContainer.node(),\n      legendVerticalPosition: 'top',\n      cellSize,\n      cellPadding,\n      cellRadius,\n      legendCellSize: cellSize,\n      legendCellPadding: 2,\n      legendCellRadius: cellRadius,\n      tooltip: true,\n      domain: domainGranularity,\n      subDomain: subdomainGranularity,\n      range: data.range,\n      browsing: true,\n      legend,\n      legendColors: {\n        colorScale,\n        min: legendColors[0],\n        max: legendColors[legendColors.length - 1],\n        empty: 'white' },\n\n      displayLegend: showLegend,\n      itemName: '',\n      valueFormatter,\n      timeFormatter,\n      subDomainTextFormat });\n\n  });\n}\n\nCalendar.displayName = 'Calendar';\nCalendar.propTypes = propTypes;const _default =\n\nCalendar;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(propTypes, \"propTypes\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\Calendar.js\");reactHotLoader.register(Calendar, \"Calendar\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\Calendar.js\");reactHotLoader.register(_default, \"default\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\Calendar.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvc3JjL0NhbGVuZGFyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1jYWxlbmRhci9zcmMvQ2FsZW5kYXIuanM/NGM2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5pbXBvcnQgeyBleHRlbnQgYXMgZDNFeHRlbnQsIHJhbmdlIGFzIGQzUmFuZ2UgfSBmcm9tICdkMy1hcnJheSc7XHJcbmltcG9ydCB7IHNlbGVjdCBhcyBkM1NlbGVjdCB9IGZyb20gJ2QzLXNlbGVjdGlvbic7XHJcbmltcG9ydCB7IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSB9IGZyb20gJ0BzdXBlcnNldC11aS9jb3JlJztcclxuaW1wb3J0IENhbEhlYXRNYXAgZnJvbSAnLi92ZW5kb3IvY2FsLWhlYXRtYXAnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gIGRhdGE6IFByb3BUeXBlcy5zaGFwZSh7XHJcbiAgICAvLyBPYmplY3QgaGFzaGVkIGJ5IG1ldHJpYyBuYW1lLFxyXG4gICAgLy8gdGhlbiBoYXNoZWQgYnkgdGltZXN0YW1wIChpbiBzZWNvbmRzLCBub3QgbWlsbGlzZWNvbmRzKSBhcyBmbG9hdFxyXG4gICAgLy8gdGhlIGlubmVybW9zdCB2YWx1ZSBpcyBjb3VudFxyXG4gICAgLy8gZS5nLiB7IGNvdW50X2Rpc3RpbmN0X3NvbWV0aGluZzogeyAxNTM1MDM0MjM2LjA6IDMgfSB9XHJcbiAgICBkYXRhOiBQcm9wVHlwZXMub2JqZWN0LFxyXG4gICAgZG9tYWluOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgcmFuZ2U6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICAvLyB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICBzdGFydDogUHJvcFR5cGVzLm51bWJlcixcclxuICAgIHN1YmRvbWFpbjogUHJvcFR5cGVzLnN0cmluZyxcclxuICB9KSxcclxuICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L3NvcnQtcHJvcC10eXBlc1xyXG4gIGNlbGxQYWRkaW5nOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9zb3J0LXByb3AtdHlwZXNcclxuICBjZWxsUmFkaXVzOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9zb3J0LXByb3AtdHlwZXNcclxuICBjZWxsU2l6ZTogUHJvcFR5cGVzLm51bWJlcixcclxuICBsaW5lYXJDb2xvclNjaGVtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICBzaG93TGVnZW5kOiBQcm9wVHlwZXMuYm9vbCxcclxuICBzaG93TWV0cmljTmFtZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgc2hvd1ZhbHVlczogUHJvcFR5cGVzLmJvb2wsXHJcbiAgc3RlcHM6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgdGltZUZvcm1hdHRlcjogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgdmFsdWVGb3JtYXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxyXG4gIHZlcmJvc2VNYXA6IFByb3BUeXBlcy5vYmplY3QsXHJcbn07XHJcblxyXG5mdW5jdGlvbiBDYWxlbmRhcihlbGVtZW50LCBwcm9wcykge1xyXG4gIGNvbnN0IHtcclxuICAgIGRhdGEsXHJcbiAgICBoZWlnaHQsXHJcbiAgICBjZWxsUGFkZGluZyA9IDMsXHJcbiAgICBjZWxsUmFkaXVzID0gMCxcclxuICAgIGNlbGxTaXplID0gMTAsXHJcbiAgICBkb21haW5HcmFudWxhcml0eSxcclxuICAgIGxpbmVhckNvbG9yU2NoZW1lLFxyXG4gICAgc2hvd0xlZ2VuZCxcclxuICAgIHNob3dNZXRyaWNOYW1lLFxyXG4gICAgc2hvd1ZhbHVlcyxcclxuICAgIHN0ZXBzLFxyXG4gICAgc3ViZG9tYWluR3JhbnVsYXJpdHksXHJcbiAgICB0aW1lRm9ybWF0dGVyLFxyXG4gICAgdmFsdWVGb3JtYXR0ZXIsXHJcbiAgICB2ZXJib3NlTWFwLFxyXG4gIH0gPSBwcm9wcztcclxuXHJcbiAgY29uc3QgY29udGFpbmVyID0gZDNTZWxlY3QoZWxlbWVudClcclxuICAgIC5jbGFzc2VkKCdzdXBlcnNldC1sZWdhY3ktY2hhcnQtY2FsZW5kYXInLCB0cnVlKVxyXG4gICAgLnN0eWxlKCdoZWlnaHQnLCBoZWlnaHQpO1xyXG4gIGNvbnRhaW5lci5zZWxlY3RBbGwoJyonKS5yZW1vdmUoKTtcclxuICBjb25zdCBkaXYgPSBjb250YWluZXIuYXBwZW5kKCdkaXYnKTtcclxuXHJcbiAgY29uc3Qgc3ViRG9tYWluVGV4dEZvcm1hdCA9IHNob3dWYWx1ZXNcclxuICAgID8gKGRhdGUsIHZhbHVlKSA9PiB2YWx1ZUZvcm1hdHRlcih2YWx1ZSlcclxuICAgIDogbnVsbDtcclxuXHJcbiAgY29uc3QgbWV0cmljc0RhdGEgPSBkYXRhLmRhdGE7XHJcblxyXG4gIE9iamVjdC5rZXlzKG1ldHJpY3NEYXRhKS5mb3JFYWNoKG1ldHJpYyA9PiB7XHJcbiAgICBjb25zdCBjYWxDb250YWluZXIgPSBkaXYuYXBwZW5kKCdkaXYnKTtcclxuICAgIGlmIChzaG93TWV0cmljTmFtZSkge1xyXG4gICAgICBjYWxDb250YWluZXIudGV4dChgTWV0cmljOiAke3ZlcmJvc2VNYXBbbWV0cmljXSB8fCBtZXRyaWN9YCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gbWV0cmljc0RhdGFbbWV0cmljXTtcclxuICAgIGNvbnN0IGV4dGVudHMgPSBkM0V4dGVudChPYmplY3Qua2V5cyh0aW1lc3RhbXBzKSwga2V5ID0+IHRpbWVzdGFtcHNba2V5XSk7XHJcbiAgICBjb25zdCBzdGVwID0gKGV4dGVudHNbMV0gLSBleHRlbnRzWzBdKSAvIChzdGVwcyAtIDEpO1xyXG4gICAgY29uc3QgY29sb3JTY2FsZSA9IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSgpXHJcbiAgICAgIC5nZXQobGluZWFyQ29sb3JTY2hlbWUpXHJcbiAgICAgIC5jcmVhdGVMaW5lYXJTY2FsZShleHRlbnRzKTtcclxuXHJcbiAgICBjb25zdCBsZWdlbmQgPSBkM1JhbmdlKHN0ZXBzKS5tYXAoaSA9PiBleHRlbnRzWzBdICsgc3RlcCAqIGkpO1xyXG4gICAgY29uc3QgbGVnZW5kQ29sb3JzID0gbGVnZW5kLm1hcCh4ID0+IGNvbG9yU2NhbGUoeCkpO1xyXG5cclxuICAgIGNvbnN0IGNhbCA9IG5ldyBDYWxIZWF0TWFwKCk7XHJcbiAgICBjYWwuaW5pdCh7XHJcbiAgICAgIHN0YXJ0OiBkYXRhLnN0YXJ0LFxyXG4gICAgICBkYXRhOiB0aW1lc3RhbXBzLFxyXG4gICAgICBpdGVtU2VsZWN0b3I6IGNhbENvbnRhaW5lci5ub2RlKCksXHJcbiAgICAgIGxlZ2VuZFZlcnRpY2FsUG9zaXRpb246ICd0b3AnLFxyXG4gICAgICBjZWxsU2l6ZSxcclxuICAgICAgY2VsbFBhZGRpbmcsXHJcbiAgICAgIGNlbGxSYWRpdXMsXHJcbiAgICAgIGxlZ2VuZENlbGxTaXplOiBjZWxsU2l6ZSxcclxuICAgICAgbGVnZW5kQ2VsbFBhZGRpbmc6IDIsXHJcbiAgICAgIGxlZ2VuZENlbGxSYWRpdXM6IGNlbGxSYWRpdXMsXHJcbiAgICAgIHRvb2x0aXA6IHRydWUsXHJcbiAgICAgIGRvbWFpbjogZG9tYWluR3JhbnVsYXJpdHksXHJcbiAgICAgIHN1YkRvbWFpbjogc3ViZG9tYWluR3JhbnVsYXJpdHksXHJcbiAgICAgIHJhbmdlOiBkYXRhLnJhbmdlLFxyXG4gICAgICBicm93c2luZzogdHJ1ZSxcclxuICAgICAgbGVnZW5kLFxyXG4gICAgICBsZWdlbmRDb2xvcnM6IHtcclxuICAgICAgICBjb2xvclNjYWxlLFxyXG4gICAgICAgIG1pbjogbGVnZW5kQ29sb3JzWzBdLFxyXG4gICAgICAgIG1heDogbGVnZW5kQ29sb3JzW2xlZ2VuZENvbG9ycy5sZW5ndGggLSAxXSxcclxuICAgICAgICBlbXB0eTogJ3doaXRlJyxcclxuICAgICAgfSxcclxuICAgICAgZGlzcGxheUxlZ2VuZDogc2hvd0xlZ2VuZCxcclxuICAgICAgaXRlbU5hbWU6ICcnLFxyXG4gICAgICB2YWx1ZUZvcm1hdHRlcixcclxuICAgICAgdGltZUZvcm1hdHRlcixcclxuICAgICAgc3ViRG9tYWluVGV4dEZvcm1hdCxcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5DYWxlbmRhci5kaXNwbGF5TmFtZSA9ICdDYWxlbmRhcic7XHJcbkNhbGVuZGFyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhbGVuZGFyO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/src/Calendar.js\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-calendar/src/ReactCalendar.jsx":
/*!********************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/src/ReactCalendar.jsx ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/chart/components/reactify.tsx\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/style/index.tsx\");\n/* harmony import */ var _Calendar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Calendar */ \"./plugins/legacy-plugin-chart-calendar/src/Calendar.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\n\n\n\n\n\nconst ReactComponent = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_Calendar__WEBPACK_IMPORTED_MODULE_2__[\"default\"]);\n\nconst Calender = ({ className, ...otherProps }) =>\n(0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(\"div\", { className: className },\n(0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(_emotion_react__WEBPACK_IMPORTED_MODULE_4__.Global, {\n  styles: (theme) => _emotion_react__WEBPACK_IMPORTED_MODULE_4__.css`\n        .d3-tip {\n          line-height: 1;\n          padding: ${theme.gridUnit * 3}px;\n          background: ${theme.colors.grayscale.dark2};\n          color: ${theme.colors.grayscale.light5};\n          border-radius: 4px;\n          pointer-events: none;\n          z-index: 1000;\n          font-size: ${theme.typography.sizes.s}px;\n        }\n        /* Creates a small triangle extender for the tooltip */\n        .d3-tip:after {\n          box-sizing: border-box;\n          display: inline;\n          font-size: ${theme.typography.sizes.xs};\n          width: 100%;\n          line-height: 1;\n          color: ${theme.colors.grayscale.dark2};\n          position: absolute;\n          pointer-events: none;\n        }\n        /* Northward tooltips */\n        .d3-tip.n:after {\n          content: '\\\\25BC';\n          margin: -${theme.gridUnit}px 0 0 0;\n          top: 100%;\n          left: 0;\n          text-align: center;\n        }\n        /* Eastward tooltips */\n        .d3-tip.e:after {\n          content: '\\\\25C0';\n          margin: -${theme.gridUnit}px 0 0 0;\n          top: 50%;\n          left: -${theme.gridUnit * 2}px;\n        }\n        /* Southward tooltips */\n        .d3-tip.s:after {\n          content: '\\\\25B2';\n          margin: 0;\n          top: -${theme.gridUnit * 2}px;\n          left: 0;\n          text-align: center;\n        }\n        /* Westward tooltips */\n        .d3-tip.w:after {\n          content: '\\\\25B6';\n          margin: -${theme.gridUnit}px 0 0 0px;\n          top: 50%;\n          left: 100%;\n        }\n      ` }),\n\n(0,_emotion_react__WEBPACK_IMPORTED_MODULE_4__.jsx)(ReactComponent, otherProps));\n\n\n\nCalender.defaultProps = {\n  otherProps: {} };\n\n\nCalender.propTypes = {\n  className: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().string.isRequired),\n  otherProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default().objectOf((prop_types__WEBPACK_IMPORTED_MODULE_1___default().any)) };const _default =\n\n\n(0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_5__.styled)(Calender)`\n  ${({ theme }) => `\n    .superset-legacy-chart-calendar {\n      padding: ${theme.gridUnit * 3}px;\n      position: static !important;\n      overflow: auto !important;\n    }\n\n    .superset-legacy-chart-calendar .ch-tooltip {\n      margin-left: ${theme.gridUnit * 5}px;\n      margin-top: ${theme.gridUnit}px;\n    }\n\n    .superset-legacy-chart-calendar .d3-tip {\n      line-height: 1;\n      padding: ${theme.gridUnit * 3}px;\n      background: ${theme.colors.grayscale.dark2};\n      color: ${theme.colors.grayscale.light5};\n      border-radius: ${theme.borderRadius}px;\n      pointer-events: none;\n      z-index: 1000;\n    }\n\n    .cal-heatmap-container {\n      display: block;\n    }\n\n    .cal-heatmap-container .graph-label {\n      fill: ${theme.colors.grayscale.base};\n      font-size: ${theme.typography.sizes.xs}px;\n    }\n\n    .cal-heatmap-container .graph,\n    .cal-heatmap-container .graph-legend rect {\n      shape-rendering: crispedges;\n    }\n\n    .cal-heatmap-container .graph-rect {\n      fill: ${theme.colors.grayscale.light2};\n    }\n\n    .cal-heatmap-container .graph-subdomain-group rect:hover {\n      stroke: ${theme.colors.grayscale.dark2};\n      stroke-width: 1px;\n    }\n\n    .cal-heatmap-container .subdomain-text {\n      font-size: ${theme.typography.sizes.xs}px;\n      pointer-events: none;\n    }\n\n    .cal-heatmap-container .hover_cursor:hover {\n      cursor: pointer;\n    }\n\n    .cal-heatmap-container .qi {\n      background-color: ${theme.colors.grayscale.base};\n      fill: ${theme.colors.grayscale.base};\n    }\n\n    .cal-heatmap-container .q1 {\n      background-color: ${theme.colors.alert.light2};\n      fill: ${theme.colors.alert.light2};\n    }\n\n    .cal-heatmap-container .q2 {\n      background-color: ${theme.colors.alert.light1};\n      fill: ${theme.colors.alert.light1};\n    }\n\n    .cal-heatmap-container .q3 {\n      background-color: ${theme.colors.success.light1};\n      fill: ${theme.colors.success.light1};\n    }\n\n    .cal-heatmap-container .q4 {\n      background-color: ${theme.colors.success.base};\n      fill: ${theme.colors.success.base};\n    }\n\n    .cal-heatmap-container .q5 {\n      background-color: ${theme.colors.success.dark1};\n      fill: ${theme.colors.success.dark1};\n    }\n\n    .cal-heatmap-container rect.highlight {\n      stroke: ${theme.colors.grayscale.dark1};\n      stroke-width: 1;\n    }\n\n    .cal-heatmap-container text.highlight {\n      fill: ${theme.colors.grayscale.dark1};\n    }\n\n    .cal-heatmap-container rect.highlight-now {\n      stroke: ${theme.colors.error.base};\n    }\n\n    .cal-heatmap-container text.highlight-now {\n      fill: ${theme.colors.error.base};\n      font-weight: ${theme.typography.weights.bold};\n    }\n\n    .cal-heatmap-container .domain-background {\n      fill: none;\n      shape-rendering: crispedges;\n    }\n\n    .ch-tooltip {\n      padding: ${theme.gridUnit * 2}px;\n      background: ${theme.colors.grayscale.dark1};\n      color: ${theme.colors.grayscale.light1};\n      font-size: ${theme.typography.sizes.s}px;\n      line-height: 1.4;\n      width: 140px;\n      position: absolute;\n      z-index: 99999;\n      text-align: center;\n      border-radius: ${theme.borderRadius}px;\n      box-shadow: 2px 2px 2px ${theme.colors.grayscale.dark2};\n      display: none;\n      box-sizing: border-box;\n    }\n\n    .ch-tooltip::after {\n      position: absolute;\n      width: 0;\n      height: 0;\n      border-color: transparent;\n      border-style: solid;\n      content: '';\n      padding: 0;\n      display: block;\n      bottom: -${theme.gridUnit}px;\n      left: 50%;\n      margin-left: -${theme.gridUnit}px;\n      border-width: ${theme.gridUnit}px ${theme.gridUnit}px 0;\n      border-top-color: ${theme.colors.grayscale.dark1};\n    }\n  `}\n`;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ReactComponent, \"ReactComponent\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\ReactCalendar.jsx\");reactHotLoader.register(Calender, \"Calender\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\ReactCalendar.jsx\");reactHotLoader.register(_default, \"default\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\ReactCalendar.jsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvc3JjL1JlYWN0Q2FsZW5kYXIuanN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvc3JjL1JlYWN0Q2FsZW5kYXIuanN4P2M4MTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuICogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuICogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcclxuaW1wb3J0IHsgcmVhY3RpZnksIHN0eWxlZCwgY3NzIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xyXG5pbXBvcnQgeyBHbG9iYWwgfSBmcm9tICdAZW1vdGlvbi9yZWFjdCc7XHJcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnLi9DYWxlbmRhcic7XHJcblxyXG5jb25zdCBSZWFjdENvbXBvbmVudCA9IHJlYWN0aWZ5KENvbXBvbmVudCk7XHJcblxyXG5jb25zdCBDYWxlbmRlciA9ICh7IGNsYXNzTmFtZSwgLi4ub3RoZXJQcm9wcyB9KSA9PiAoXHJcbiAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XHJcbiAgICA8R2xvYmFsXHJcbiAgICAgIHN0eWxlcz17dGhlbWUgPT4gY3NzYFxyXG4gICAgICAgIC5kMy10aXAge1xyXG4gICAgICAgICAgbGluZS1oZWlnaHQ6IDE7XHJcbiAgICAgICAgICBwYWRkaW5nOiAke3RoZW1lLmdyaWRVbml0ICogM31weDtcclxuICAgICAgICAgIGJhY2tncm91bmQ6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMn07XHJcbiAgICAgICAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0NX07XHJcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XHJcbiAgICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgICAgICAgIHotaW5kZXg6IDEwMDA7XHJcbiAgICAgICAgICBmb250LXNpemU6ICR7dGhlbWUudHlwb2dyYXBoeS5zaXplcy5zfXB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBDcmVhdGVzIGEgc21hbGwgdHJpYW5nbGUgZXh0ZW5kZXIgZm9yIHRoZSB0b29sdGlwICovXHJcbiAgICAgICAgLmQzLXRpcDphZnRlciB7XHJcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gICAgICAgICAgZGlzcGxheTogaW5saW5lO1xyXG4gICAgICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMueHN9O1xyXG4gICAgICAgICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgICAgICBsaW5lLWhlaWdodDogMTtcclxuICAgICAgICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazJ9O1xyXG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIE5vcnRod2FyZCB0b29sdGlwcyAqL1xyXG4gICAgICAgIC5kMy10aXAubjphZnRlciB7XHJcbiAgICAgICAgICBjb250ZW50OiAnXFxcXDI1QkMnO1xyXG4gICAgICAgICAgbWFyZ2luOiAtJHt0aGVtZS5ncmlkVW5pdH1weCAwIDAgMDtcclxuICAgICAgICAgIHRvcDogMTAwJTtcclxuICAgICAgICAgIGxlZnQ6IDA7XHJcbiAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIEVhc3R3YXJkIHRvb2x0aXBzICovXHJcbiAgICAgICAgLmQzLXRpcC5lOmFmdGVyIHtcclxuICAgICAgICAgIGNvbnRlbnQ6ICdcXFxcMjVDMCc7XHJcbiAgICAgICAgICBtYXJnaW46IC0ke3RoZW1lLmdyaWRVbml0fXB4IDAgMCAwO1xyXG4gICAgICAgICAgdG9wOiA1MCU7XHJcbiAgICAgICAgICBsZWZ0OiAtJHt0aGVtZS5ncmlkVW5pdCAqIDJ9cHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIFNvdXRod2FyZCB0b29sdGlwcyAqL1xyXG4gICAgICAgIC5kMy10aXAuczphZnRlciB7XHJcbiAgICAgICAgICBjb250ZW50OiAnXFxcXDI1QjInO1xyXG4gICAgICAgICAgbWFyZ2luOiAwO1xyXG4gICAgICAgICAgdG9wOiAtJHt0aGVtZS5ncmlkVW5pdCAqIDJ9cHg7XHJcbiAgICAgICAgICBsZWZ0OiAwO1xyXG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiBXZXN0d2FyZCB0b29sdGlwcyAqL1xyXG4gICAgICAgIC5kMy10aXAudzphZnRlciB7XHJcbiAgICAgICAgICBjb250ZW50OiAnXFxcXDI1QjYnO1xyXG4gICAgICAgICAgbWFyZ2luOiAtJHt0aGVtZS5ncmlkVW5pdH1weCAwIDAgMHB4O1xyXG4gICAgICAgICAgdG9wOiA1MCU7XHJcbiAgICAgICAgICBsZWZ0OiAxMDAlO1xyXG4gICAgICAgIH1cclxuICAgICAgYH1cclxuICAgIC8+XHJcbiAgICA8UmVhY3RDb21wb25lbnQgey4uLm90aGVyUHJvcHN9IC8+XHJcbiAgPC9kaXY+XHJcbik7XHJcblxyXG5DYWxlbmRlci5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgb3RoZXJQcm9wczoge30sXHJcbn07XHJcblxyXG5DYWxlbmRlci5wcm9wVHlwZXMgPSB7XHJcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgb3RoZXJQcm9wczogUHJvcFR5cGVzLm9iamVjdE9mKFByb3BUeXBlcy5hbnkpLFxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc3R5bGVkKENhbGVuZGVyKWBcclxuICAkeyh7IHRoZW1lIH0pID0+IGBcclxuICAgIC5zdXBlcnNldC1sZWdhY3ktY2hhcnQtY2FsZW5kYXIge1xyXG4gICAgICBwYWRkaW5nOiAke3RoZW1lLmdyaWRVbml0ICogM31weDtcclxuICAgICAgcG9zaXRpb246IHN0YXRpYyAhaW1wb3J0YW50O1xyXG4gICAgICBvdmVyZmxvdzogYXV0byAhaW1wb3J0YW50O1xyXG4gICAgfVxyXG5cclxuICAgIC5zdXBlcnNldC1sZWdhY3ktY2hhcnQtY2FsZW5kYXIgLmNoLXRvb2x0aXAge1xyXG4gICAgICBtYXJnaW4tbGVmdDogJHt0aGVtZS5ncmlkVW5pdCAqIDV9cHg7XHJcbiAgICAgIG1hcmdpbi10b3A6ICR7dGhlbWUuZ3JpZFVuaXR9cHg7XHJcbiAgICB9XHJcblxyXG4gICAgLnN1cGVyc2V0LWxlZ2FjeS1jaGFydC1jYWxlbmRhciAuZDMtdGlwIHtcclxuICAgICAgbGluZS1oZWlnaHQ6IDE7XHJcbiAgICAgIHBhZGRpbmc6ICR7dGhlbWUuZ3JpZFVuaXQgKiAzfXB4O1xyXG4gICAgICBiYWNrZ3JvdW5kOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazJ9O1xyXG4gICAgICBjb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmxpZ2h0NX07XHJcbiAgICAgIGJvcmRlci1yYWRpdXM6ICR7dGhlbWUuYm9yZGVyUmFkaXVzfXB4O1xyXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgICAgei1pbmRleDogMTAwMDtcclxuICAgIH1cclxuXHJcbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIHtcclxuICAgICAgZGlzcGxheTogYmxvY2s7XHJcbiAgICB9XHJcblxyXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAuZ3JhcGgtbGFiZWwge1xyXG4gICAgICBmaWxsOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuYmFzZX07XHJcbiAgICAgIGZvbnQtc2l6ZTogJHt0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnhzfXB4O1xyXG4gICAgfVxyXG5cclxuICAgIC5jYWwtaGVhdG1hcC1jb250YWluZXIgLmdyYXBoLFxyXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAuZ3JhcGgtbGVnZW5kIHJlY3Qge1xyXG4gICAgICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwZWRnZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAuZ3JhcGgtcmVjdCB7XHJcbiAgICAgIGZpbGw6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5saWdodDJ9O1xyXG4gICAgfVxyXG5cclxuICAgIC5jYWwtaGVhdG1hcC1jb250YWluZXIgLmdyYXBoLXN1YmRvbWFpbi1ncm91cCByZWN0OmhvdmVyIHtcclxuICAgICAgc3Ryb2tlOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazJ9O1xyXG4gICAgICBzdHJva2Utd2lkdGg6IDFweDtcclxuICAgIH1cclxuXHJcbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIC5zdWJkb21haW4tdGV4dCB7XHJcbiAgICAgIGZvbnQtc2l6ZTogJHt0aGVtZS50eXBvZ3JhcGh5LnNpemVzLnhzfXB4O1xyXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcclxuICAgIH1cclxuXHJcbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIC5ob3Zlcl9jdXJzb3I6aG92ZXIge1xyXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAucWkge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuYmFzZX07XHJcbiAgICAgIGZpbGw6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5iYXNlfTtcclxuICAgIH1cclxuXHJcbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIC5xMSB7XHJcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLmFsZXJ0LmxpZ2h0Mn07XHJcbiAgICAgIGZpbGw6ICR7dGhlbWUuY29sb3JzLmFsZXJ0LmxpZ2h0Mn07XHJcbiAgICB9XHJcblxyXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAucTIge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5hbGVydC5saWdodDF9O1xyXG4gICAgICBmaWxsOiAke3RoZW1lLmNvbG9ycy5hbGVydC5saWdodDF9O1xyXG4gICAgfVxyXG5cclxuICAgIC5jYWwtaGVhdG1hcC1jb250YWluZXIgLnEzIHtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuc3VjY2Vzcy5saWdodDF9O1xyXG4gICAgICBmaWxsOiAke3RoZW1lLmNvbG9ycy5zdWNjZXNzLmxpZ2h0MX07XHJcbiAgICB9XHJcblxyXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciAucTQge1xyXG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5zdWNjZXNzLmJhc2V9O1xyXG4gICAgICBmaWxsOiAke3RoZW1lLmNvbG9ycy5zdWNjZXNzLmJhc2V9O1xyXG4gICAgfVxyXG5cclxuICAgIC5jYWwtaGVhdG1hcC1jb250YWluZXIgLnE1IHtcclxuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuc3VjY2Vzcy5kYXJrMX07XHJcbiAgICAgIGZpbGw6ICR7dGhlbWUuY29sb3JzLnN1Y2Nlc3MuZGFyazF9O1xyXG4gICAgfVxyXG5cclxuICAgIC5jYWwtaGVhdG1hcC1jb250YWluZXIgcmVjdC5oaWdobGlnaHQge1xyXG4gICAgICBzdHJva2U6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMX07XHJcbiAgICAgIHN0cm9rZS13aWR0aDogMTtcclxuICAgIH1cclxuXHJcbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIHRleHQuaGlnaGxpZ2h0IHtcclxuICAgICAgZmlsbDogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsxfTtcclxuICAgIH1cclxuXHJcbiAgICAuY2FsLWhlYXRtYXAtY29udGFpbmVyIHJlY3QuaGlnaGxpZ2h0LW5vdyB7XHJcbiAgICAgIHN0cm9rZTogJHt0aGVtZS5jb2xvcnMuZXJyb3IuYmFzZX07XHJcbiAgICB9XHJcblxyXG4gICAgLmNhbC1oZWF0bWFwLWNvbnRhaW5lciB0ZXh0LmhpZ2hsaWdodC1ub3cge1xyXG4gICAgICBmaWxsOiAke3RoZW1lLmNvbG9ycy5lcnJvci5iYXNlfTtcclxuICAgICAgZm9udC13ZWlnaHQ6ICR7dGhlbWUudHlwb2dyYXBoeS53ZWlnaHRzLmJvbGR9O1xyXG4gICAgfVxyXG5cclxuICAgIC5jYWwtaGVhdG1hcC1jb250YWluZXIgLmRvbWFpbi1iYWNrZ3JvdW5kIHtcclxuICAgICAgZmlsbDogbm9uZTtcclxuICAgICAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcGVkZ2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC5jaC10b29sdGlwIHtcclxuICAgICAgcGFkZGluZzogJHt0aGVtZS5ncmlkVW5pdCAqIDJ9cHg7XHJcbiAgICAgIGJhY2tncm91bmQ6ICR7dGhlbWUuY29sb3JzLmdyYXlzY2FsZS5kYXJrMX07XHJcbiAgICAgIGNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQxfTtcclxuICAgICAgZm9udC1zaXplOiAke3RoZW1lLnR5cG9ncmFwaHkuc2l6ZXMuc31weDtcclxuICAgICAgbGluZS1oZWlnaHQ6IDEuNDtcclxuICAgICAgd2lkdGg6IDE0MHB4O1xyXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgICAgIHotaW5kZXg6IDk5OTk5O1xyXG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbiAgICAgIGJvcmRlci1yYWRpdXM6ICR7dGhlbWUuYm9yZGVyUmFkaXVzfXB4O1xyXG4gICAgICBib3gtc2hhZG93OiAycHggMnB4IDJweCAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazJ9O1xyXG4gICAgICBkaXNwbGF5OiBub25lO1xyXG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xyXG4gICAgfVxyXG5cclxuICAgIC5jaC10b29sdGlwOjphZnRlciB7XHJcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICAgICAgd2lkdGg6IDA7XHJcbiAgICAgIGhlaWdodDogMDtcclxuICAgICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDtcclxuICAgICAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcclxuICAgICAgY29udGVudDogJyc7XHJcbiAgICAgIHBhZGRpbmc6IDA7XHJcbiAgICAgIGRpc3BsYXk6IGJsb2NrO1xyXG4gICAgICBib3R0b206IC0ke3RoZW1lLmdyaWRVbml0fXB4O1xyXG4gICAgICBsZWZ0OiA1MCU7XHJcbiAgICAgIG1hcmdpbi1sZWZ0OiAtJHt0aGVtZS5ncmlkVW5pdH1weDtcclxuICAgICAgYm9yZGVyLXdpZHRoOiAke3RoZW1lLmdyaWRVbml0fXB4ICR7dGhlbWUuZ3JpZFVuaXR9cHggMDtcclxuICAgICAgYm9yZGVyLXRvcC1jb2xvcjogJHt0aGVtZS5jb2xvcnMuZ3JheXNjYWxlLmRhcmsxfTtcclxuICAgIH1cclxuICBgfVxyXG5gO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/src/ReactCalendar.jsx\n");

/***/ }),

/***/ "./plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js":
/*!************************************************************************!*\
  !*** ./plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js ***!
  \************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var d3_tip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-tip */ \"./node_modules/d3-tip/index.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/color/utils.ts\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; // [LICENSE TBD]\n/* Copied and altered from http://cal-heatmap.com/ , alterations around:\r\n * - tuning tooltips\r\n * - supporting multi-colors scales\r\n * - legend format\r\n * - UTC handling\r\n */\n\n/* eslint-disable */\n\n\n\n\nvar d3 =  true ? __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\") : 0;\n\nvar d3 =  true ? __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\") : 0;\n\nvar CalHeatMap = function () {\n  'use strict';\n\n  var self = this;\n  self.tip = (0,d3_tip__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().\n  attr('class', 'd3-tip').\n  direction('n').\n  offset([-5, 0]).\n  html(\n  (d) => `\n      ${self.options.timeFormatter(d.t)}: <strong>${self.options.valueFormatter(\n  d.v)\n  }</strong>\n    `);\n\n  self.legendTip = (0,d3_tip__WEBPACK_IMPORTED_MODULE_0__[\"default\"])().\n  attr('class', 'd3-tip').\n  direction('n').\n  offset([-5, 0]).\n  html((d) => self.options.valueFormatter(d));\n\n  this.allowedDataType = ['json', 'csv', 'tsv', 'txt'];\n\n  // Default settings\n  this.options = {\n    // selector string of the container to append the graph to\n    // Accept any string value accepted by document.querySelector or CSS3\n    // or an Element object\n    itemSelector: '#cal-heatmap',\n\n    // Whether to paint the calendar on init()\n    // Used by testsuite to reduce testing time\n    paintOnLoad: true,\n\n    // ================================================\n    // DOMAIN\n    // ================================================\n\n    // Number of domain to display on the graph\n    range: 12,\n\n    // Size of each cell, in pixel\n    cellSize: 10,\n\n    // Padding between each cell, in pixel\n    cellPadding: 2,\n\n    // For rounded subdomain rectangles, in pixels\n    cellRadius: 0,\n\n    domainGutter: 2,\n\n    domainMargin: [0, 0, 0, 0],\n\n    valueFormatter: (d) => d,\n\n    timeFormatter: (d) => d,\n\n    domain: 'hour',\n\n    subDomain: 'min',\n\n    // Number of columns to split the subDomains to\n    // If not null, will takes precedence over rowLimit\n    colLimit: null,\n\n    // Number of rows to split the subDomains to\n    // Will be ignored if colLimit is not null\n    rowLimit: null,\n\n    // First day of the week is Monday\n    // 0 to start the week on Sunday\n    weekStartOnMonday: true,\n\n    // Start date of the graph\n    // @default now\n    start: new Date(),\n\n    minDate: null,\n\n    maxDate: null,\n\n    // ================================================\n    // DATA\n    // ================================================\n\n    // Data source\n    // URL, where to fetch the original datas\n    data: '',\n\n    // Data type\n    // Default: json\n    dataType: this.allowedDataType[0],\n\n    // Payload sent when using POST http method\n    // Leave to null (default) for GET request\n    // Expect a string, formatted like \"a=b;c=d\"\n    dataPostPayload: null,\n\n    // Additional headers sent when requesting data\n    // Expect an object formatted like:\n    // { 'X-CSRF-TOKEN': 'token' }\n    dataRequestHeaders: null,\n\n    // Whether to consider missing date:value from the datasource\n    // as equal to 0, or just leave them as missing\n    considerMissingDataAsZero: false,\n\n    // Load remote data on calendar creation\n    // When false, the calendar will be left empty\n    loadOnInit: true,\n\n    // Calendar orientation\n    // false: display domains side by side\n    // true : display domains one under the other\n    verticalOrientation: false,\n\n    // Domain dynamic width/height\n    // The width on a domain depends on the number of\n    domainDynamicDimension: true,\n\n    // Domain Label properties\n    label: {\n      // valid: top, right, bottom, left\n      position: 'bottom',\n\n      // Valid: left, center, right\n      // Also valid are the direct svg values: start, middle, end\n      align: 'center',\n\n      // By default, there is no margin/padding around the label\n      offset: {\n        x: 0,\n        y: 0 },\n\n\n      rotate: null,\n\n      // Used only on vertical orientation\n      width: 100,\n\n      // Used only on horizontal orientation\n      height: null },\n\n\n    // ================================================\n    // LEGEND\n    // ================================================\n\n    // Threshold for the legend\n    legend: [10, 20, 30, 40],\n\n    // Whether to display the legend\n    displayLegend: true,\n\n    legendCellSize: 10,\n\n    legendCellPadding: 2,\n\n    legendMargin: [0, 0, 0, 0],\n\n    // Legend vertical position\n    // top: place legend above calendar\n    // bottom: place legend below the calendar\n    legendVerticalPosition: 'bottom',\n\n    // Legend horizontal position\n    // accepted values: left, center, right\n    legendHorizontalPosition: 'left',\n\n    // Legend rotation\n    // accepted values: horizontal, vertical\n    legendOrientation: 'horizontal',\n\n    // Objects holding all the heatmap different colors\n    // null to disable, and use the default css styles\n    //\n    // Examples:\n    // legendColors: {\n    //    min: \"green\",\n    //    max: \"red\",\n    //    empty: \"#ffffff\",\n    //    base: \"grey\",\n    //    overflow: \"red\",\n    //    colorScaler: null,\n    // }\n    legendColors: null,\n\n    // ================================================\n    // HIGHLIGHT\n    // ================================================\n\n    // List of dates to highlight\n    // Valid values:\n    // - []: don't highlight anything\n    // - \"now\": highlight the current date\n    // - an array of Date objects: highlight the specified dates\n    highlight: [],\n\n    // ================================================\n    // TEXT FORMATTING / i18n\n    // ================================================\n\n    // Name of the items to represent in the calendar\n    itemName: ['item', 'items'],\n\n    // Formatting of the domain label\n    // @default: null, will use the formatting according to domain type\n    // Accept a string used as specifier by d3.time.format()\n    // or a function\n    //\n    // Refer to https://github.com/mbostock/d3/wiki/Time-Formatting\n    // for accepted date formatting used by d3.time.format()\n    domainLabelFormat: null,\n\n    // Formatting of the title displayed when hovering a subDomain cell\n    subDomainTitleFormat: {\n      empty: '{date}',\n      filled: '{count} {name} {connector} {date}' },\n\n\n    // Formatting of the {date} used in subDomainTitleFormat\n    // @default: null, will use the formatting according to subDomain type\n    // Accept a string used as specifier by d3.time.format()\n    // or a function\n    //\n    // Refer to https://github.com/mbostock/d3/wiki/Time-Formatting\n    // for accepted date formatting used by d3.time.format()\n    subDomainDateFormat: null,\n\n    // Formatting of the text inside each subDomain cell\n    // @default: null, no text\n    // Accept a string used as specifier by d3.time.format()\n    // or a function\n    //\n    // Refer to https://github.com/mbostock/d3/wiki/Time-Formatting\n    // for accepted date formatting used by d3.time.format()\n    subDomainTextFormat: null,\n\n    // Formatting of the title displayed when hovering a legend cell\n    legendTitleFormat: {\n      lower: 'less than {min} {name}',\n      inner: 'between {down} and {up} {name}',\n      upper: 'more than {max} {name}' },\n\n\n    // Animation duration, in ms\n    animationDuration: 500,\n\n    nextSelector: false,\n\n    previousSelector: false,\n\n    itemNamespace: 'cal-heatmap',\n\n    tooltip: false,\n\n    // ================================================\n    // EVENTS CALLBACK\n    // ================================================\n\n    // Callback when clicking on a time block\n    onClick: null,\n\n    // Callback after painting the empty calendar\n    // Can be used to trigger an API call, once the calendar is ready to be filled\n    afterLoad: null,\n\n    // Callback after loading the next domain in the calendar\n    afterLoadNextDomain: null,\n\n    // Callback after loading the previous domain in the calendar\n    afterLoadPreviousDomain: null,\n\n    // Callback after finishing all actions on the calendar\n    onComplete: null,\n\n    // Callback after fetching the datas, but before applying them to the calendar\n    // Used mainly to convert the datas if they're not formatted like expected\n    // Takes the fetched \"data\" object as argument, must return a json object\n    // formatted like {timestamp:count, timestamp2:count2},\n    afterLoadData: function (data) {\n      return data;\n    },\n\n    // Callback triggered after calling and completing update().\n    afterUpdate: null,\n\n    // Callback triggered after calling next().\n    // The `status` argument is equal to true if there is no\n    // more next domain to load\n    //\n    // This callback is also executed once, after calling previous(),\n    // only when the max domain is reached\n    onMaxDomainReached: null,\n\n    // Callback triggered after calling previous().\n    // The `status` argument is equal to true if there is no\n    // more previous domain to load\n    //\n    // This callback is also executed once, after calling next(),\n    // only when the min domain is reached\n    onMinDomainReached: null };\n\n\n  this._domainType = {\n    min: {\n      name: 'minute',\n      level: 10,\n      maxItemNumber: 60,\n      defaultRowNumber: 10,\n      defaultColumnNumber: 6,\n      row: function (d) {\n        return self.getSubDomainRowNumber(d);\n      },\n      column: function (d) {\n        return self.getSubDomainColumnNumber(d);\n      },\n      position: {\n        x: function (d) {\n          return Math.floor(d.getMinutes() / self._domainType.min.row(d));\n        },\n        y: function (d) {\n          return d.getMinutes() % self._domainType.min.row(d);\n        } },\n\n      format: {\n        date: '%H:%M, %A %B %-e, %Y',\n        legend: '',\n        connector: 'at' },\n\n      extractUnit: function (d) {\n        return new Date(\n        d.getFullYear(),\n        d.getMonth(),\n        d.getDate(),\n        d.getHours(),\n        d.getMinutes()).\n        getTime();\n      } },\n\n    hour: {\n      name: 'hour',\n      level: 20,\n      maxItemNumber: function (d) {\n        switch (self.options.domain) {\n          case 'day':\n            return 24;\n          case 'week':\n            return 24 * 7;\n          case 'month':\n            return (\n              24 * (\n              self.options.domainDynamicDimension ?\n              self.getDayCountInMonth(d) :\n              31));}\n\n\n      },\n      defaultRowNumber: 6,\n      defaultColumnNumber: function (d) {\n        switch (self.options.domain) {\n          case 'day':\n            return 4;\n          case 'week':\n            return 28;\n          case 'month':\n            return self.options.domainDynamicDimension ?\n            self.getDayCountInMonth(d) :\n            31;}\n\n      },\n      row: function (d) {\n        return self.getSubDomainRowNumber(d);\n      },\n      column: function (d) {\n        return self.getSubDomainColumnNumber(d);\n      },\n      position: {\n        x: function (d) {\n          if (self.options.domain === 'month') {\n            if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n              return Math.floor(\n              (d.getHours() + (d.getDate() - 1) * 24) /\n              self._domainType.hour.row(d));\n\n            }\n            return (\n              Math.floor(d.getHours() / self._domainType.hour.row(d)) +\n              (d.getDate() - 1) * 4);\n\n          } else if (self.options.domain === 'week') {\n            if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n              return Math.floor(\n              (d.getHours() + self.getWeekDay(d) * 24) /\n              self._domainType.hour.row(d));\n\n            }\n            return (\n              Math.floor(d.getHours() / self._domainType.hour.row(d)) +\n              self.getWeekDay(d) * 4);\n\n          }\n          return Math.floor(d.getHours() / self._domainType.hour.row(d));\n        },\n        y: function (d) {\n          var p = d.getHours();\n          if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n            switch (self.options.domain) {\n              case 'month':\n                p += (d.getDate() - 1) * 24;\n                break;\n              case 'week':\n                p += self.getWeekDay(d) * 24;\n                break;}\n\n          }\n          return Math.floor(p % self._domainType.hour.row(d));\n        } },\n\n      format: {\n        date: '%Hh, %A %B %-e, %Y',\n        legend: '%H:00',\n        connector: 'at' },\n\n      extractUnit: function (d) {\n        return new Date(\n        d.getFullYear(),\n        d.getMonth(),\n        d.getDate(),\n        d.getHours()).\n        getTime();\n      } },\n\n    day: {\n      name: 'day',\n      level: 30,\n      maxItemNumber: function (d) {\n        switch (self.options.domain) {\n          case 'week':\n            return 7;\n          case 'month':\n            return self.options.domainDynamicDimension ?\n            self.getDayCountInMonth(d) :\n            31;\n          case 'year':\n            return self.options.domainDynamicDimension ?\n            self.getDayCountInYear(d) :\n            366;}\n\n      },\n      defaultColumnNumber: function (d) {\n        d = new Date(d);\n        switch (self.options.domain) {\n          case 'week':\n            return 1;\n          case 'month':\n            return self.options.domainDynamicDimension &&\n            !self.options.verticalOrientation ?\n            self.getWeekNumber(\n            new Date(d.getFullYear(), d.getMonth() + 1, 0)) -\n\n            self.getWeekNumber(d) +\n            1 :\n            6;\n          case 'year':\n            return self.options.domainDynamicDimension ?\n            self.getWeekNumber(new Date(d.getFullYear(), 11, 31)) -\n            self.getWeekNumber(new Date(d.getFullYear(), 0)) +\n            1 :\n            54;}\n\n      },\n      defaultRowNumber: 7,\n      row: function (d) {\n        return self.getSubDomainRowNumber(d);\n      },\n      column: function (d) {\n        return self.getSubDomainColumnNumber(d);\n      },\n      position: {\n        x: function (d) {\n          switch (self.options.domain) {\n            case 'week':\n              return Math.floor(\n              self.getWeekDay(d) / self._domainType.day.row(d));\n\n            case 'month':\n              if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n                return Math.floor(\n                (d.getDate() - 1) / self._domainType.day.row(d));\n\n              }\n              return (\n                self.getWeekNumber(d) -\n                self.getWeekNumber(new Date(d.getFullYear(), d.getMonth())));\n\n            case 'year':\n              if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n                return Math.floor(\n                (self.getDayOfYear(d) - 1) / self._domainType.day.row(d));\n\n              }\n              return self.getWeekNumber(d);}\n\n        },\n        y: function (d) {\n          var p = self.getWeekDay(d);\n          if (self.options.colLimit > 0 || self.options.rowLimit > 0) {\n            switch (self.options.domain) {\n              case 'year':\n                p = self.getDayOfYear(d) - 1;\n                break;\n              case 'week':\n                p = self.getWeekDay(d);\n                break;\n              case 'month':\n                p = d.getDate() - 1;\n                break;}\n\n          }\n          return Math.floor(p % self._domainType.day.row(d));\n        } },\n\n      format: {\n        date: '%A %B %-e, %Y',\n        legend: '%e %b',\n        connector: 'on' },\n\n      extractUnit: function (d) {\n        return new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();\n      } },\n\n    week: {\n      name: 'week',\n      level: 40,\n      maxItemNumber: 54,\n      defaultColumnNumber: function (d) {\n        d = new Date(d);\n        switch (self.options.domain) {\n          case 'year':\n            return self._domainType.week.maxItemNumber;\n          case 'month':\n            return self.options.domainDynamicDimension ?\n            self.getWeekNumber(\n            new Date(d.getFullYear(), d.getMonth() + 1, 0)) -\n            self.getWeekNumber(d) :\n            5;}\n\n      },\n      defaultRowNumber: 1,\n      row: function (d) {\n        return self.getSubDomainRowNumber(d);\n      },\n      column: function (d) {\n        return self.getSubDomainColumnNumber(d);\n      },\n      position: {\n        x: function (d) {\n          switch (self.options.domain) {\n            case 'year':\n              return Math.floor(\n              self.getWeekNumber(d) / self._domainType.week.row(d));\n\n            case 'month':\n              return Math.floor(\n              self.getMonthWeekNumber(d) / self._domainType.week.row(d));}\n\n\n        },\n        y: function (d) {\n          return self.getWeekNumber(d) % self._domainType.week.row(d);\n        } },\n\n      format: {\n        date: '%B Week #%W',\n        legend: '%B Week #%W',\n        connector: 'in' },\n\n      extractUnit: function (d) {\n        var dt = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n        // According to ISO-8601, week number computation are based on week starting on Monday\n        var weekDay = dt.getDay() - (self.options.weekStartOnMonday ? 1 : 0);\n        if (weekDay < 0) {\n          weekDay = 6;\n        }\n        dt.setDate(dt.getDate() - weekDay);\n        return dt.getTime();\n      } },\n\n    month: {\n      name: 'month',\n      level: 50,\n      maxItemNumber: 12,\n      defaultColumnNumber: 12,\n      defaultRowNumber: 1,\n      row: function () {\n        return self.getSubDomainRowNumber();\n      },\n      column: function () {\n        return self.getSubDomainColumnNumber();\n      },\n      position: {\n        x: function (d) {\n          return Math.floor(d.getMonth() / self._domainType.month.row(d));\n        },\n        y: function (d) {\n          return d.getMonth() % self._domainType.month.row(d);\n        } },\n\n      format: {\n        date: '%B %Y',\n        legend: '%B',\n        connector: 'in' },\n\n      extractUnit: function (d) {\n        return new Date(d.getFullYear(), d.getMonth()).getTime();\n      } },\n\n    year: {\n      name: 'year',\n      level: 60,\n      row: function () {\n        return self.options.rowLimit || 1;\n      },\n      column: function () {\n        return self.options.colLimit || 1;\n      },\n      position: {\n        x: function () {\n          return 1;\n        },\n        y: function () {\n          return 1;\n        } },\n\n      format: {\n        date: '%Y',\n        legend: '%Y',\n        connector: 'in' },\n\n      extractUnit: function (d) {\n        return new Date(d.getFullYear()).getTime();\n      } } };\n\n\n\n  for (var type in this._domainType) {\n    if (this._domainType.hasOwnProperty(type)) {\n      var d = this._domainType[type];\n      this._domainType['x_' + type] = {\n        name: 'x_' + type,\n        level: d.type,\n        maxItemNumber: d.maxItemNumber,\n        defaultRowNumber: d.defaultRowNumber,\n        defaultColumnNumber: d.defaultColumnNumber,\n        row: d.column,\n        column: d.row,\n        position: {\n          x: d.position.y,\n          y: d.position.x },\n\n        format: d.format,\n        extractUnit: d.extractUnit };\n\n    }\n  }\n\n  // Record the address of the last inserted domain when browsing\n  this.lastInsertedSvg = null;\n\n  this._completed = false;\n\n  // Record all the valid domains\n  // Each domain value is a timestamp in milliseconds\n  this._domains = d3.map();\n\n  this.graphDim = {\n    width: 0,\n    height: 0 };\n\n\n  this.legendDim = {\n    width: 0,\n    height: 0 };\n\n\n  this.NAVIGATE_LEFT = 1;\n  this.NAVIGATE_RIGHT = 2;\n\n  // Various update mode when using the update() API\n  this.RESET_ALL_ON_UPDATE = 0;\n  this.RESET_SINGLE_ON_UPDATE = 1;\n  this.APPEND_ON_UPDATE = 2;\n\n  this.DEFAULT_LEGEND_MARGIN = 10;\n\n  this.root = null;\n  this.tooltip = null;\n\n  this._maxDomainReached = false;\n  this._minDomainReached = false;\n\n  this.domainPosition = new DomainPosition();\n  this.Legend = null;\n  this.legendScale = null;\n\n  // List of domains that are skipped because of DST\n  // All times belonging to these domains should be re-assigned to the previous domain\n  this.DSTDomain = [];\n\n  /**\r\n   * Display the graph for the first time\r\n   * @return bool True if the calendar is created\r\n   */\n  this._init = function () {\n    self.\n    getDomain(self.options.start).\n    map(function (d) {\n      return d.getTime();\n    }).\n    map(function (d) {\n      self._domains.set(\n      d,\n      self.getSubDomain(d).map(function (d) {\n        return {\n          t: self._domainType[self.options.subDomain].extractUnit(d),\n          v: null };\n\n      }));\n\n    });\n\n    self.root = d3.\n    select(self.options.itemSelector).\n    append('svg').\n    attr('class', 'cal-heatmap-container');\n\n    self.root.attr('x', 0).attr('y', 0).append('svg').attr('class', 'graph');\n\n    self.Legend = new Legend(self);\n\n    if (self.options.paintOnLoad) {\n      _initCalendar();\n    }\n    self.root.call(self.tip);\n    self.root.call(self.legendTip);\n\n    return true;\n  };\n\n  function _initCalendar() {\n    self.verticalDomainLabel =\n    self.options.label.position === 'top' ||\n    self.options.label.position === 'bottom';\n\n    self.domainVerticalLabelHeight =\n    self.options.label.height === null ?\n    Math.max(25, self.options.cellSize * 2) :\n    self.options.label.height;\n    self.domainHorizontalLabelWidth = 0;\n\n    if (\n    self.options.domainLabelFormat === '' &&\n    self.options.label.height === null)\n    {\n      self.domainVerticalLabelHeight = 0;\n    }\n\n    if (!self.verticalDomainLabel) {\n      self.domainVerticalLabelHeight = 0;\n      self.domainHorizontalLabelWidth = self.options.label.width;\n    }\n\n    self.paint();\n\n    // =========================================================================//\n    // ATTACHING DOMAIN NAVIGATION EVENT                    //\n    // =========================================================================//\n    if (self.options.nextSelector !== false) {\n      d3.select(self.options.nextSelector).on(\n      'click.' + self.options.itemNamespace,\n      function () {\n        d3.event.preventDefault();\n        return self.loadNextDomain(1);\n      });\n\n    }\n\n    if (self.options.previousSelector !== false) {\n      d3.select(self.options.previousSelector).on(\n      'click.' + self.options.itemNamespace,\n      function () {\n        d3.event.preventDefault();\n        return self.loadPreviousDomain(1);\n      });\n\n    }\n\n    self.Legend.redraw(\n    self.graphDim.width -\n    self.options.domainGutter -\n    self.options.cellPadding);\n\n    self.afterLoad();\n\n    var domains = self.getDomainKeys();\n\n    // Fill the graph with some datas\n    if (self.options.loadOnInit) {\n      self.getDatas(\n      self.options.data,\n      new Date(domains[0]),\n      self.getSubDomain(domains[domains.length - 1]).pop(),\n      function () {\n        self.fill();\n        self.onComplete();\n      });\n\n    } else {\n      self.onComplete();\n    }\n\n    self.checkIfMinDomainIsReached(domains[0]);\n    self.checkIfMaxDomainIsReached(self.getNextDomain().getTime());\n  }\n\n  // Return the width of the domain block, without the domain gutter\n  // @param int d Domain start timestamp\n  function w(d, outer) {\n    var width =\n    self.options.cellSize *\n    self._domainType[self.options.subDomain].column(d) +\n    self.options.cellPadding *\n    self._domainType[self.options.subDomain].column(d);\n    if (arguments.length === 2 && outer === true) {\n      return width +=\n      self.domainHorizontalLabelWidth +\n      self.options.domainGutter +\n      self.options.domainMargin[1] +\n      self.options.domainMargin[3];\n    }\n    return width;\n  }\n\n  // Return the height of the domain block, without the domain gutter\n  function h(d, outer) {\n    var height =\n    self.options.cellSize * self._domainType[self.options.subDomain].row(d) +\n    self.options.cellPadding *\n    self._domainType[self.options.subDomain].row(d);\n    if (arguments.length === 2 && outer === true) {\n      height +=\n      self.options.domainGutter +\n      self.domainVerticalLabelHeight +\n      self.options.domainMargin[0] +\n      self.options.domainMargin[2];\n    }\n    return height;\n  }\n\n  /**\r\n   *\r\n   *\r\n   * @param int navigationDir\r\n   */\n  this.paint = function (navigationDir) {\n    var options = self.options;\n\n    if (arguments.length === 0) {\n      navigationDir = false;\n    }\n\n    // Painting all the domains\n    var domainSvg = self.root.\n    select('.graph').\n    selectAll('.graph-domain').\n    data(\n    function () {\n      var data = self.getDomainKeys();\n      return navigationDir === self.NAVIGATE_LEFT ? data.reverse() : data;\n    },\n    function (d) {\n      return d;\n    });\n\n    var enteringDomainDim = 0;\n    var exitingDomainDim = 0;\n\n    // =========================================================================//\n    // PAINTING DOMAIN                              //\n    // =========================================================================//\n\n    var svg = domainSvg.\n    enter().\n    append('svg').\n    attr('width', function (d) {\n      return w(d, true);\n    }).\n    attr('height', function (d) {\n      return h(d, true);\n    }).\n    attr('x', function (d) {\n      if (options.verticalOrientation) {\n        self.graphDim.width = Math.max(self.graphDim.width, w(d, true));\n        return 0;\n      } else {\n        return getDomainPosition(d, self.graphDim, 'width', w(d, true));\n      }\n    }).\n    attr('y', function (d) {\n      if (options.verticalOrientation) {\n        return getDomainPosition(d, self.graphDim, 'height', h(d, true));\n      } else {\n        self.graphDim.height = Math.max(self.graphDim.height, h(d, true));\n        return 0;\n      }\n    }).\n    attr('class', function (d) {\n      var classname = 'graph-domain';\n      var date = new Date(d);\n      switch (options.domain) {\n        case 'hour':\n          classname += ' h_' + date.getHours();\n        /* falls through */\n        case 'day':\n          classname += ' d_' + date.getDate() + ' dy_' + date.getDay();\n        /* falls through */\n        case 'week':\n          classname += ' w_' + self.getWeekNumber(date);\n        /* falls through */\n        case 'month':\n          classname += ' m_' + (date.getMonth() + 1);\n        /* falls through */\n        case 'year':\n          classname += ' y_' + date.getFullYear();}\n\n      return classname;\n    });\n    self.lastInsertedSvg = svg;\n\n    function getDomainPosition(domainIndex, graphDim, axis, domainDim) {\n      var tmp = 0;\n      switch (navigationDir) {\n        case false:\n          tmp = graphDim[axis];\n\n          graphDim[axis] += domainDim;\n          self.domainPosition.setPosition(domainIndex, tmp);\n          return tmp;\n\n        case self.NAVIGATE_RIGHT:\n          self.domainPosition.setPosition(domainIndex, graphDim[axis]);\n\n          enteringDomainDim = domainDim;\n          exitingDomainDim = self.domainPosition.getPositionFromIndex(1);\n\n          self.domainPosition.shiftRightBy(exitingDomainDim);\n          return graphDim[axis];\n\n        case self.NAVIGATE_LEFT:\n          tmp = -domainDim;\n\n          enteringDomainDim = -tmp;\n          exitingDomainDim = graphDim[axis] - self.domainPosition.getLast();\n\n          self.domainPosition.setPosition(domainIndex, tmp);\n          self.domainPosition.shiftLeftBy(enteringDomainDim);\n          return tmp;}\n\n    }\n\n    svg.\n    append('rect').\n    attr('width', function (d) {\n      return w(d, true) - options.domainGutter - options.cellPadding;\n    }).\n    attr('height', function (d) {\n      return h(d, true) - options.domainGutter - options.cellPadding;\n    }).\n    attr('class', 'domain-background');\n\n    // =========================================================================//\n    // PAINTING SUBDOMAINS                            //\n    // =========================================================================//\n    var subDomainSvgGroup = svg.\n    append('svg').\n    attr('x', function () {\n      if (options.label.position === 'left') {\n        return self.domainHorizontalLabelWidth + options.domainMargin[3];\n      } else {\n        return options.domainMargin[3];\n      }\n    }).\n    attr('y', function () {\n      if (options.label.position === 'top') {\n        return self.domainVerticalLabelHeight + options.domainMargin[0];\n      } else {\n        return options.domainMargin[0];\n      }\n    }).\n    attr('class', 'graph-subdomain-group');\n    var rect = subDomainSvgGroup.\n    selectAll('g').\n    data(function (d) {\n      return self._domains.get(d);\n    }).\n    enter().\n    append('g');\n    rect.\n    append('rect').\n    attr('class', function (d) {\n      return (\n        'graph-rect' +\n        self.getHighlightClassName(d.t) + (\n        options.onClick !== null ? ' hover_cursor' : ''));\n\n    }).\n    attr('width', options.cellSize).\n    attr('height', options.cellSize).\n    attr('x', function (d) {\n      return self.positionSubDomainX(d.t);\n    }).\n    attr('y', function (d) {\n      return self.positionSubDomainY(d.t);\n    }).\n    on('click', function (d) {\n      if (options.onClick !== null) {\n        return self.onClick(new Date(d.t), d.v);\n      }\n    }).\n    call(function (selection) {\n      if (options.cellRadius > 0) {\n        selection.\n        attr('rx', options.cellRadius).\n        attr('ry', options.cellRadius);\n      }\n\n      if (\n      self.legendScale !== null &&\n      options.legendColors !== null &&\n      options.legendColors.hasOwnProperty('base'))\n      {\n        selection.attr('fill', options.legendColors.base);\n      }\n\n      if (options.tooltip) {\n        selection.\n        on('mouseover', function (d) {\n          self.tip.show(d, this);\n        }).\n        on('mouseout', function () {\n          self.tip.hide(d);\n        });\n      }\n    });\n\n    // Appending a title to each subdomain\n    if (!options.tooltip) {\n      rect.append('title').text(function (d) {\n        return self.formatDate(new Date(d.t), options.subDomainDateFormat);\n      });\n    }\n\n    // =========================================================================//\n    // PAINTING LABEL                              //\n    // =========================================================================//\n    if (options.domainLabelFormat !== '') {\n      svg.\n      append('text').\n      attr('class', 'graph-label').\n      attr('y', function (d) {\n        var y = options.domainMargin[0];\n        switch (options.label.position) {\n          case 'top':\n            y += self.domainVerticalLabelHeight / 2;\n            break;\n          case 'bottom':\n            y += h(d) + self.domainVerticalLabelHeight / 2;}\n\n\n        return (\n          y +\n          options.label.offset.y * (\n          options.label.rotate === 'right' &&\n          options.label.position === 'right' ||\n          options.label.rotate === 'left' &&\n          options.label.position === 'left' ?\n          -1 :\n          1));\n\n      }).\n      attr('x', function (d) {\n        var x = options.domainMargin[3];\n        switch (options.label.position) {\n          case 'right':\n            x += w(d);\n            break;\n          case 'bottom':\n          case 'top':\n            x += w(d) / 2;}\n\n\n        if (options.label.align === 'right') {\n          return (\n            x +\n            self.domainHorizontalLabelWidth -\n            options.label.offset.x * (\n            options.label.rotate === 'right' ? -1 : 1));\n\n        }\n        return x + options.label.offset.x;\n      }).\n      attr('text-anchor', function () {\n        switch (options.label.align) {\n          case 'start':\n          case 'left':\n            return 'start';\n          case 'end':\n          case 'right':\n            return 'end';\n          default:\n            return 'middle';}\n\n      }).\n      attr('dominant-baseline', function () {\n        return self.verticalDomainLabel ? 'middle' : 'top';\n      }).\n      text(function (d) {\n        return self.formatDate(new Date(d), options.domainLabelFormat);\n      }).\n      call(domainRotate);\n    }\n\n    function domainRotate(selection) {\n      switch (options.label.rotate) {\n        case 'right':\n          selection.attr('transform', function (d) {\n            var s = 'rotate(90), ';\n            switch (options.label.position) {\n              case 'right':\n                s += 'translate(-' + w(d) + ' , -' + w(d) + ')';\n                break;\n              case 'left':\n                s += 'translate(0, -' + self.domainHorizontalLabelWidth + ')';\n                break;}\n\n\n            return s;\n          });\n          break;\n        case 'left':\n          selection.attr('transform', function (d) {\n            var s = 'rotate(270), ';\n            switch (options.label.position) {\n              case 'right':\n                s +=\n                'translate(-' + (\n                w(d) + self.domainHorizontalLabelWidth) +\n                ' , ' +\n                w(d) +\n                ')';\n                break;\n              case 'left':\n                s +=\n                'translate(-' +\n                self.domainHorizontalLabelWidth +\n                ' , ' +\n                self.domainHorizontalLabelWidth +\n                ')';\n                break;}\n\n\n            return s;\n          });\n          break;}\n\n    }\n\n    // =========================================================================//\n    // PAINTING DOMAIN SUBDOMAIN CONTENT                    //\n    // =========================================================================//\n    if (options.subDomainTextFormat !== null) {\n      rect.\n      append('text').\n      attr('class', function (d) {\n        return 'subdomain-text' + self.getHighlightClassName(d.t);\n      }).\n      attr('x', function (d) {\n        return self.positionSubDomainX(d.t) + options.cellSize / 2;\n      }).\n      attr('y', function (d) {\n        return self.positionSubDomainY(d.t) + options.cellSize / 2;\n      }).\n      attr('text-anchor', 'middle').\n      attr('dominant-baseline', 'central').\n      text(function (d) {\n        return self.formatDate(new Date(d.t), options.subDomainTextFormat);\n      });\n    }\n\n    // =========================================================================//\n    // ANIMATION                                //\n    // =========================================================================//\n\n    if (navigationDir !== false) {\n      domainSvg.\n      transition().\n      duration(options.animationDuration).\n      attr('x', function (d) {\n        return options.verticalOrientation ?\n        0 :\n        self.domainPosition.getPosition(d);\n      }).\n      attr('y', function (d) {\n        return options.verticalOrientation ?\n        self.domainPosition.getPosition(d) :\n        0;\n      });\n    }\n\n    var tempWidth = self.graphDim.width;\n    var tempHeight = self.graphDim.height;\n\n    if (options.verticalOrientation) {\n      self.graphDim.height += enteringDomainDim - exitingDomainDim;\n    } else {\n      self.graphDim.width += enteringDomainDim - exitingDomainDim;\n    }\n\n    // At the time of exit, domainsWidth and domainsHeight already automatically shifted\n    domainSvg.\n    exit().\n    transition().\n    duration(options.animationDuration).\n    attr('x', function (d) {\n      if (options.verticalOrientation) {\n        return 0;\n      } else {\n        switch (navigationDir) {\n          case self.NAVIGATE_LEFT:\n            return Math.min(self.graphDim.width, tempWidth);\n          case self.NAVIGATE_RIGHT:\n            return -w(d, true);}\n\n      }\n    }).\n    attr('y', function (d) {\n      if (options.verticalOrientation) {\n        switch (navigationDir) {\n          case self.NAVIGATE_LEFT:\n            return Math.min(self.graphDim.height, tempHeight);\n          case self.NAVIGATE_RIGHT:\n            return -h(d, true);}\n\n      } else {\n        return 0;\n      }\n    }).\n    remove();\n\n    // Resize the root container\n    self.resize();\n  };\n};\n\nCalHeatMap.prototype = {\n  /**\r\n   * Validate and merge user settings with default settings\r\n   *\r\n   * @param  {object} settings User settings\r\n   * @return {bool} False if settings contains error\r\n   */\n  /* jshint maxstatements:false */\n  init: function (settings) {\n    'use strict';\n\n    var parent = this;\n\n    var options = parent.options = mergeRecursive(parent.options, settings);\n\n    // Fatal errors\n    // Stop script execution on error\n    validateDomainType();\n    validateSelector(options.itemSelector, false, 'itemSelector');\n\n    if (parent.allowedDataType.indexOf(options.dataType) === -1) {\n      throw new Error(\n      \"The data type '\" + options.dataType + \"' is not valid data type\");\n\n    }\n\n    if (d3.select(options.itemSelector)[0][0] === null) {\n      throw new Error(\n      \"The node '\" +\n      options.itemSelector +\n      \"' specified in itemSelector does not exists\");\n\n    }\n\n    try {\n      validateSelector(options.nextSelector, true, 'nextSelector');\n      validateSelector(options.previousSelector, true, 'previousSelector');\n    } catch (error) {\n      console.log(error.message);\n      return false;\n    }\n\n    // If other settings contains error, will fallback to default\n\n    if (!settings.hasOwnProperty('subDomain')) {\n      this.options.subDomain = getOptimalSubDomain(settings.domain);\n    }\n\n    if (\n    typeof options.itemNamespace !== 'string' ||\n    options.itemNamespace === '')\n    {\n      console.log(\n      'itemNamespace can not be empty, falling back to cal-heatmap');\n\n      options.itemNamespace = 'cal-heatmap';\n    }\n\n    // Don't touch these settings\n    var s = [\n    'data',\n    'onComplete',\n    'onClick',\n    'afterLoad',\n    'afterLoadData',\n    'afterLoadPreviousDomain',\n    'afterLoadNextDomain',\n    'afterUpdate'];\n\n\n    for (var k in s) {\n      if (settings.hasOwnProperty(s[k])) {\n        options[s[k]] = settings[s[k]];\n      }\n    }\n\n    options.subDomainDateFormat =\n    typeof options.subDomainDateFormat === 'string' ||\n    typeof options.subDomainDateFormat === 'function' ?\n    options.subDomainDateFormat :\n    this._domainType[options.subDomain].format.date;\n    options.domainLabelFormat =\n    typeof options.domainLabelFormat === 'string' ||\n    typeof options.domainLabelFormat === 'function' ?\n    options.domainLabelFormat :\n    this._domainType[options.domain].format.legend;\n    options.subDomainTextFormat =\n    typeof options.subDomainTextFormat === 'string' &&\n    options.subDomainTextFormat !== '' ||\n    typeof options.subDomainTextFormat === 'function' ?\n    options.subDomainTextFormat :\n    null;\n    options.domainMargin = expandMarginSetting(options.domainMargin);\n    options.legendMargin = expandMarginSetting(options.legendMargin);\n    options.highlight = parent.expandDateSetting(options.highlight);\n    options.itemName = expandItemName(options.itemName);\n    options.colLimit = parseColLimit(options.colLimit);\n    options.rowLimit = parseRowLimit(options.rowLimit);\n    if (!settings.hasOwnProperty('legendMargin')) {\n      autoAddLegendMargin();\n    }\n    autoAlignLabel();\n\n    /**\r\n     * Validate that a queryString is valid\r\n     *\r\n     * @param  {Element|string|bool} selector   The queryString to test\r\n     * @param  {bool}  canBeFalse  Whether false is an accepted and valid value\r\n     * @param  {string} name    Name of the tested selector\r\n     * @throws {Error}        If the selector is not valid\r\n     * @return {bool}        True if the selector is a valid queryString\r\n     */\n    function validateSelector(selector, canBeFalse, name) {\n      if (\n      (canBeFalse && selector === false ||\n      selector instanceof Element ||\n      typeof selector === 'string') &&\n      selector !== '')\n      {\n        return true;\n      }\n      throw new Error('The ' + name + ' is not valid');\n    }\n\n    /**\r\n     * Return the optimal subDomain for the specified domain\r\n     *\r\n     * @param  {string} domain a domain name\r\n     * @return {string}        the subDomain name\r\n     */\n    function getOptimalSubDomain(domain) {\n      switch (domain) {\n        case 'year':\n          return 'month';\n        case 'month':\n          return 'day';\n        case 'week':\n          return 'day';\n        case 'day':\n          return 'hour';\n        default:\n          return 'min';}\n\n    }\n\n    /**\r\n     * Ensure that the domain and subdomain are valid\r\n     *\r\n     * @throw {Error} when domain or subdomain are not valid\r\n     * @return {bool} True if domain and subdomain are valid and compatible\r\n     */\n    function validateDomainType() {\n      if (\n      !parent._domainType.hasOwnProperty(options.domain) ||\n      options.domain === 'min' ||\n      options.domain.substring(0, 2) === 'x_')\n      {\n        throw new Error(\"The domain '\" + options.domain + \"' is not valid\");\n      }\n\n      if (\n      !parent._domainType.hasOwnProperty(options.subDomain) ||\n      options.subDomain === 'year')\n      {\n        throw new Error(\n        \"The subDomain '\" + options.subDomain + \"' is not valid\");\n\n      }\n\n      if (\n      parent._domainType[options.domain].level <=\n      parent._domainType[options.subDomain].level)\n      {\n        throw new Error(\n        \"'\" +\n        options.subDomain +\n        \"' is not a valid subDomain to '\" +\n        options.domain +\n        \"'\");\n\n      }\n\n      return true;\n    }\n\n    /**\r\n     * Fine-tune the label alignement depending on its position\r\n     *\r\n     * @return void\r\n     */\n    function autoAlignLabel() {\n      // Auto-align label, depending on it's position\n      if (\n      !settings.hasOwnProperty('label') ||\n      settings.hasOwnProperty('label') &&\n      !settings.label.hasOwnProperty('align'))\n      {\n        switch (options.label.position) {\n          case 'left':\n            options.label.align = 'right';\n            break;\n          case 'right':\n            options.label.align = 'left';\n            break;\n          default:\n            options.label.align = 'center';}\n\n\n        if (options.label.rotate === 'left') {\n          options.label.align = 'right';\n        } else if (options.label.rotate === 'right') {\n          options.label.align = 'left';\n        }\n      }\n\n      if (\n      !settings.hasOwnProperty('label') ||\n      settings.hasOwnProperty('label') &&\n      !settings.label.hasOwnProperty('offset'))\n      {\n        if (\n        options.label.position === 'left' ||\n        options.label.position === 'right')\n        {\n          options.label.offset = {\n            x: 10,\n            y: 15 };\n\n        }\n      }\n    }\n\n    /**\r\n     * If not specified, add some margin around the legend depending on its position\r\n     *\r\n     * @return void\r\n     */\n    function autoAddLegendMargin() {\n      switch (options.legendVerticalPosition) {\n        case 'top':\n          options.legendMargin[2] = parent.DEFAULT_LEGEND_MARGIN;\n          break;\n        case 'bottom':\n          options.legendMargin[0] = parent.DEFAULT_LEGEND_MARGIN;\n          break;\n        case 'middle':\n        case 'center':\n          options.legendMargin[\n          options.legendHorizontalPosition === 'right' ? 3 : 1] =\n          parent.DEFAULT_LEGEND_MARGIN;}\n\n    }\n\n    /**\r\n     * Expand a number of an array of numbers to an usable 4 values array\r\n     *\r\n     * @param  {integer|array} value\r\n     * @return {array}        array\r\n     */\n    function expandMarginSetting(value) {\n      if (typeof value === 'number') {\n        value = [value];\n      }\n\n      if (!Array.isArray(value)) {\n        console.log('Margin only takes an integer or an array of integers');\n        value = [0];\n      }\n\n      switch (value.length) {\n        case 1:\n          return [value[0], value[0], value[0], value[0]];\n        case 2:\n          return [value[0], value[1], value[0], value[1]];\n        case 3:\n          return [value[0], value[1], value[2], value[1]];\n        case 4:\n          return value;\n        default:\n          return value.slice(0, 4);}\n\n    }\n\n    /**\r\n     * Convert a string to an array like [singular-form, plural-form]\r\n     *\r\n     * @param  {string|array} value Date to convert\r\n     * @return {array}       An array like [singular-form, plural-form]\r\n     */\n    function expandItemName(value) {\n      if (typeof value === 'string') {\n        return [value, value + (value !== '' ? 's' : '')];\n      }\n\n      if (Array.isArray(value)) {\n        if (value.length === 1) {\n          return [value[0], value[0] + 's'];\n        } else if (value.length > 2) {\n          return value.slice(0, 2);\n        }\n\n        return value;\n      }\n\n      return ['item', 'items'];\n    }\n\n    function parseColLimit(value) {\n      return value > 0 ? value : null;\n    }\n\n    function parseRowLimit(value) {\n      if (value > 0 && options.colLimit > 0) {\n        console.log(\n        'colLimit and rowLimit are mutually exclusive, rowLimit will be ignored');\n\n        return null;\n      }\n      return value > 0 ? value : null;\n    }\n\n    return this._init();\n  },\n\n  /**\r\n   * Convert a keyword or an array of keyword/date to an array of date objects\r\n   *\r\n   * @param  {string|array|Date} value Data to convert\r\n   * @return {array}       An array of Dates\r\n   */\n  expandDateSetting: function (value) {\n    'use strict';\n\n    if (!Array.isArray(value)) {\n      value = [value];\n    }\n\n    return value.\n    map(function (data) {\n      if (data === 'now') {\n        return new Date();\n      }\n      if (data instanceof Date) {\n        return data;\n      }\n      return false;\n    }).\n    filter(function (d) {\n      return d !== false;\n    });\n  },\n\n  /**\r\n   * Fill the calendar by coloring the cells\r\n   *\r\n   * @param array svg An array of html node to apply the transformation to (optional)\r\n   *                  It's used to limit the painting to only a subset of the calendar\r\n   * @return void\r\n   */\n  fill: function (svg) {\n    'use strict';\n\n    var parent = this;\n    var options = parent.options;\n\n    if (arguments.length === 0) {\n      svg = parent.root.selectAll('.graph-domain');\n    }\n\n    var rect = svg.\n    selectAll('svg').\n    selectAll('g').\n    data(function (d) {\n      return parent._domains.get(d);\n    });\n    /**\r\n     * Colorize the cell via a style attribute if enabled\r\n     */\n    function addStyle(element) {\n      if (parent.legendScale === null) {\n        return false;\n      }\n\n      element.attr('fill', function (d) {\n        if (\n        d.v === null &&\n        options.hasOwnProperty('considerMissingDataAsZero') &&\n        !options.considerMissingDataAsZero)\n        {\n          if (options.legendColors.hasOwnProperty('base')) {\n            return options.legendColors.base;\n          }\n        }\n\n        if (\n        options.legendColors !== null &&\n        options.legendColors.hasOwnProperty('empty') && (\n        d.v === 0 ||\n        d.v === null &&\n        options.hasOwnProperty('considerMissingDataAsZero') &&\n        options.considerMissingDataAsZero))\n        {\n          return options.legendColors.empty;\n        }\n\n        if (\n        d.v < 0 &&\n        options.legend[0] > 0 &&\n        options.legendColors !== null &&\n        options.legendColors.hasOwnProperty('overflow'))\n        {\n          return options.legendColors.overflow;\n        }\n\n        return parent.legendScale(\n        Math.min(d.v, options.legend[options.legend.length - 1]));\n\n      });\n    }\n\n    rect.\n    transition().\n    duration(options.animationDuration).\n    select('rect').\n    attr('class', function (d) {\n      var htmlClass = parent.getHighlightClassName(d.t).trim().split(' ');\n      var pastDate = parent.dateIsLessThan(d.t, new Date());\n      var sameDate = parent.dateIsEqual(d.t, new Date());\n\n      if (\n      parent.legendScale === null ||\n      d.v === null &&\n      options.hasOwnProperty('considerMissingDataAsZero') &&\n      !options.considerMissingDataAsZero &&\n      !options.legendColors.hasOwnProperty('base'))\n      {\n        htmlClass.push('graph-rect');\n      }\n\n      if (sameDate) {\n        htmlClass.push('now');\n      } else if (!pastDate) {\n        htmlClass.push('future');\n      }\n\n      if (d.v !== null) {\n        htmlClass.push(\n        parent.Legend.getClass(d.v, parent.legendScale === null));\n\n      } else if (options.considerMissingDataAsZero && pastDate) {\n        htmlClass.push(\n        parent.Legend.getClass(0, parent.legendScale === null));\n\n      }\n\n      if (options.onClick !== null) {\n        htmlClass.push('hover_cursor');\n      }\n\n      return htmlClass.join(' ');\n    }).\n    call(addStyle);\n\n    rect.\n    transition().\n    duration(options.animationDuration).\n    select('title').\n    text(function (d) {\n      return parent.getSubDomainTitle(d);\n    });\n\n    function formatSubDomainText(element) {\n      if (typeof options.subDomainTextFormat === 'function') {\n        element.text(function (d) {\n          return options.subDomainTextFormat(d.t, d.v);\n        });\n      }\n    }\n\n    /**\r\n     * Change the subDomainText class if necessary\r\n     * Also change the text, e.g when text is representing the value\r\n     * instead of the date\r\n     */\n    rect.\n    transition().\n    duration(options.animationDuration).\n    select('text').\n    attr('class', function (d) {\n      return 'subdomain-text' + parent.getHighlightClassName(d.t);\n    }).\n    call(formatSubDomainText).\n    attr('fill', (d) => {\n      if (!d.v) return '#000';\n      const rgb = parent.legendScale(\n      Math.min(d.v, options.legend[options.legend.length - 1]));\n\n      return (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_1__.getContrastingColor)(rgb, 135);\n    });\n  },\n\n  /**\r\n   * Sprintf like function.\r\n   * Replaces placeholders {0} in string with values from provided object.\r\n   *\r\n   * @param string formatted String containing placeholders.\r\n   * @param object args Object with properties to replace placeholders in string.\r\n   *\r\n   * @return String\r\n   */\n  formatStringWithObject: function (formatted, args) {\n    'use strict';\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        var regexp = new RegExp('\\\\{' + prop + '\\\\}', 'gi');\n        formatted = formatted.replace(regexp, args[prop]);\n      }\n    }\n    return formatted;\n  },\n\n  // =========================================================================//\n  // EVENTS CALLBACK                              //\n  // =========================================================================//\n\n  /**\r\n   * Helper method for triggering event callback\r\n   *\r\n   * @param  string  eventName       Name of the event to trigger\r\n   * @param  array  successArgs     List of argument to pass to the callback\r\n   * @param  boolean  skip      Whether to skip the event triggering\r\n   * @return mixed  True when the triggering was skipped, false on error, else the callback function\r\n   */\n  triggerEvent: function (eventName, successArgs, skip) {\n    'use strict';\n\n    if (arguments.length === 3 && skip || this.options[eventName] === null) {\n      return true;\n    }\n\n    if (typeof this.options[eventName] === 'function') {\n      if (typeof successArgs === 'function') {\n        successArgs = successArgs();\n      }\n      return this.options[eventName].apply(this, successArgs);\n    } else {\n      console.log('Provided callback for ' + eventName + ' is not a function.');\n      return false;\n    }\n  },\n\n  /**\r\n   * Event triggered on a mouse click on a subDomain cell\r\n   *\r\n   * @param  Date    d    Date of the subdomain block\r\n   * @param  int    itemNb  Number of items in that date\r\n   */\n  onClick: function (d, itemNb) {\n    'use strict';\n\n    return this.triggerEvent('onClick', [d, itemNb]);\n  },\n\n  /**\r\n   * Event triggered after drawing the calendar, byt before filling it with data\r\n   */\n  afterLoad: function () {\n    'use strict';\n\n    return this.triggerEvent('afterLoad');\n  },\n\n  /**\r\n   * Event triggered after completing drawing and filling the calendar\r\n   */\n  onComplete: function () {\n    'use strict';\n\n    var response = this.triggerEvent('onComplete', [], this._completed);\n    this._completed = true;\n    return response;\n  },\n\n  /**\r\n   * Event triggered after shifting the calendar one domain back\r\n   *\r\n   * @param  Date    start  Domain start date\r\n   * @param  Date    end    Domain end date\r\n   */\n  afterLoadPreviousDomain: function (start) {\n    'use strict';\n\n    var parent = this;\n    return this.triggerEvent('afterLoadPreviousDomain', function () {\n      var subDomain = parent.getSubDomain(start);\n      return [subDomain.shift(), subDomain.pop()];\n    });\n  },\n\n  /**\r\n   * Event triggered after shifting the calendar one domain above\r\n   *\r\n   * @param  Date    start  Domain start date\r\n   * @param  Date    end    Domain end date\r\n   */\n  afterLoadNextDomain: function (start) {\n    'use strict';\n\n    var parent = this;\n    return this.triggerEvent('afterLoadNextDomain', function () {\n      var subDomain = parent.getSubDomain(start);\n      return [subDomain.shift(), subDomain.pop()];\n    });\n  },\n\n  /**\r\n   * Event triggered after loading the leftmost domain allowed by minDate\r\n   *\r\n   * @param  boolean  reached True if the leftmost domain was reached\r\n   */\n  onMinDomainReached: function (reached) {\n    'use strict';\n\n    this._minDomainReached = reached;\n    return this.triggerEvent('onMinDomainReached', [reached]);\n  },\n\n  /**\r\n   * Event triggered after loading the rightmost domain allowed by maxDate\r\n   *\r\n   * @param  boolean  reached True if the rightmost domain was reached\r\n   */\n  onMaxDomainReached: function (reached) {\n    'use strict';\n\n    this._maxDomainReached = reached;\n    return this.triggerEvent('onMaxDomainReached', [reached]);\n  },\n\n  checkIfMinDomainIsReached: function (date, upperBound) {\n    'use strict';\n\n    if (this.minDomainIsReached(date)) {\n      this.onMinDomainReached(true);\n    }\n\n    if (arguments.length === 2) {\n      if (this._maxDomainReached && !this.maxDomainIsReached(upperBound)) {\n        this.onMaxDomainReached(false);\n      }\n    }\n  },\n\n  checkIfMaxDomainIsReached: function (date, lowerBound) {\n    'use strict';\n\n    if (this.maxDomainIsReached(date)) {\n      this.onMaxDomainReached(true);\n    }\n\n    if (arguments.length === 2) {\n      if (this._minDomainReached && !this.minDomainIsReached(lowerBound)) {\n        this.onMinDomainReached(false);\n      }\n    }\n  },\n\n  afterUpdate: function () {\n    'use strict';\n\n    return this.triggerEvent('afterUpdate');\n  },\n\n  // =========================================================================//\n  // FORMATTER                                //\n  // =========================================================================//\n\n  formatNumber: d3.format(',g'),\n\n  formatDate: function (d, format) {\n    'use strict';\n\n    if (arguments.length < 2) {\n      format = 'title';\n    }\n\n    if (typeof format === 'function') {\n      return format(d);\n    } else {\n      var f = d3.time.format(format);\n      return f(d);\n    }\n  },\n\n  getSubDomainTitle: function (d) {\n    'use strict';\n\n    if (d.v === null && !this.options.considerMissingDataAsZero) {\n      return this.formatStringWithObject(\n      this.options.subDomainTitleFormat.empty,\n      {\n        date: this.formatDate(\n        new Date(d.t),\n        this.options.subDomainDateFormat) });\n\n\n\n    } else {\n      var value = d.v;\n      // Consider null as 0\n      if (value === null && this.options.considerMissingDataAsZero) {\n        value = 0;\n      }\n\n      return this.formatStringWithObject(\n      this.options.subDomainTitleFormat.filled,\n      {\n        count: this.formatNumber(value),\n        name: this.options.itemName[value !== 1 ? 1 : 0],\n        connector: this._domainType[this.options.subDomain].format.connector,\n        date: this.formatDate(\n        new Date(d.t),\n        this.options.subDomainDateFormat) });\n\n\n\n    }\n  },\n\n  // =========================================================================//\n  // DOMAIN NAVIGATION                            //\n  // =========================================================================//\n\n  /**\r\n   * Shift the calendar one domain forward\r\n   *\r\n   * The new domain is loaded only if it's not beyond maxDate\r\n   *\r\n   * @param int n Number of domains to load\r\n   * @return bool True if the next domain was loaded, else false\r\n   */\n  loadNextDomain: function (n) {\n    'use strict';\n\n    if (this._maxDomainReached || n === 0) {\n      return false;\n    }\n\n    var bound = this.loadNewDomains(\n    this.NAVIGATE_RIGHT,\n    this.getDomain(this.getNextDomain(), n));\n\n\n    this.afterLoadNextDomain(bound.end);\n    this.checkIfMaxDomainIsReached(this.getNextDomain().getTime(), bound.start);\n\n    return true;\n  },\n\n  /**\r\n   * Shift the calendar one domain backward\r\n   *\r\n   * The previous domain is loaded only if it's not beyond the minDate\r\n   *\r\n   * @param int n Number of domains to load\r\n   * @return bool True if the previous domain was loaded, else false\r\n   */\n  loadPreviousDomain: function (n) {\n    'use strict';\n\n    if (this._minDomainReached || n === 0) {\n      return false;\n    }\n\n    var bound = this.loadNewDomains(\n    this.NAVIGATE_LEFT,\n    this.getDomain(this.getDomainKeys()[0], -n).reverse());\n\n\n    this.afterLoadPreviousDomain(bound.start);\n    this.checkIfMinDomainIsReached(bound.start, bound.end);\n\n    return true;\n  },\n\n  loadNewDomains: function (direction, newDomains) {\n    'use strict';\n\n    var parent = this;\n    var backward = direction === this.NAVIGATE_LEFT;\n    var i = -1;\n    var total = newDomains.length;\n    var domains = this.getDomainKeys();\n\n    function buildSubDomain(d) {\n      return {\n        t: parent._domainType[parent.options.subDomain].extractUnit(d),\n        v: null };\n\n    }\n\n    // Remove out of bound domains from list of new domains to prepend\n    while (++i < total) {\n      if (backward && this.minDomainIsReached(newDomains[i])) {\n        newDomains = newDomains.slice(0, i + 1);\n        break;\n      }\n      if (!backward && this.maxDomainIsReached(newDomains[i])) {\n        newDomains = newDomains.slice(0, i);\n        break;\n      }\n    }\n\n    newDomains = newDomains.slice(-this.options.range);\n\n    for (i = 0, total = newDomains.length; i < total; i += 1) {\n      this._domains.set(\n      newDomains[i].getTime(),\n      this.getSubDomain(newDomains[i]).map(buildSubDomain));\n\n\n      this._domains.remove(backward ? domains.pop() : domains.shift());\n    }\n\n    domains = this.getDomainKeys();\n\n    if (backward) {\n      newDomains = newDomains.reverse();\n    }\n\n    this.paint(direction);\n\n    this.getDatas(\n    this.options.data,\n    newDomains[0],\n    this.getSubDomain(newDomains[newDomains.length - 1]).pop(),\n    function () {\n      parent.fill(parent.lastInsertedSvg);\n    });\n\n\n    return {\n      start: newDomains[backward ? 0 : 1],\n      end: domains[domains.length - 1] };\n\n  },\n\n  /**\r\n   * Return whether a date is inside the scope determined by maxDate\r\n   *\r\n   * @param int datetimestamp The timestamp in ms to test\r\n   * @return bool True if the specified date correspond to the calendar upper bound\r\n   */\n  maxDomainIsReached: function (datetimestamp) {\n    'use strict';\n\n    return (\n      this.options.maxDate !== null &&\n      this.options.maxDate.getTime() < datetimestamp);\n\n  },\n\n  /**\r\n   * Return whether a date is inside the scope determined by minDate\r\n   *\r\n   * @param int datetimestamp The timestamp in ms to test\r\n   * @return bool True if the specified date correspond to the calendar lower bound\r\n   */\n  minDomainIsReached: function (datetimestamp) {\n    'use strict';\n\n    return (\n      this.options.minDate !== null &&\n      this.options.minDate.getTime() >= datetimestamp);\n\n  },\n\n  /**\r\n   * Return the list of the calendar's domain timestamp\r\n   *\r\n   * @return Array a sorted array of timestamp\r\n   */\n  getDomainKeys: function () {\n    'use strict';\n\n    return this._domains.\n    keys().\n    map(function (d) {\n      return parseInt(d, 10);\n    }).\n    sort(function (a, b) {\n      return a - b;\n    });\n  },\n\n  // =========================================================================//\n  // POSITIONNING                                //\n  // =========================================================================//\n\n  positionSubDomainX: function (d) {\n    'use strict';\n\n    var index = this._domainType[this.options.subDomain].position.x(\n    new Date(d));\n\n    return index * this.options.cellSize + index * this.options.cellPadding;\n  },\n\n  positionSubDomainY: function (d) {\n    'use strict';\n\n    var index = this._domainType[this.options.subDomain].position.y(\n    new Date(d));\n\n    return index * this.options.cellSize + index * this.options.cellPadding;\n  },\n\n  getSubDomainColumnNumber: function (d) {\n    'use strict';\n\n    if (this.options.rowLimit > 0) {\n      var i = this._domainType[this.options.subDomain].maxItemNumber;\n      if (typeof i === 'function') {\n        i = i(d);\n      }\n      return Math.ceil(i / this.options.rowLimit);\n    }\n\n    var j = this._domainType[this.options.subDomain].defaultColumnNumber;\n    if (typeof j === 'function') {\n      j = j(d);\n    }\n    return this.options.colLimit || j;\n  },\n\n  getSubDomainRowNumber: function (d) {\n    'use strict';\n\n    if (this.options.colLimit > 0) {\n      var i = this._domainType[this.options.subDomain].maxItemNumber;\n      if (typeof i === 'function') {\n        i = i(d);\n      }\n      return Math.ceil(i / this.options.colLimit);\n    }\n\n    var j = this._domainType[this.options.subDomain].defaultRowNumber;\n    if (typeof j === 'function') {\n      j = j(d);\n    }\n    return this.options.rowLimit || j;\n  },\n\n  /**\r\n   * Return a classname if the specified date should be highlighted\r\n   *\r\n   * @param  timestamp date Date of the current subDomain\r\n   * @return String the highlight class\r\n   */\n  getHighlightClassName: function (d) {\n    'use strict';\n\n    d = new Date(d);\n\n    if (this.options.highlight.length > 0) {\n      for (var i in this.options.highlight) {\n        if (this.dateIsEqual(this.options.highlight[i], d)) {\n          return this.isNow(this.options.highlight[i]) ?\n          ' highlight-now' :\n          ' highlight';\n        }\n      }\n    }\n    return '';\n  },\n\n  /**\r\n   * Return whether the specified date is now,\r\n   * according to the type of subdomain\r\n   *\r\n   * @param  Date d The date to compare\r\n   * @return bool True if the date correspond to a subdomain cell\r\n   */\n  isNow: function (d) {\n    'use strict';\n\n    return this.dateIsEqual(d, new Date());\n  },\n\n  /**\r\n   * Return whether 2 dates are equals\r\n   * This function is subdomain-aware,\r\n   * and dates comparison are dependent of the subdomain\r\n   *\r\n   * @param  Date dateA First date to compare\r\n   * @param  Date dateB Secon date to compare\r\n   * @return bool true if the 2 dates are equals\r\n   */\n  /* jshint maxcomplexity: false */\n  dateIsEqual: function (dateA, dateB) {\n    'use strict';\n\n    if (!(dateA instanceof Date)) {\n      dateA = new Date(dateA);\n    }\n\n    if (!(dateB instanceof Date)) {\n      dateB = new Date(dateB);\n    }\n\n    switch (this.options.subDomain) {\n      case 'x_min':\n      case 'min':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          dateA.getMonth() === dateB.getMonth() &&\n          dateA.getDate() === dateB.getDate() &&\n          dateA.getHours() === dateB.getHours() &&\n          dateA.getMinutes() === dateB.getMinutes());\n\n      case 'x_hour':\n      case 'hour':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          dateA.getMonth() === dateB.getMonth() &&\n          dateA.getDate() === dateB.getDate() &&\n          dateA.getHours() === dateB.getHours());\n\n      case 'x_day':\n      case 'day':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          dateA.getMonth() === dateB.getMonth() &&\n          dateA.getDate() === dateB.getDate());\n\n      case 'x_week':\n      case 'week':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          this.getWeekNumber(dateA) === this.getWeekNumber(dateB));\n\n      case 'x_month':\n      case 'month':\n        return (\n          dateA.getFullYear() === dateB.getFullYear() &&\n          dateA.getMonth() === dateB.getMonth());\n\n      default:\n        return false;}\n\n  },\n\n  /**\r\n   * Returns wether or not dateA is less than or equal to dateB. This function is subdomain aware.\r\n   * Performs automatic conversion of values.\r\n   * @param dateA may be a number or a Date\r\n   * @param dateB may be a number or a Date\r\n   * @returns {boolean}\r\n   */\n  dateIsLessThan: function (dateA, dateB) {\n    'use strict';\n\n    if (!(dateA instanceof Date)) {\n      dateA = new Date(dateA);\n    }\n\n    if (!(dateB instanceof Date)) {\n      dateB = new Date(dateB);\n    }\n\n    function normalizedMillis(date, subdomain) {\n      switch (subdomain) {\n        case 'x_min':\n        case 'min':\n          return new Date(\n          date.getFullYear(),\n          date.getMonth(),\n          date.getDate(),\n          date.getHours(),\n          date.getMinutes()).\n          getTime();\n        case 'x_hour':\n        case 'hour':\n          return new Date(\n          date.getFullYear(),\n          date.getMonth(),\n          date.getDate(),\n          date.getHours()).\n          getTime();\n        case 'x_day':\n        case 'day':\n          return new Date(\n          date.getFullYear(),\n          date.getMonth(),\n          date.getDate()).\n          getTime();\n        case 'x_week':\n        case 'week':\n        case 'x_month':\n        case 'month':\n          return new Date(date.getFullYear(), date.getMonth()).getTime();\n        default:\n          return date.getTime();}\n\n    }\n\n    return (\n      normalizedMillis(dateA, this.options.subDomain) <\n      normalizedMillis(dateB, this.options.subDomain));\n\n  },\n\n  // =========================================================================//\n  // DATE COMPUTATION                              //\n  // =========================================================================//\n\n  /**\r\n   * Return the day of the year for the date\r\n   * @param  Date\r\n   * @return  int Day of the year [1,366]\r\n   */\n  getDayOfYear: d3.time.format('%j'),\n\n  /**\r\n   * Return the week number of the year\r\n   * Monday as the first day of the week\r\n   * @return int  Week number [0-53]\r\n   */\n  getWeekNumber: function (d) {\n    'use strict';\n\n    var f =\n    this.options.weekStartOnMonday === true ?\n    d3.time.format('%W') :\n    d3.time.format('%U');\n    return f(d);\n  },\n\n  /**\r\n   * Return the week number, relative to its month\r\n   *\r\n   * @param  int|Date d Date or timestamp in milliseconds\r\n   * @return int Week number, relative to the month [0-5]\r\n   */\n  getMonthWeekNumber: function (d) {\n    'use strict';\n\n    if (typeof d === 'number') {\n      d = new Date(d);\n    }\n\n    var monthFirstWeekNumber = this.getWeekNumber(\n    new Date(d.getFullYear(), d.getMonth()));\n\n    return this.getWeekNumber(d) - monthFirstWeekNumber - 1;\n  },\n\n  /**\r\n   * Return the number of weeks in the dates' year\r\n   *\r\n   * @param  int|Date d Date or timestamp in milliseconds\r\n   * @return int Number of weeks in the date's year\r\n   */\n  getWeekNumberInYear: function (d) {\n    'use strict';\n\n    if (typeof d === 'number') {\n      d = new Date(d);\n    }\n  },\n\n  /**\r\n   * Return the number of days in the date's month\r\n   *\r\n   * @param  int|Date d Date or timestamp in milliseconds\r\n   * @return int Number of days in the date's month\r\n   */\n  getDayCountInMonth: function (d) {\n    'use strict';\n\n    return this.getEndOfMonth(d).getDate();\n  },\n\n  /**\r\n   * Return the number of days in the date's year\r\n   *\r\n   * @param  int|Date d Date or timestamp in milliseconds\r\n   * @return int Number of days in the date's year\r\n   */\n  getDayCountInYear: function (d) {\n    'use strict';\n\n    if (typeof d === 'number') {\n      d = new Date(d);\n    }\n    return new Date(d.getFullYear(), 1, 29).getMonth() === 1 ? 366 : 365;\n  },\n\n  /**\r\n   * Get the weekday from a date\r\n   *\r\n   * Return the week day number (0-6) of a date,\r\n   * depending on whether the week start on monday or sunday\r\n   *\r\n   * @param  Date d\r\n   * @return int The week day number (0-6)\r\n   */\n  getWeekDay: function (d) {\n    'use strict';\n\n    if (this.options.weekStartOnMonday === false) {\n      return d.getDay();\n    }\n    return d.getDay() === 0 ? 6 : d.getDay() - 1;\n  },\n\n  /**\r\n   * Get the last day of the month\r\n   * @param  Date|int  d  Date or timestamp in milliseconds\r\n   * @return Date      Last day of the month\r\n   */\n  getEndOfMonth: function (d) {\n    'use strict';\n\n    if (typeof d === 'number') {\n      d = new Date(d);\n    }\n    return new Date(d.getFullYear(), d.getMonth() + 1, 0);\n  },\n\n  /**\r\n   *\r\n   * @param  Date date\r\n   * @param  int count\r\n   * @param  string step\r\n   * @return Date\r\n   */\n  jumpDate: function (date, count, step) {\n    'use strict';\n\n    var d = new Date(date);\n    switch (step) {\n      case 'hour':\n        d.setHours(d.getHours() + count);\n        break;\n      case 'day':\n        d.setHours(d.getHours() + count * 24);\n        break;\n      case 'week':\n        d.setHours(d.getHours() + count * 24 * 7);\n        break;\n      case 'month':\n        d.setMonth(d.getMonth() + count);\n        break;\n      case 'year':\n        d.setFullYear(d.getFullYear() + count);}\n\n\n    return new Date(d);\n  },\n\n  // =========================================================================//\n  // DOMAIN COMPUTATION                            //\n  // =========================================================================//\n\n  /**\r\n   * Return all the minutes between 2 dates\r\n   *\r\n   * @param  Date  d  date  A date\r\n   * @param  int|date  range  Number of minutes in the range, or a stop date\r\n   * @return array  An array of minutes\r\n   */\n  getMinuteDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(\n    d.getFullYear(),\n    d.getMonth(),\n    d.getDate(),\n    d.getHours());\n\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(\n      range.getFullYear(),\n      range.getMonth(),\n      range.getDate(),\n      range.getHours());\n\n    } else {\n      stop = new Date(+start + range * 1000 * 60);\n    }\n    return d3.time.minutes(Math.min(start, stop), Math.max(start, stop));\n  },\n\n  /**\r\n   * Return all the hours between 2 dates\r\n   *\r\n   * @param  Date  d  A date\r\n   * @param  int|date  range  Number of hours in the range, or a stop date\r\n   * @return array  An array of hours\r\n   */\n  getHourDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(\n    d.getFullYear(),\n    d.getMonth(),\n    d.getDate(),\n    d.getHours());\n\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(\n      range.getFullYear(),\n      range.getMonth(),\n      range.getDate(),\n      range.getHours());\n\n    } else {\n      stop = new Date(start);\n      stop.setHours(stop.getHours() + range);\n    }\n\n    var domains = d3.time.hours(Math.min(start, stop), Math.max(start, stop));\n\n    // Passing from DST to standard time\n    // If there are 25 hours, let's compress the duplicate hours\n    var i = 0;\n    var total = domains.length;\n    for (i = 0; i < total; i += 1) {\n      if (i > 0 && domains[i].getHours() === domains[i - 1].getHours()) {\n        this.DSTDomain.push(domains[i].getTime());\n        domains.splice(i, 1);\n        break;\n      }\n    }\n\n    // d3.time.hours is returning more hours than needed when changing\n    // from DST to standard time, because there is really 2 hours between\n    // 1am and 2am!\n    if (typeof range === 'number' && domains.length > Math.abs(range)) {\n      domains.splice(domains.length - 1, 1);\n    }\n\n    return domains;\n  },\n\n  /**\r\n   * Return all the days between 2 dates\r\n   *\r\n   * @param  Date    d    A date\r\n   * @param  int|date  range  Number of days in the range, or a stop date\r\n   * @return array  An array of weeks\r\n   */\n  getDayDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(range.getFullYear(), range.getMonth(), range.getDate());\n    } else {\n      stop = new Date(start);\n      stop = new Date(stop.setDate(stop.getDate() + parseInt(range, 10)));\n    }\n\n    return d3.time.days(Math.min(start, stop), Math.max(start, stop));\n  },\n\n  /**\r\n   * Return all the weeks between 2 dates\r\n   *\r\n   * @param  Date  d  A date\r\n   * @param  int|date  range  Number of minutes in the range, or a stop date\r\n   * @return array  An array of weeks\r\n   */\n  getWeekDomain: function (d, range) {\n    'use strict';\n\n    var weekStart;\n\n    if (this.options.weekStartOnMonday === false) {\n      weekStart = new Date(\n      d.getFullYear(),\n      d.getMonth(),\n      d.getDate() - d.getDay());\n\n    } else {\n      if (d.getDay() === 1) {\n        weekStart = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n      } else if (d.getDay() === 0) {\n        weekStart = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n        weekStart.setDate(weekStart.getDate() - 6);\n      } else {\n        weekStart = new Date(\n        d.getFullYear(),\n        d.getMonth(),\n        d.getDate() - d.getDay() + 1);\n\n      }\n    }\n\n    var endDate = new Date(weekStart);\n\n    var stop = range;\n    if (typeof range !== 'object') {\n      stop = new Date(endDate.setDate(endDate.getDate() + range * 7));\n    }\n\n    return this.options.weekStartOnMonday === true ?\n    d3.time.mondays(Math.min(weekStart, stop), Math.max(weekStart, stop)) :\n    d3.time.sundays(Math.min(weekStart, stop), Math.max(weekStart, stop));\n  },\n\n  /**\r\n   * Return all the months between 2 dates\r\n   *\r\n   * @param  Date    d    A date\r\n   * @param  int|date  range  Number of months in the range, or a stop date\r\n   * @return array  An array of months\r\n   */\n  getMonthDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(d.getFullYear(), d.getMonth());\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(range.getFullYear(), range.getMonth());\n    } else {\n      stop = new Date(start);\n      stop = stop.setMonth(stop.getMonth() + range);\n    }\n\n    return d3.time.months(Math.min(start, stop), Math.max(start, stop));\n  },\n\n  /**\r\n   * Return all the years between 2 dates\r\n   *\r\n   * @param  Date  d  date  A date\r\n   * @param  int|date  range  Number of minutes in the range, or a stop date\r\n   * @return array  An array of hours\r\n   */\n  getYearDomain: function (d, range) {\n    'use strict';\n\n    var start = new Date(d.getFullYear(), 0);\n    var stop = null;\n    if (range instanceof Date) {\n      stop = new Date(range.getFullYear(), 0);\n    } else {\n      stop = new Date(d.getFullYear() + range, 0);\n    }\n\n    return d3.time.years(Math.min(start, stop), Math.max(start, stop));\n  },\n\n  /**\r\n   * Get an array of domain start dates\r\n   *\r\n   * @param  int|Date date A random date included in the wanted domain\r\n   * @param  int|Date range Number of dates to get, or a stop date\r\n   * @return Array of dates\r\n   */\n  getDomain: function (date, range) {\n    'use strict';\n\n    if (typeof date === 'number') {\n      date = new Date(date);\n    }\n\n    if (arguments.length < 2) {\n      range = this.options.range;\n    }\n\n    switch (this.options.domain) {\n      case 'hour':\n        var domains = this.getHourDomain(date, range);\n\n        // Case where an hour is missing, when passing from standard time to DST\n        // Missing hour is perfectly acceptabl in subDomain, but not in domains\n        if (typeof range === 'number' && domains.length < range) {\n          if (range > 0) {\n            domains.push(this.getHourDomain(domains[domains.length - 1], 2)[1]);\n          } else {\n            domains.shift(this.getHourDomain(domains[0], -2)[0]);\n          }\n        }\n        return domains;\n      case 'day':\n        return this.getDayDomain(date, range);\n      case 'week':\n        return this.getWeekDomain(date, range);\n      case 'month':\n        return this.getMonthDomain(date, range);\n      case 'year':\n        return this.getYearDomain(date, range);}\n\n  },\n\n  /* jshint maxcomplexity: false */\n  getSubDomain: function (date) {\n    'use strict';\n\n    if (typeof date === 'number') {\n      date = new Date(date);\n    }\n\n    var parent = this;\n\n    /**\r\n     * @return int\r\n     */\n    var computeDaySubDomainSize = function (date, domain) {\n      switch (domain) {\n        case 'year':\n          return parent.getDayCountInYear(date);\n        case 'month':\n          return parent.getDayCountInMonth(date);\n        case 'week':\n          return 7;}\n\n    };\n\n    /**\r\n     * @return int\r\n     */\n    var computeMinSubDomainSize = function (date, domain) {\n      switch (domain) {\n        case 'hour':\n          return 60;\n        case 'day':\n          return 60 * 24;\n        case 'week':\n          return 60 * 24 * 7;}\n\n    };\n\n    /**\r\n     * @return int\r\n     */\n    var computeHourSubDomainSize = function (date, domain) {\n      switch (domain) {\n        case 'day':\n          return 24;\n        case 'week':\n          return 168;\n        case 'month':\n          return parent.getDayCountInMonth(date) * 24;}\n\n    };\n\n    /**\r\n     * @return int\r\n     */\n    var computeWeekSubDomainSize = function (date, domain) {\n      if (domain === 'month') {\n        var endOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0);\n        var endWeekNb = parent.getWeekNumber(endOfMonth);\n        var startWeekNb = parent.getWeekNumber(\n        new Date(date.getFullYear(), date.getMonth()));\n\n\n        if (startWeekNb > endWeekNb) {\n          startWeekNb = 0;\n          endWeekNb += 1;\n        }\n\n        return endWeekNb - startWeekNb + 1;\n      } else if (domain === 'year') {\n        return parent.getWeekNumber(new Date(date.getFullYear(), 11, 31));\n      }\n    };\n\n    switch (this.options.subDomain) {\n      case 'x_min':\n      case 'min':\n        return this.getMinuteDomain(\n        date,\n        computeMinSubDomainSize(date, this.options.domain));\n\n      case 'x_hour':\n      case 'hour':\n        return this.getHourDomain(\n        date,\n        computeHourSubDomainSize(date, this.options.domain));\n\n      case 'x_day':\n      case 'day':\n        return this.getDayDomain(\n        date,\n        computeDaySubDomainSize(date, this.options.domain));\n\n      case 'x_week':\n      case 'week':\n        return this.getWeekDomain(\n        date,\n        computeWeekSubDomainSize(date, this.options.domain));\n\n      case 'x_month':\n      case 'month':\n        return this.getMonthDomain(date, 12);}\n\n  },\n\n  /**\r\n   * Get the n-th next domain after the calendar newest (rightmost) domain\r\n   * @param  int n\r\n   * @return Date The start date of the wanted domain\r\n   */\n  getNextDomain: function (n) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      n = 1;\n    }\n    return this.getDomain(\n    this.jumpDate(this.getDomainKeys().pop(), n, this.options.domain),\n    1)[\n    0];\n  },\n\n  /**\r\n   * Get the n-th domain before the calendar oldest (leftmost) domain\r\n   * @param  int n\r\n   * @return Date The start date of the wanted domain\r\n   */\n  getPreviousDomain: function (n) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      n = 1;\n    }\n    return this.getDomain(\n    this.jumpDate(this.getDomainKeys().shift(), -n, this.options.domain),\n    1)[\n    0];\n  },\n\n  // =========================================================================//\n  // DATAS                                  //\n  // =========================================================================//\n\n  /**\r\n   * Fetch and interpret data from the datasource\r\n   *\r\n   * @param string|object source\r\n   * @param Date startDate\r\n   * @param Date endDate\r\n   * @param function callback\r\n   * @param function|boolean afterLoad function used to convert the data into a json object. Use true to use the afterLoad callback\r\n   * @param updateMode\r\n   *\r\n   * @return mixed\r\n   * - True if there are no data to load\r\n   * - False if data are loaded asynchronously\r\n   */\n  getDatas: function (\n  source,\n  startDate,\n  endDate,\n  callback,\n  afterLoad,\n  updateMode)\n  {\n    'use strict';\n\n    var self = this;\n    if (arguments.length < 5) {\n      afterLoad = true;\n    }\n    if (arguments.length < 6) {\n      updateMode = this.APPEND_ON_UPDATE;\n    }\n    var _callback = function (error, data) {\n      if (afterLoad !== false) {\n        if (typeof afterLoad === 'function') {\n          data = afterLoad(data);\n        } else if (typeof self.options.afterLoadData === 'function') {\n          data = self.options.afterLoadData(data);\n        } else {\n          console.log('Provided callback for afterLoadData is not a function.');\n        }\n      } else if (\n      self.options.dataType === 'csv' ||\n      self.options.dataType === 'tsv')\n      {\n        data = this.interpretCSV(data);\n      }\n      self.parseDatas(data, updateMode, startDate, endDate);\n      if (typeof callback === 'function') {\n        callback();\n      }\n    };\n\n    switch (typeof source) {\n      case 'string':\n        if (source === '') {\n          _callback(null, {});\n          return true;\n        } else {\n          var url = this.parseURI(source, startDate, endDate);\n          var requestType = 'GET';\n          if (self.options.dataPostPayload !== null) {\n            requestType = 'POST';\n          }\n          var payload = null;\n          if (self.options.dataPostPayload !== null) {\n            payload = this.parseURI(\n            self.options.dataPostPayload,\n            startDate,\n            endDate);\n\n          }\n\n          var xhr = null;\n          switch (this.options.dataType) {\n            case 'json':\n              xhr = d3.json(url);\n              break;\n            case 'csv':\n              xhr = d3.csv(url);\n              break;\n            case 'tsv':\n              xhr = d3.tsv(url);\n              break;\n            case 'txt':\n              xhr = d3.text(url, 'text/plain');\n              break;}\n\n\n          // jshint maxdepth:5\n          if (self.options.dataRequestHeaders !== null) {\n            for (var header in self.options.dataRequestHeaders) {\n              if (self.options.dataRequestHeaders.hasOwnProperty(header)) {\n                xhr.header(header, self.options.dataRequestHeaders[header]);\n              }\n            }\n          }\n\n          xhr.send(requestType, payload, _callback);\n        }\n        return false;\n      case 'object':\n        if (source === Object(source)) {\n          _callback(null, source);\n          return false;\n        }\n      /* falls through */\n      default:\n        _callback(null, {});\n        return true;}\n\n  },\n\n  /**\r\n   * Populate the calendar internal data\r\n   *\r\n   * @param object data\r\n   * @param constant updateMode\r\n   * @param Date startDate\r\n   * @param Date endDate\r\n   *\r\n   * @return void\r\n   */\n  parseDatas: function (data, updateMode, startDate, endDate) {\n    'use strict';\n\n    if (updateMode === this.RESET_ALL_ON_UPDATE) {\n      this._domains.forEach(function (key, value) {\n        value.forEach(function (element, index, array) {\n          array[index].v = null;\n        });\n      });\n    }\n\n    var temp = {};\n\n    var extractTime = function (d) {\n      return d.t;\n    };\n\n    /*jshint forin:false */\n    for (var d in data) {\n      var date = new Date(d * 1000);\n      var domainUnit = this.getDomain(date)[0].getTime();\n      // The current data belongs to a domain that was compressed\n      // Compress the data for the two duplicate hours into the same hour\n      if (this.DSTDomain.indexOf(domainUnit) >= 0) {\n        // Re-assign all data to the first or the second duplicate hours\n        // depending on which is visible\n        if (this._domains.has(domainUnit - 3600 * 1000)) {\n          domainUnit -= 3600 * 1000;\n        }\n      }\n\n      // Skip if data is not relevant to current domain\n      if (\n      isNaN(d) ||\n      !data.hasOwnProperty(d) ||\n      !this._domains.has(domainUnit) ||\n      !(domainUnit >= +startDate && domainUnit < +endDate))\n      {\n        continue;\n      }\n\n      var subDomainsData = this._domains.get(domainUnit);\n\n      if (!temp.hasOwnProperty(domainUnit)) {\n        temp[domainUnit] = subDomainsData.map(extractTime);\n      }\n\n      var index = temp[domainUnit].indexOf(\n      this._domainType[this.options.subDomain].extractUnit(date));\n\n\n      if (updateMode === this.RESET_SINGLE_ON_UPDATE) {\n        subDomainsData[index].v = data[d];\n      } else {\n        if (!isNaN(subDomainsData[index].v)) {\n          subDomainsData[index].v += data[d];\n        } else {\n          subDomainsData[index].v = data[d];\n        }\n      }\n    }\n  },\n\n  parseURI: function (str, startDate, endDate) {\n    'use strict';\n\n    // Use a timestamp in seconds\n    str = str.replace(/\\{\\{t:start\\}\\}/g, startDate.getTime() / 1000);\n    str = str.replace(/\\{\\{t:end\\}\\}/g, endDate.getTime() / 1000);\n\n    // Use a string date, following the ISO-8601\n    str = str.replace(/\\{\\{d:start\\}\\}/g, startDate.toISOString());\n    str = str.replace(/\\{\\{d:end\\}\\}/g, endDate.toISOString());\n\n    return str;\n  },\n\n  interpretCSV: function (data) {\n    'use strict';\n\n    var d = {};\n    var keys = Object.keys(data[0]);\n    var i, total;\n    for (i = 0, total = data.length; i < total; i += 1) {\n      d[data[i][keys[0]]] = +data[i][keys[1]];\n    }\n    return d;\n  },\n\n  /**\r\n   * Handle the calendar layout and dimension\r\n   *\r\n   * Expand and shrink the container depending on its children dimension\r\n   * Also rearrange the children position depending on their dimension,\r\n   * and the legend position\r\n   *\r\n   * @return void\r\n   */\n  resize: function () {\n    'use strict';\n\n    var parent = this;\n    var options = parent.options;\n    var legendWidth = options.displayLegend ?\n    parent.Legend.getDim('width') +\n    options.legendMargin[1] +\n    options.legendMargin[3] :\n    0;\n    var legendHeight = options.displayLegend ?\n    parent.Legend.getDim('height') +\n    options.legendMargin[0] +\n    options.legendMargin[2] :\n    0;\n\n    var graphWidth =\n    parent.graphDim.width - options.domainGutter - options.cellPadding;\n    var graphHeight =\n    parent.graphDim.height - options.domainGutter - options.cellPadding;\n\n    this.root.\n    transition().\n    duration(options.animationDuration).\n    attr('width', function () {\n      if (\n      options.legendVerticalPosition === 'middle' ||\n      options.legendVerticalPosition === 'center')\n      {\n        return graphWidth + legendWidth;\n      }\n      return Math.max(graphWidth, legendWidth);\n    }).\n    attr('height', function () {\n      if (\n      options.legendVerticalPosition === 'middle' ||\n      options.legendVerticalPosition === 'center')\n      {\n        return Math.max(graphHeight, legendHeight);\n      }\n      return graphHeight + legendHeight;\n    });\n\n    this.root.\n    select('.graph').\n    transition().\n    duration(options.animationDuration).\n    attr('y', function () {\n      if (options.legendVerticalPosition === 'top') {\n        return legendHeight;\n      }\n      return 0;\n    }).\n    attr('x', function () {\n      if (\n      (options.legendVerticalPosition === 'middle' ||\n      options.legendVerticalPosition === 'center') &&\n      options.legendHorizontalPosition === 'left')\n      {\n        return legendWidth;\n      }\n      return 0;\n    });\n  },\n\n  // =========================================================================//\n  // PUBLIC API                                //\n  // =========================================================================//\n\n  /**\r\n   * Shift the calendar forward\r\n   */\n  next: function (n) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      n = 1;\n    }\n    return this.loadNextDomain(n);\n  },\n\n  /**\r\n   * Shift the calendar backward\r\n   */\n  previous: function (n) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      n = 1;\n    }\n    return this.loadPreviousDomain(n);\n  },\n\n  /**\r\n   * Jump directly to a specific date\r\n   *\r\n   * JumpTo will scroll the calendar until the wanted domain with the specified\r\n   * date is visible. Unless you set reset to true, the wanted domain\r\n   * will not necessarily be the first (leftmost) domain of the calendar.\r\n   *\r\n   * @param Date date Jump to the domain containing that date\r\n   * @param bool reset Whether the wanted domain should be the first domain of the calendar\r\n   * @param bool True of the calendar was scrolled\r\n   */\n  jumpTo: function (date, reset) {\n    'use strict';\n\n    if (arguments.length < 2) {\n      reset = false;\n    }\n    var domains = this.getDomainKeys();\n    var firstDomain = domains[0];\n    var lastDomain = domains[domains.length - 1];\n\n    if (date < firstDomain) {\n      return this.loadPreviousDomain(this.getDomain(firstDomain, date).length);\n    } else {\n      if (reset) {\n        return this.loadNextDomain(this.getDomain(firstDomain, date).length);\n      }\n\n      if (date > lastDomain) {\n        return this.loadNextDomain(this.getDomain(lastDomain, date).length);\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Navigate back to the start date\r\n   *\r\n   * @since  3.3.8\r\n   * @return void\r\n   */\n  rewind: function () {\n    'use strict';\n\n    this.jumpTo(this.options.start, true);\n  },\n\n  /**\r\n   * Update the calendar with new data\r\n   *\r\n   * @param  object|string    dataSource    The calendar's datasource, same type as this.options.data\r\n   * @param  boolean|function    afterLoad    Whether to execute afterLoad() on the data. Pass directly a function\r\n   * if you don't want to use the afterLoad() callback\r\n   */\n  update: function (dataSource, afterLoad, updateMode) {\n    'use strict';\n\n    if (arguments.length === 0) {\n      dataSource = this.options.data;\n    }\n    if (arguments.length < 2) {\n      afterLoad = true;\n    }\n    if (arguments.length < 3) {\n      updateMode = this.RESET_ALL_ON_UPDATE;\n    }\n\n    var domains = this.getDomainKeys();\n    var self = this;\n    this.getDatas(\n    dataSource,\n    new Date(domains[0]),\n    this.getSubDomain(domains[domains.length - 1]).pop(),\n    function () {\n      self.fill();\n      self.afterUpdate();\n    },\n    afterLoad,\n    updateMode);\n\n  },\n\n  /**\r\n   * Set the legend\r\n   *\r\n   * @param array legend an array of integer, representing the different threshold value\r\n   * @param array colorRange an array of 2 hex colors, for the minimum and maximum colors\r\n   */\n  setLegend: function () {\n    'use strict';\n\n    var oldLegend = this.options.legend.slice(0);\n    if (arguments.length >= 1 && Array.isArray(arguments[0])) {\n      this.options.legend = arguments[0];\n    }\n    if (arguments.length >= 2) {\n      if (Array.isArray(arguments[1]) && arguments[1].length >= 2) {\n        this.options.legendColors = [arguments[1][0], arguments[1][1]];\n      } else {\n        this.options.legendColors = arguments[1];\n      }\n    }\n\n    if (\n    arguments.length > 0 && !arrayEquals(oldLegend, this.options.legend) ||\n    arguments.length >= 2)\n    {\n      this.Legend.buildColors();\n      this.fill();\n    }\n\n    this.Legend.redraw(\n    this.graphDim.width -\n    this.options.domainGutter -\n    this.options.cellPadding);\n\n  },\n\n  /**\r\n   * Remove the legend\r\n   *\r\n   * @return bool False if there is no legend to remove\r\n   */\n  removeLegend: function () {\n    'use strict';\n\n    if (!this.options.displayLegend) {\n      return false;\n    }\n    this.options.displayLegend = false;\n    this.Legend.remove();\n    return true;\n  },\n\n  /**\r\n   * Display the legend\r\n   *\r\n   * @return bool False if the legend was already displayed\r\n   */\n  showLegend: function () {\n    'use strict';\n\n    if (this.options.displayLegend) {\n      return false;\n    }\n    this.options.displayLegend = true;\n    this.Legend.redraw(\n    this.graphDim.width -\n    this.options.domainGutter -\n    this.options.cellPadding);\n\n    return true;\n  },\n\n  /**\r\n   * Highlight dates\r\n   *\r\n   * Add a highlight class to a set of dates\r\n   *\r\n   * @since  3.3.5\r\n   * @param  array Array of dates to highlight\r\n   * @return bool True if dates were highlighted\r\n   */\n  highlight: function (args) {\n    'use strict';\n\n    if ((this.options.highlight = this.expandDateSetting(args)).length > 0) {\n      this.fill();\n      return true;\n    }\n    return false;\n  },\n\n  /**\r\n   * Destroy the calendar\r\n   *\r\n   * Usage: cal = cal.destroy();\r\n   *\r\n   * @since  3.3.6\r\n   * @param function A callback function to trigger after destroying the calendar\r\n   * @return null\r\n   */\n  destroy: function (callback) {\n    'use strict';\n\n    this.root.\n    transition().\n    duration(this.options.animationDuration).\n    attr('width', 0).\n    attr('height', 0).\n    remove().\n    each('end', function () {\n      if (typeof callback === 'function') {\n        callback();\n      } else if (typeof callback !== 'undefined') {\n        console.log('Provided callback for destroy() is not a function.');\n      }\n    });\n\n    return null;\n  },\n\n  getSVG: function () {\n    'use strict';\n\n    var styles = {\n      '.cal-heatmap-container': {},\n      '.graph': {},\n      '.graph-rect': {},\n      'rect.highlight': {},\n      'rect.now': {},\n      'rect.highlight-now': {},\n      'text.highlight': {},\n      'text.now': {},\n      'text.highlight-now': {},\n      '.domain-background': {},\n      '.graph-label': {},\n      '.subdomain-text': {},\n      '.q0': {},\n      '.qi': {} };\n\n\n    for (\n    var j = 1, total = this.options.legend.length + 1;\n    j <= total;\n    j += 1)\n    {\n      styles['.q' + j] = {};\n    }\n\n    var root = this.root;\n\n    var whitelistStyles = [\n    // SVG specific properties\n    'stroke',\n    'stroke-width',\n    'stroke-opacity',\n    'stroke-dasharray',\n    'stroke-dashoffset',\n    'stroke-linecap',\n    'stroke-miterlimit',\n    'fill',\n    'fill-opacity',\n    'fill-rule',\n    'marker',\n    'marker-start',\n    'marker-mid',\n    'marker-end',\n    'alignement-baseline',\n    'baseline-shift',\n    'dominant-baseline',\n    'glyph-orientation-horizontal',\n    'glyph-orientation-vertical',\n    'kerning',\n    'text-anchor',\n    'shape-rendering',\n\n    // Text Specific properties\n    'text-transform',\n    'font-family',\n    'font',\n    'font-size',\n    'font-weight'];\n\n\n    var filterStyles = function (attribute, property, value) {\n      if (whitelistStyles.indexOf(property) !== -1) {\n        styles[attribute][property] = value;\n      }\n    };\n\n    var getElement = function (e) {\n      return root.select(e)[0][0];\n    };\n\n    /* jshint forin:false */\n    for (var element in styles) {\n      if (!styles.hasOwnProperty(element)) {\n        continue;\n      }\n\n      var dom = getElement(element);\n\n      if (dom === null) {\n        continue;\n      }\n\n      // The DOM Level 2 CSS way\n      /* jshint maxdepth: false */\n      if ('getComputedStyle' in window) {\n        var cs = getComputedStyle(dom, null);\n        if (cs.length !== 0) {\n          for (var i = 0; i < cs.length; i += 1) {\n            filterStyles(element, cs.item(i), cs.getPropertyValue(cs.item(i)));\n          }\n\n          // Opera workaround. Opera doesn\"t support `item`/`length`\n          // on CSSStyleDeclaration.\n        } else {\n          for (var k in cs) {\n            if (cs.hasOwnProperty(k)) {\n              filterStyles(element, k, cs[k]);\n            }\n          }\n        }\n\n        // The IE way\n      } else if ('currentStyle' in dom) {\n        var css = dom.currentStyle;\n        for (var p in css) {\n          filterStyles(element, p, css[p]);\n        }\n      }\n    }\n\n    var string =\n    '<svg xmlns=\"http://www.w3.org/2000/svg\" ' +\n    'xmlns:xlink=\"http://www.w3.org/1999/xlink\"><style type=\"text/css\"><![CDATA[ ';\n\n    for (var style in styles) {\n      string += style + ' {\\n';\n      for (var l in styles[style]) {\n        string += '\\t' + l + ':' + styles[style][l] + ';\\n';\n      }\n      string += '}\\n';\n    }\n\n    string += ']]></style>';\n    string += new XMLSerializer().serializeToString(this.root[0][0]);\n    string += '</svg>';\n\n    return string;\n  } };\n\n\n// =========================================================================//\n// DOMAIN POSITION COMPUTATION                        //\n// =========================================================================//\n\n/**\r\n * Compute the position of a domain, relative to the calendar\r\n */\nvar DomainPosition = function () {\n  'use strict';\n\n  this.positions = d3.map();\n};\n\nDomainPosition.prototype.getPosition = function (d) {\n  'use strict';\n\n  return this.positions.get(d);\n};\n\nDomainPosition.prototype.getPositionFromIndex = function (i) {\n  'use strict';\n\n  var domains = this.getKeys();\n  return this.positions.get(domains[i]);\n};\n\nDomainPosition.prototype.getLast = function () {\n  'use strict';\n\n  var domains = this.getKeys();\n  return this.positions.get(domains[domains.length - 1]);\n};\n\nDomainPosition.prototype.setPosition = function (d, dim) {\n  'use strict';\n\n  this.positions.set(d, dim);\n};\n\nDomainPosition.prototype.shiftRightBy = function (exitingDomainDim) {\n  'use strict';\n\n  this.positions.forEach(function (key, value) {\n    this.set(key, value - exitingDomainDim);\n  });\n\n  var domains = this.getKeys();\n  this.positions.remove(domains[0]);\n};\n\nDomainPosition.prototype.shiftLeftBy = function (enteringDomainDim) {\n  'use strict';\n\n  this.positions.forEach(function (key, value) {\n    this.set(key, value + enteringDomainDim);\n  });\n\n  var domains = this.getKeys();\n  this.positions.remove(domains[domains.length - 1]);\n};\n\nDomainPosition.prototype.getKeys = function () {\n  'use strict';\n\n  return this.positions.keys().sort(function (a, b) {\n    return parseInt(a, 10) - parseInt(b, 10);\n  });\n};\n\n// =========================================================================//\n// LEGEND                                  //\n// =========================================================================//\n\nvar Legend = function (calendar) {\n  'use strict';\n\n  this.calendar = calendar;\n  this.computeDim();\n\n  if (calendar.options.legendColors !== null) {\n    this.buildColors();\n  }\n};\n\nLegend.prototype.computeDim = function () {\n  'use strict';\n\n  var options = this.calendar.options; // Shorter accessor for variable name mangling when minifying\n  this.dim = {\n    width:\n    options.legendCellSize * (options.legend.length + 1) +\n    options.legendCellPadding * options.legend.length,\n    height: options.legendCellSize };\n\n};\n\nLegend.prototype.remove = function () {\n  'use strict';\n\n  this.calendar.root.select('.graph-legend').remove();\n  this.calendar.resize();\n};\n\nLegend.prototype.redraw = function (width) {\n  'use strict';\n\n  if (!this.calendar.options.displayLegend) {\n    return false;\n  }\n\n  var parent = this;\n  var calendar = this.calendar;\n  var legend = calendar.root;\n  var legendItem;\n  var options = calendar.options; // Shorter accessor for variable name mangling when minifying\n\n  this.computeDim();\n\n  var _legend = options.legend.slice(0);\n  _legend.push(_legend[_legend.length - 1] + 1);\n\n  var legendElement = calendar.root.select('.graph-legend');\n  if (legendElement[0][0] !== null) {\n    legend = legendElement;\n    legendItem = legend.select('g').selectAll('rect').data(_legend);\n  } else {\n    // Creating the new legend DOM if it doesn't already exist\n    legend =\n    options.legendVerticalPosition === 'top' ?\n    legend.insert('svg', '.graph') :\n    legend.append('svg');\n\n    legend.attr('x', getLegendXPosition()).attr('y', getLegendYPosition());\n\n    legendItem = legend.\n    attr('class', 'graph-legend').\n    attr('height', parent.getDim('height')).\n    attr('width', parent.getDim('width')).\n    append('g').\n    selectAll().\n    data(_legend);\n  }\n\n  legendItem.\n  enter().\n  append('rect').\n  call(legendCellLayout).\n  attr('class', function (d) {\n    return calendar.Legend.getClass(d, calendar.legendScale === null);\n  }).\n  attr('fill-opacity', 0).\n  call(function (selection) {\n    if (\n    calendar.legendScale !== null &&\n    options.legendColors !== null &&\n    options.legendColors.hasOwnProperty('base'))\n    {\n      selection.attr('fill', options.legendColors.base);\n    }\n  }).\n  append('title');\n\n  legendItem.\n  exit().\n  transition().\n  duration(options.animationDuration).\n  attr('fill-opacity', 0).\n  remove();\n\n  legendItem.\n  transition().\n  delay(function (d, i) {\n    return options.animationDuration * i / 10;\n  }).\n  call(legendCellLayout).\n  attr('fill-opacity', 1).\n  call(function (element) {\n    element.attr('fill', function (d, i) {\n      if (calendar.legendScale === null) {\n        return '';\n      }\n\n      if (i === 0) {\n        return calendar.legendScale(d - 1);\n      }\n      return calendar.legendScale(options.legend[i - 1]);\n    });\n\n    element.attr('class', function (d) {\n      return calendar.Legend.getClass(d, calendar.legendScale === null);\n    });\n  });\n\n  function legendCellLayout(selection) {\n    selection.\n    attr('width', options.legendCellSize).\n    attr('height', options.legendCellSize).\n    attr('rx', options.legendCellRadius).\n    attr('ry', options.legendCellRadius).\n    attr('x', function (d, i) {\n      return i * (options.legendCellSize + options.legendCellPadding);\n    });\n  }\n\n  legendItem.select('title').text(function (d, i) {\n    if (i === 0) {\n      return calendar.formatStringWithObject(options.legendTitleFormat.lower, {\n        min: options.legend[i],\n        name: options.itemName[1] });\n\n    } else if (i === _legend.length - 1) {\n      return calendar.formatStringWithObject(options.legendTitleFormat.upper, {\n        max: options.legend[i - 1],\n        name: options.itemName[1] });\n\n    } else {\n      return calendar.formatStringWithObject(options.legendTitleFormat.inner, {\n        down: options.legend[i - 1],\n        up: options.legend[i],\n        name: options.itemName[1] });\n\n    }\n  });\n  legendItem.\n  on('mouseover', function (d) {\n    calendar.legendTip.show(d, this);\n  }).\n  on('mouseout', function () {\n    calendar.legendTip.hide();\n  });\n\n  legend.\n  transition().\n  duration(options.animationDuration).\n  attr('x', getLegendXPosition()).\n  attr('y', getLegendYPosition()).\n  attr('width', parent.getDim('width')).\n  attr('height', parent.getDim('height'));\n\n  legend.\n  select('g').\n  transition().\n  duration(options.animationDuration).\n  attr('transform', function () {\n    if (options.legendOrientation === 'vertical') {\n      return (\n        'rotate(90 ' +\n        options.legendCellSize / 2 +\n        ' ' +\n        options.legendCellSize / 2 +\n        ')');\n\n    }\n    return '';\n  });\n\n  function getLegendXPosition() {\n    switch (options.legendHorizontalPosition) {\n      case 'right':\n        if (\n        options.legendVerticalPosition === 'center' ||\n        options.legendVerticalPosition === 'middle')\n        {\n          return width + options.legendMargin[3];\n        }\n        return width - parent.getDim('width') - options.legendMargin[1];\n      case 'middle':\n      case 'center':\n        return Math.round(width / 2 - parent.getDim('width') / 2);\n      default:\n        return options.legendMargin[3];}\n\n  }\n\n  function getLegendYPosition() {\n    if (options.legendVerticalPosition === 'bottom') {\n      return (\n        calendar.graphDim.height +\n        options.legendMargin[0] -\n        options.domainGutter -\n        options.cellPadding);\n\n    }\n    return options.legendMargin[0];\n  }\n\n  calendar.resize();\n};\n\n/**\r\n * Return the dimension of the legend\r\n *\r\n * Takes into account rotation\r\n *\r\n * @param  string axis Width or height\r\n * @return int height or width in pixels\r\n */\nLegend.prototype.getDim = function (axis) {\n  'use strict';\n\n  var isHorizontal = this.calendar.options.legendOrientation === 'horizontal';\n\n  switch (axis) {\n    case 'width':\n      return this.dim[isHorizontal ? 'width' : 'height'];\n    case 'height':\n      return this.dim[isHorizontal ? 'height' : 'width'];}\n\n};\n\nLegend.prototype.buildColors = function () {\n  'use strict';\n\n  var options = this.calendar.options; // Shorter accessor for variable name mangling when minifying\n\n  if (options.legendColors === null) {\n    this.calendar.legendScale = null;\n    return false;\n  }\n\n  var _colorRange = [];\n\n  if (Array.isArray(options.legendColors)) {\n    _colorRange = options.legendColors;\n  } else if (\n  options.legendColors.hasOwnProperty('min') &&\n  options.legendColors.hasOwnProperty('max'))\n  {\n    _colorRange = [options.legendColors.min, options.legendColors.max];\n  } else {\n    options.legendColors = null;\n    return false;\n  }\n\n  var _legend = options.legend.slice(0);\n\n  if (_legend[0] > 0) {\n    _legend.unshift(0);\n  } else if (_legend[0] <= 0) {\n    // Let's guess the leftmost value, it we have to add one\n    _legend.unshift(\n    _legend[0] - (_legend[_legend.length - 1] - _legend[0]) / _legend.length);\n\n  }\n  var colorScale;\n  if (options.legendColors.hasOwnProperty('colorScale')) {\n    colorScale = options.legendColors.colorScale;\n  } else {\n    colorScale = d3.scale.\n    linear().\n    range(_colorRange).\n    interpolate(d3.interpolateHcl).\n    domain([d3.min(_legend), d3.max(_legend)]);\n  }\n\n  var legendColors = _legend.map(function (element) {\n    return colorScale(element);\n  });\n  this.calendar.legendScale = d3.scale.\n  threshold().\n  domain(options.legend).\n  range(legendColors);\n\n  return true;\n};\n\n/**\r\n * Return the classname on the legend for the specified value\r\n *\r\n * @param integer n Value associated to a date\r\n * @param bool withCssClass Whether to display the css class used to style the cell.\r\n *                          Disabling will allow styling directly via html fill attribute\r\n *\r\n * @return string Classname according to the legend\r\n */\nLegend.prototype.getClass = function (n, withCssClass) {\n  'use strict';\n\n  if (n === null || isNaN(n)) {\n    return '';\n  }\n\n  var index = [this.calendar.options.legend.length + 1];\n\n  for (\n  var i = 0, total = this.calendar.options.legend.length - 1;\n  i <= total;\n  i += 1)\n  {\n    if (this.calendar.options.legend[0] > 0 && n < 0) {\n      index = ['1', 'i'];\n      break;\n    }\n\n    if (n <= this.calendar.options.legend[i]) {\n      index = [i + 1];\n      break;\n    }\n  }\n\n  if (n === 0) {\n    index.push(0);\n  }\n\n  index.unshift('');\n  return (index.join(' r') + (withCssClass ? index.join(' q') : '')).trim();\n};\n\n/**\r\n * #source http://stackoverflow.com/a/383245/805649\r\n */\nfunction mergeRecursive(obj1, obj2) {\n  'use strict';\n\n  /*jshint forin:false */\n  for (var p in obj2) {\n    try {\n      // Property in destination object set; update its value.\n      if (obj2[p].constructor === Object) {\n        obj1[p] = mergeRecursive(obj1[p], obj2[p]);\n      } else {\n        obj1[p] = obj2[p];\n      }\n    } catch (e) {\n      // Property in destination object not set; create it and set its value.\n      obj1[p] = obj2[p];\n    }\n  }\n\n  return obj1;\n}\n\n/**\r\n * Check if 2 arrays are equals\r\n *\r\n * @link http://stackoverflow.com/a/14853974/805649\r\n * @param  array array the array to compare to\r\n * @return bool true of the 2 arrays are equals\r\n */\nfunction arrayEquals(arrayA, arrayB) {\n  'use strict';\n\n  // if the other array is a falsy value, return\n  if (!arrayB || !arrayA) {\n    return false;\n  }\n\n  // compare lengths - can save a lot of time\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n\n  for (var i = 0; i < arrayA.length; i += 1) {\n    // Check if we have nested arrays\n    if (arrayA[i] instanceof Array && arrayB[i] instanceof Array) {\n      // recurse into the nested arrays\n      if (!arrayEquals(arrayA[i], arrayB[i])) {\n        return false;\n      }\n    } else if (arrayA[i] !== arrayB[i]) {\n      // Warning - two different object instances will never be equal: {x:20} != {x:20}\n      return false;\n    }\n  }\n  return true;\n}const _default =\n\nCalHeatMap;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(d3, \"d3\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\vendor\\\\cal-heatmap.js\");reactHotLoader.register(CalHeatMap, \"CalHeatMap\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\vendor\\\\cal-heatmap.js\");reactHotLoader.register(DomainPosition, \"DomainPosition\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\vendor\\\\cal-heatmap.js\");reactHotLoader.register(Legend, \"Legend\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\vendor\\\\cal-heatmap.js\");reactHotLoader.register(mergeRecursive, \"mergeRecursive\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\vendor\\\\cal-heatmap.js\");reactHotLoader.register(arrayEquals, \"arrayEquals\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\vendor\\\\cal-heatmap.js\");reactHotLoader.register(_default, \"default\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\plugins\\\\legacy-plugin-chart-calendar\\\\src\\\\vendor\\\\cal-heatmap.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wbHVnaW5zL2xlZ2FjeS1wbHVnaW4tY2hhcnQtY2FsZW5kYXIvc3JjL3ZlbmRvci9jYWwtaGVhdG1hcC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BsdWdpbnMvbGVnYWN5LXBsdWdpbi1jaGFydC1jYWxlbmRhci9zcmMvdmVuZG9yL2NhbC1oZWF0bWFwLmpzP2VlNWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gW0xJQ0VOU0UgVEJEXVxyXG4vKiBDb3BpZWQgYW5kIGFsdGVyZWQgZnJvbSBodHRwOi8vY2FsLWhlYXRtYXAuY29tLyAsIGFsdGVyYXRpb25zIGFyb3VuZDpcclxuICogLSB0dW5pbmcgdG9vbHRpcHNcclxuICogLSBzdXBwb3J0aW5nIG11bHRpLWNvbG9ycyBzY2FsZXNcclxuICogLSBsZWdlbmQgZm9ybWF0XHJcbiAqIC0gVVRDIGhhbmRsaW5nXHJcbiAqL1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuXHJcbmltcG9ydCBkM3RpcCBmcm9tICdkMy10aXAnO1xyXG5pbXBvcnQgeyBnZXRDb250cmFzdGluZ0NvbG9yIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xyXG5cclxudmFyIGQzID0gdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyByZXF1aXJlKCdkMycpIDogd2luZG93LmQzO1xyXG5cclxudmFyIGQzID0gdHlwZW9mIHJlcXVpcmUgPT09ICdmdW5jdGlvbicgPyByZXF1aXJlKCdkMycpIDogd2luZG93LmQzO1xyXG5cclxudmFyIENhbEhlYXRNYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgc2VsZi50aXAgPSBkM3RpcCgpXHJcbiAgICAuYXR0cignY2xhc3MnLCAnZDMtdGlwJylcclxuICAgIC5kaXJlY3Rpb24oJ24nKVxyXG4gICAgLm9mZnNldChbLTUsIDBdKVxyXG4gICAgLmh0bWwoXHJcbiAgICAgIGQgPT4gYFxyXG4gICAgICAke3NlbGYub3B0aW9ucy50aW1lRm9ybWF0dGVyKGQudCl9OiA8c3Ryb25nPiR7c2VsZi5vcHRpb25zLnZhbHVlRm9ybWF0dGVyKFxyXG4gICAgICAgIGQudixcclxuICAgICAgKX08L3N0cm9uZz5cclxuICAgIGAsXHJcbiAgICApO1xyXG4gIHNlbGYubGVnZW5kVGlwID0gZDN0aXAoKVxyXG4gICAgLmF0dHIoJ2NsYXNzJywgJ2QzLXRpcCcpXHJcbiAgICAuZGlyZWN0aW9uKCduJylcclxuICAgIC5vZmZzZXQoWy01LCAwXSlcclxuICAgIC5odG1sKGQgPT4gc2VsZi5vcHRpb25zLnZhbHVlRm9ybWF0dGVyKGQpKTtcclxuXHJcbiAgdGhpcy5hbGxvd2VkRGF0YVR5cGUgPSBbJ2pzb24nLCAnY3N2JywgJ3RzdicsICd0eHQnXTtcclxuXHJcbiAgLy8gRGVmYXVsdCBzZXR0aW5nc1xyXG4gIHRoaXMub3B0aW9ucyA9IHtcclxuICAgIC8vIHNlbGVjdG9yIHN0cmluZyBvZiB0aGUgY29udGFpbmVyIHRvIGFwcGVuZCB0aGUgZ3JhcGggdG9cclxuICAgIC8vIEFjY2VwdCBhbnkgc3RyaW5nIHZhbHVlIGFjY2VwdGVkIGJ5IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Igb3IgQ1NTM1xyXG4gICAgLy8gb3IgYW4gRWxlbWVudCBvYmplY3RcclxuICAgIGl0ZW1TZWxlY3RvcjogJyNjYWwtaGVhdG1hcCcsXHJcblxyXG4gICAgLy8gV2hldGhlciB0byBwYWludCB0aGUgY2FsZW5kYXIgb24gaW5pdCgpXHJcbiAgICAvLyBVc2VkIGJ5IHRlc3RzdWl0ZSB0byByZWR1Y2UgdGVzdGluZyB0aW1lXHJcbiAgICBwYWludE9uTG9hZDogdHJ1ZSxcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIERPTUFJTlxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLy8gTnVtYmVyIG9mIGRvbWFpbiB0byBkaXNwbGF5IG9uIHRoZSBncmFwaFxyXG4gICAgcmFuZ2U6IDEyLFxyXG5cclxuICAgIC8vIFNpemUgb2YgZWFjaCBjZWxsLCBpbiBwaXhlbFxyXG4gICAgY2VsbFNpemU6IDEwLFxyXG5cclxuICAgIC8vIFBhZGRpbmcgYmV0d2VlbiBlYWNoIGNlbGwsIGluIHBpeGVsXHJcbiAgICBjZWxsUGFkZGluZzogMixcclxuXHJcbiAgICAvLyBGb3Igcm91bmRlZCBzdWJkb21haW4gcmVjdGFuZ2xlcywgaW4gcGl4ZWxzXHJcbiAgICBjZWxsUmFkaXVzOiAwLFxyXG5cclxuICAgIGRvbWFpbkd1dHRlcjogMixcclxuXHJcbiAgICBkb21haW5NYXJnaW46IFswLCAwLCAwLCAwXSxcclxuXHJcbiAgICB2YWx1ZUZvcm1hdHRlcjogZCA9PiBkLFxyXG5cclxuICAgIHRpbWVGb3JtYXR0ZXI6IGQgPT4gZCxcclxuXHJcbiAgICBkb21haW46ICdob3VyJyxcclxuXHJcbiAgICBzdWJEb21haW46ICdtaW4nLFxyXG5cclxuICAgIC8vIE51bWJlciBvZiBjb2x1bW5zIHRvIHNwbGl0IHRoZSBzdWJEb21haW5zIHRvXHJcbiAgICAvLyBJZiBub3QgbnVsbCwgd2lsbCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgcm93TGltaXRcclxuICAgIGNvbExpbWl0OiBudWxsLFxyXG5cclxuICAgIC8vIE51bWJlciBvZiByb3dzIHRvIHNwbGl0IHRoZSBzdWJEb21haW5zIHRvXHJcbiAgICAvLyBXaWxsIGJlIGlnbm9yZWQgaWYgY29sTGltaXQgaXMgbm90IG51bGxcclxuICAgIHJvd0xpbWl0OiBudWxsLFxyXG5cclxuICAgIC8vIEZpcnN0IGRheSBvZiB0aGUgd2VlayBpcyBNb25kYXlcclxuICAgIC8vIDAgdG8gc3RhcnQgdGhlIHdlZWsgb24gU3VuZGF5XHJcbiAgICB3ZWVrU3RhcnRPbk1vbmRheTogdHJ1ZSxcclxuXHJcbiAgICAvLyBTdGFydCBkYXRlIG9mIHRoZSBncmFwaFxyXG4gICAgLy8gQGRlZmF1bHQgbm93XHJcbiAgICBzdGFydDogbmV3IERhdGUoKSxcclxuXHJcbiAgICBtaW5EYXRlOiBudWxsLFxyXG5cclxuICAgIG1heERhdGU6IG51bGwsXHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBEQVRBXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvLyBEYXRhIHNvdXJjZVxyXG4gICAgLy8gVVJMLCB3aGVyZSB0byBmZXRjaCB0aGUgb3JpZ2luYWwgZGF0YXNcclxuICAgIGRhdGE6ICcnLFxyXG5cclxuICAgIC8vIERhdGEgdHlwZVxyXG4gICAgLy8gRGVmYXVsdDoganNvblxyXG4gICAgZGF0YVR5cGU6IHRoaXMuYWxsb3dlZERhdGFUeXBlWzBdLFxyXG5cclxuICAgIC8vIFBheWxvYWQgc2VudCB3aGVuIHVzaW5nIFBPU1QgaHR0cCBtZXRob2RcclxuICAgIC8vIExlYXZlIHRvIG51bGwgKGRlZmF1bHQpIGZvciBHRVQgcmVxdWVzdFxyXG4gICAgLy8gRXhwZWN0IGEgc3RyaW5nLCBmb3JtYXR0ZWQgbGlrZSBcImE9YjtjPWRcIlxyXG4gICAgZGF0YVBvc3RQYXlsb2FkOiBudWxsLFxyXG5cclxuICAgIC8vIEFkZGl0aW9uYWwgaGVhZGVycyBzZW50IHdoZW4gcmVxdWVzdGluZyBkYXRhXHJcbiAgICAvLyBFeHBlY3QgYW4gb2JqZWN0IGZvcm1hdHRlZCBsaWtlOlxyXG4gICAgLy8geyAnWC1DU1JGLVRPS0VOJzogJ3Rva2VuJyB9XHJcbiAgICBkYXRhUmVxdWVzdEhlYWRlcnM6IG51bGwsXHJcblxyXG4gICAgLy8gV2hldGhlciB0byBjb25zaWRlciBtaXNzaW5nIGRhdGU6dmFsdWUgZnJvbSB0aGUgZGF0YXNvdXJjZVxyXG4gICAgLy8gYXMgZXF1YWwgdG8gMCwgb3IganVzdCBsZWF2ZSB0aGVtIGFzIG1pc3NpbmdcclxuICAgIGNvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm86IGZhbHNlLFxyXG5cclxuICAgIC8vIExvYWQgcmVtb3RlIGRhdGEgb24gY2FsZW5kYXIgY3JlYXRpb25cclxuICAgIC8vIFdoZW4gZmFsc2UsIHRoZSBjYWxlbmRhciB3aWxsIGJlIGxlZnQgZW1wdHlcclxuICAgIGxvYWRPbkluaXQ6IHRydWUsXHJcblxyXG4gICAgLy8gQ2FsZW5kYXIgb3JpZW50YXRpb25cclxuICAgIC8vIGZhbHNlOiBkaXNwbGF5IGRvbWFpbnMgc2lkZSBieSBzaWRlXHJcbiAgICAvLyB0cnVlIDogZGlzcGxheSBkb21haW5zIG9uZSB1bmRlciB0aGUgb3RoZXJcclxuICAgIHZlcnRpY2FsT3JpZW50YXRpb246IGZhbHNlLFxyXG5cclxuICAgIC8vIERvbWFpbiBkeW5hbWljIHdpZHRoL2hlaWdodFxyXG4gICAgLy8gVGhlIHdpZHRoIG9uIGEgZG9tYWluIGRlcGVuZHMgb24gdGhlIG51bWJlciBvZlxyXG4gICAgZG9tYWluRHluYW1pY0RpbWVuc2lvbjogdHJ1ZSxcclxuXHJcbiAgICAvLyBEb21haW4gTGFiZWwgcHJvcGVydGllc1xyXG4gICAgbGFiZWw6IHtcclxuICAgICAgLy8gdmFsaWQ6IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFxyXG4gICAgICBwb3NpdGlvbjogJ2JvdHRvbScsXHJcblxyXG4gICAgICAvLyBWYWxpZDogbGVmdCwgY2VudGVyLCByaWdodFxyXG4gICAgICAvLyBBbHNvIHZhbGlkIGFyZSB0aGUgZGlyZWN0IHN2ZyB2YWx1ZXM6IHN0YXJ0LCBtaWRkbGUsIGVuZFxyXG4gICAgICBhbGlnbjogJ2NlbnRlcicsXHJcblxyXG4gICAgICAvLyBCeSBkZWZhdWx0LCB0aGVyZSBpcyBubyBtYXJnaW4vcGFkZGluZyBhcm91bmQgdGhlIGxhYmVsXHJcbiAgICAgIG9mZnNldDoge1xyXG4gICAgICAgIHg6IDAsXHJcbiAgICAgICAgeTogMCxcclxuICAgICAgfSxcclxuXHJcbiAgICAgIHJvdGF0ZTogbnVsbCxcclxuXHJcbiAgICAgIC8vIFVzZWQgb25seSBvbiB2ZXJ0aWNhbCBvcmllbnRhdGlvblxyXG4gICAgICB3aWR0aDogMTAwLFxyXG5cclxuICAgICAgLy8gVXNlZCBvbmx5IG9uIGhvcml6b250YWwgb3JpZW50YXRpb25cclxuICAgICAgaGVpZ2h0OiBudWxsLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIExFR0VORFxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLy8gVGhyZXNob2xkIGZvciB0aGUgbGVnZW5kXHJcbiAgICBsZWdlbmQ6IFsxMCwgMjAsIDMwLCA0MF0sXHJcblxyXG4gICAgLy8gV2hldGhlciB0byBkaXNwbGF5IHRoZSBsZWdlbmRcclxuICAgIGRpc3BsYXlMZWdlbmQ6IHRydWUsXHJcblxyXG4gICAgbGVnZW5kQ2VsbFNpemU6IDEwLFxyXG5cclxuICAgIGxlZ2VuZENlbGxQYWRkaW5nOiAyLFxyXG5cclxuICAgIGxlZ2VuZE1hcmdpbjogWzAsIDAsIDAsIDBdLFxyXG5cclxuICAgIC8vIExlZ2VuZCB2ZXJ0aWNhbCBwb3NpdGlvblxyXG4gICAgLy8gdG9wOiBwbGFjZSBsZWdlbmQgYWJvdmUgY2FsZW5kYXJcclxuICAgIC8vIGJvdHRvbTogcGxhY2UgbGVnZW5kIGJlbG93IHRoZSBjYWxlbmRhclxyXG4gICAgbGVnZW5kVmVydGljYWxQb3NpdGlvbjogJ2JvdHRvbScsXHJcblxyXG4gICAgLy8gTGVnZW5kIGhvcml6b250YWwgcG9zaXRpb25cclxuICAgIC8vIGFjY2VwdGVkIHZhbHVlczogbGVmdCwgY2VudGVyLCByaWdodFxyXG4gICAgbGVnZW5kSG9yaXpvbnRhbFBvc2l0aW9uOiAnbGVmdCcsXHJcblxyXG4gICAgLy8gTGVnZW5kIHJvdGF0aW9uXHJcbiAgICAvLyBhY2NlcHRlZCB2YWx1ZXM6IGhvcml6b250YWwsIHZlcnRpY2FsXHJcbiAgICBsZWdlbmRPcmllbnRhdGlvbjogJ2hvcml6b250YWwnLFxyXG5cclxuICAgIC8vIE9iamVjdHMgaG9sZGluZyBhbGwgdGhlIGhlYXRtYXAgZGlmZmVyZW50IGNvbG9yc1xyXG4gICAgLy8gbnVsbCB0byBkaXNhYmxlLCBhbmQgdXNlIHRoZSBkZWZhdWx0IGNzcyBzdHlsZXNcclxuICAgIC8vXHJcbiAgICAvLyBFeGFtcGxlczpcclxuICAgIC8vIGxlZ2VuZENvbG9yczoge1xyXG4gICAgLy8gICAgbWluOiBcImdyZWVuXCIsXHJcbiAgICAvLyAgICBtYXg6IFwicmVkXCIsXHJcbiAgICAvLyAgICBlbXB0eTogXCIjZmZmZmZmXCIsXHJcbiAgICAvLyAgICBiYXNlOiBcImdyZXlcIixcclxuICAgIC8vICAgIG92ZXJmbG93OiBcInJlZFwiLFxyXG4gICAgLy8gICAgY29sb3JTY2FsZXI6IG51bGwsXHJcbiAgICAvLyB9XHJcbiAgICBsZWdlbmRDb2xvcnM6IG51bGwsXHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBISUdITElHSFRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8vIExpc3Qgb2YgZGF0ZXMgdG8gaGlnaGxpZ2h0XHJcbiAgICAvLyBWYWxpZCB2YWx1ZXM6XHJcbiAgICAvLyAtIFtdOiBkb24ndCBoaWdobGlnaHQgYW55dGhpbmdcclxuICAgIC8vIC0gXCJub3dcIjogaGlnaGxpZ2h0IHRoZSBjdXJyZW50IGRhdGVcclxuICAgIC8vIC0gYW4gYXJyYXkgb2YgRGF0ZSBvYmplY3RzOiBoaWdobGlnaHQgdGhlIHNwZWNpZmllZCBkYXRlc1xyXG4gICAgaGlnaGxpZ2h0OiBbXSxcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIFRFWFQgRk9STUFUVElORyAvIGkxOG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8vIE5hbWUgb2YgdGhlIGl0ZW1zIHRvIHJlcHJlc2VudCBpbiB0aGUgY2FsZW5kYXJcclxuICAgIGl0ZW1OYW1lOiBbJ2l0ZW0nLCAnaXRlbXMnXSxcclxuXHJcbiAgICAvLyBGb3JtYXR0aW5nIG9mIHRoZSBkb21haW4gbGFiZWxcclxuICAgIC8vIEBkZWZhdWx0OiBudWxsLCB3aWxsIHVzZSB0aGUgZm9ybWF0dGluZyBhY2NvcmRpbmcgdG8gZG9tYWluIHR5cGVcclxuICAgIC8vIEFjY2VwdCBhIHN0cmluZyB1c2VkIGFzIHNwZWNpZmllciBieSBkMy50aW1lLmZvcm1hdCgpXHJcbiAgICAvLyBvciBhIGZ1bmN0aW9uXHJcbiAgICAvL1xyXG4gICAgLy8gUmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL3dpa2kvVGltZS1Gb3JtYXR0aW5nXHJcbiAgICAvLyBmb3IgYWNjZXB0ZWQgZGF0ZSBmb3JtYXR0aW5nIHVzZWQgYnkgZDMudGltZS5mb3JtYXQoKVxyXG4gICAgZG9tYWluTGFiZWxGb3JtYXQ6IG51bGwsXHJcblxyXG4gICAgLy8gRm9ybWF0dGluZyBvZiB0aGUgdGl0bGUgZGlzcGxheWVkIHdoZW4gaG92ZXJpbmcgYSBzdWJEb21haW4gY2VsbFxyXG4gICAgc3ViRG9tYWluVGl0bGVGb3JtYXQ6IHtcclxuICAgICAgZW1wdHk6ICd7ZGF0ZX0nLFxyXG4gICAgICBmaWxsZWQ6ICd7Y291bnR9IHtuYW1lfSB7Y29ubmVjdG9yfSB7ZGF0ZX0nLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGb3JtYXR0aW5nIG9mIHRoZSB7ZGF0ZX0gdXNlZCBpbiBzdWJEb21haW5UaXRsZUZvcm1hdFxyXG4gICAgLy8gQGRlZmF1bHQ6IG51bGwsIHdpbGwgdXNlIHRoZSBmb3JtYXR0aW5nIGFjY29yZGluZyB0byBzdWJEb21haW4gdHlwZVxyXG4gICAgLy8gQWNjZXB0IGEgc3RyaW5nIHVzZWQgYXMgc3BlY2lmaWVyIGJ5IGQzLnRpbWUuZm9ybWF0KClcclxuICAgIC8vIG9yIGEgZnVuY3Rpb25cclxuICAgIC8vXHJcbiAgICAvLyBSZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vbWJvc3RvY2svZDMvd2lraS9UaW1lLUZvcm1hdHRpbmdcclxuICAgIC8vIGZvciBhY2NlcHRlZCBkYXRlIGZvcm1hdHRpbmcgdXNlZCBieSBkMy50aW1lLmZvcm1hdCgpXHJcbiAgICBzdWJEb21haW5EYXRlRm9ybWF0OiBudWxsLFxyXG5cclxuICAgIC8vIEZvcm1hdHRpbmcgb2YgdGhlIHRleHQgaW5zaWRlIGVhY2ggc3ViRG9tYWluIGNlbGxcclxuICAgIC8vIEBkZWZhdWx0OiBudWxsLCBubyB0ZXh0XHJcbiAgICAvLyBBY2NlcHQgYSBzdHJpbmcgdXNlZCBhcyBzcGVjaWZpZXIgYnkgZDMudGltZS5mb3JtYXQoKVxyXG4gICAgLy8gb3IgYSBmdW5jdGlvblxyXG4gICAgLy9cclxuICAgIC8vIFJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9tYm9zdG9jay9kMy93aWtpL1RpbWUtRm9ybWF0dGluZ1xyXG4gICAgLy8gZm9yIGFjY2VwdGVkIGRhdGUgZm9ybWF0dGluZyB1c2VkIGJ5IGQzLnRpbWUuZm9ybWF0KClcclxuICAgIHN1YkRvbWFpblRleHRGb3JtYXQ6IG51bGwsXHJcblxyXG4gICAgLy8gRm9ybWF0dGluZyBvZiB0aGUgdGl0bGUgZGlzcGxheWVkIHdoZW4gaG92ZXJpbmcgYSBsZWdlbmQgY2VsbFxyXG4gICAgbGVnZW5kVGl0bGVGb3JtYXQ6IHtcclxuICAgICAgbG93ZXI6ICdsZXNzIHRoYW4ge21pbn0ge25hbWV9JyxcclxuICAgICAgaW5uZXI6ICdiZXR3ZWVuIHtkb3dufSBhbmQge3VwfSB7bmFtZX0nLFxyXG4gICAgICB1cHBlcjogJ21vcmUgdGhhbiB7bWF4fSB7bmFtZX0nLFxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBBbmltYXRpb24gZHVyYXRpb24sIGluIG1zXHJcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLFxyXG5cclxuICAgIG5leHRTZWxlY3RvcjogZmFsc2UsXHJcblxyXG4gICAgcHJldmlvdXNTZWxlY3RvcjogZmFsc2UsXHJcblxyXG4gICAgaXRlbU5hbWVzcGFjZTogJ2NhbC1oZWF0bWFwJyxcclxuXHJcbiAgICB0b29sdGlwOiBmYWxzZSxcclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIEVWRU5UUyBDQUxMQkFDS1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLy8gQ2FsbGJhY2sgd2hlbiBjbGlja2luZyBvbiBhIHRpbWUgYmxvY2tcclxuICAgIG9uQ2xpY2s6IG51bGwsXHJcblxyXG4gICAgLy8gQ2FsbGJhY2sgYWZ0ZXIgcGFpbnRpbmcgdGhlIGVtcHR5IGNhbGVuZGFyXHJcbiAgICAvLyBDYW4gYmUgdXNlZCB0byB0cmlnZ2VyIGFuIEFQSSBjYWxsLCBvbmNlIHRoZSBjYWxlbmRhciBpcyByZWFkeSB0byBiZSBmaWxsZWRcclxuICAgIGFmdGVyTG9hZDogbnVsbCxcclxuXHJcbiAgICAvLyBDYWxsYmFjayBhZnRlciBsb2FkaW5nIHRoZSBuZXh0IGRvbWFpbiBpbiB0aGUgY2FsZW5kYXJcclxuICAgIGFmdGVyTG9hZE5leHREb21haW46IG51bGwsXHJcblxyXG4gICAgLy8gQ2FsbGJhY2sgYWZ0ZXIgbG9hZGluZyB0aGUgcHJldmlvdXMgZG9tYWluIGluIHRoZSBjYWxlbmRhclxyXG4gICAgYWZ0ZXJMb2FkUHJldmlvdXNEb21haW46IG51bGwsXHJcblxyXG4gICAgLy8gQ2FsbGJhY2sgYWZ0ZXIgZmluaXNoaW5nIGFsbCBhY3Rpb25zIG9uIHRoZSBjYWxlbmRhclxyXG4gICAgb25Db21wbGV0ZTogbnVsbCxcclxuXHJcbiAgICAvLyBDYWxsYmFjayBhZnRlciBmZXRjaGluZyB0aGUgZGF0YXMsIGJ1dCBiZWZvcmUgYXBwbHlpbmcgdGhlbSB0byB0aGUgY2FsZW5kYXJcclxuICAgIC8vIFVzZWQgbWFpbmx5IHRvIGNvbnZlcnQgdGhlIGRhdGFzIGlmIHRoZXkncmUgbm90IGZvcm1hdHRlZCBsaWtlIGV4cGVjdGVkXHJcbiAgICAvLyBUYWtlcyB0aGUgZmV0Y2hlZCBcImRhdGFcIiBvYmplY3QgYXMgYXJndW1lbnQsIG11c3QgcmV0dXJuIGEganNvbiBvYmplY3RcclxuICAgIC8vIGZvcm1hdHRlZCBsaWtlIHt0aW1lc3RhbXA6Y291bnQsIHRpbWVzdGFtcDI6Y291bnQyfSxcclxuICAgIGFmdGVyTG9hZERhdGE6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDYWxsYmFjayB0cmlnZ2VyZWQgYWZ0ZXIgY2FsbGluZyBhbmQgY29tcGxldGluZyB1cGRhdGUoKS5cclxuICAgIGFmdGVyVXBkYXRlOiBudWxsLFxyXG5cclxuICAgIC8vIENhbGxiYWNrIHRyaWdnZXJlZCBhZnRlciBjYWxsaW5nIG5leHQoKS5cclxuICAgIC8vIFRoZSBgc3RhdHVzYCBhcmd1bWVudCBpcyBlcXVhbCB0byB0cnVlIGlmIHRoZXJlIGlzIG5vXHJcbiAgICAvLyBtb3JlIG5leHQgZG9tYWluIHRvIGxvYWRcclxuICAgIC8vXHJcbiAgICAvLyBUaGlzIGNhbGxiYWNrIGlzIGFsc28gZXhlY3V0ZWQgb25jZSwgYWZ0ZXIgY2FsbGluZyBwcmV2aW91cygpLFxyXG4gICAgLy8gb25seSB3aGVuIHRoZSBtYXggZG9tYWluIGlzIHJlYWNoZWRcclxuICAgIG9uTWF4RG9tYWluUmVhY2hlZDogbnVsbCxcclxuXHJcbiAgICAvLyBDYWxsYmFjayB0cmlnZ2VyZWQgYWZ0ZXIgY2FsbGluZyBwcmV2aW91cygpLlxyXG4gICAgLy8gVGhlIGBzdGF0dXNgIGFyZ3VtZW50IGlzIGVxdWFsIHRvIHRydWUgaWYgdGhlcmUgaXMgbm9cclxuICAgIC8vIG1vcmUgcHJldmlvdXMgZG9tYWluIHRvIGxvYWRcclxuICAgIC8vXHJcbiAgICAvLyBUaGlzIGNhbGxiYWNrIGlzIGFsc28gZXhlY3V0ZWQgb25jZSwgYWZ0ZXIgY2FsbGluZyBuZXh0KCksXHJcbiAgICAvLyBvbmx5IHdoZW4gdGhlIG1pbiBkb21haW4gaXMgcmVhY2hlZFxyXG4gICAgb25NaW5Eb21haW5SZWFjaGVkOiBudWxsLFxyXG4gIH07XHJcblxyXG4gIHRoaXMuX2RvbWFpblR5cGUgPSB7XHJcbiAgICBtaW46IHtcclxuICAgICAgbmFtZTogJ21pbnV0ZScsXHJcbiAgICAgIGxldmVsOiAxMCxcclxuICAgICAgbWF4SXRlbU51bWJlcjogNjAsXHJcbiAgICAgIGRlZmF1bHRSb3dOdW1iZXI6IDEwLFxyXG4gICAgICBkZWZhdWx0Q29sdW1uTnVtYmVyOiA2LFxyXG4gICAgICByb3c6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluUm93TnVtYmVyKGQpO1xyXG4gICAgICB9LFxyXG4gICAgICBjb2x1bW46IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluQ29sdW1uTnVtYmVyKGQpO1xyXG4gICAgICB9LFxyXG4gICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgIHg6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkLmdldE1pbnV0ZXMoKSAvIHNlbGYuX2RvbWFpblR5cGUubWluLnJvdyhkKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB5OiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGQuZ2V0TWludXRlcygpICUgc2VsZi5fZG9tYWluVHlwZS5taW4ucm93KGQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIGZvcm1hdDoge1xyXG4gICAgICAgIGRhdGU6ICclSDolTSwgJUEgJUIgJS1lLCAlWScsXHJcbiAgICAgICAgbGVnZW5kOiAnJyxcclxuICAgICAgICBjb25uZWN0b3I6ICdhdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgIGV4dHJhY3RVbml0OiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShcclxuICAgICAgICAgIGQuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICAgIGQuZ2V0TW9udGgoKSxcclxuICAgICAgICAgIGQuZ2V0RGF0ZSgpLFxyXG4gICAgICAgICAgZC5nZXRIb3VycygpLFxyXG4gICAgICAgICAgZC5nZXRNaW51dGVzKCksXHJcbiAgICAgICAgKS5nZXRUaW1lKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgaG91cjoge1xyXG4gICAgICBuYW1lOiAnaG91cicsXHJcbiAgICAgIGxldmVsOiAyMCxcclxuICAgICAgbWF4SXRlbU51bWJlcjogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBzd2l0Y2ggKHNlbGYub3B0aW9ucy5kb21haW4pIHtcclxuICAgICAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgICAgIHJldHVybiAyNDtcclxuICAgICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgICAgICByZXR1cm4gMjQgKiA3O1xyXG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIDI0ICpcclxuICAgICAgICAgICAgICAoc2VsZi5vcHRpb25zLmRvbWFpbkR5bmFtaWNEaW1lbnNpb25cclxuICAgICAgICAgICAgICAgID8gc2VsZi5nZXREYXlDb3VudEluTW9udGgoZClcclxuICAgICAgICAgICAgICAgIDogMzEpXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBkZWZhdWx0Um93TnVtYmVyOiA2LFxyXG4gICAgICBkZWZhdWx0Q29sdW1uTnVtYmVyOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHN3aXRjaCAoc2VsZi5vcHRpb25zLmRvbWFpbikge1xyXG4gICAgICAgICAgY2FzZSAnZGF5JzpcclxuICAgICAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICAgICAgICBjYXNlICd3ZWVrJzpcclxuICAgICAgICAgICAgcmV0dXJuIDI4O1xyXG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLmRvbWFpbkR5bmFtaWNEaW1lbnNpb25cclxuICAgICAgICAgICAgICA/IHNlbGYuZ2V0RGF5Q291bnRJbk1vbnRoKGQpXHJcbiAgICAgICAgICAgICAgOiAzMTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHJvdzogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5nZXRTdWJEb21haW5Sb3dOdW1iZXIoZCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbHVtbjogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5nZXRTdWJEb21haW5Db2x1bW5OdW1iZXIoZCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgeDogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZG9tYWluID09PSAnbW9udGgnKSB7XHJcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuY29sTGltaXQgPiAwIHx8IHNlbGYub3B0aW9ucy5yb3dMaW1pdCA+IDApIHtcclxuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihcclxuICAgICAgICAgICAgICAgIChkLmdldEhvdXJzKCkgKyAoZC5nZXREYXRlKCkgLSAxKSAqIDI0KSAvXHJcbiAgICAgICAgICAgICAgICAgIHNlbGYuX2RvbWFpblR5cGUuaG91ci5yb3coZCksXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIE1hdGguZmxvb3IoZC5nZXRIb3VycygpIC8gc2VsZi5fZG9tYWluVHlwZS5ob3VyLnJvdyhkKSkgK1xyXG4gICAgICAgICAgICAgIChkLmdldERhdGUoKSAtIDEpICogNFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxmLm9wdGlvbnMuZG9tYWluID09PSAnd2VlaycpIHtcclxuICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jb2xMaW1pdCA+IDAgfHwgc2VsZi5vcHRpb25zLnJvd0xpbWl0ID4gMCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKFxyXG4gICAgICAgICAgICAgICAgKGQuZ2V0SG91cnMoKSArIHNlbGYuZ2V0V2Vla0RheShkKSAqIDI0KSAvXHJcbiAgICAgICAgICAgICAgICAgIHNlbGYuX2RvbWFpblR5cGUuaG91ci5yb3coZCksXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIE1hdGguZmxvb3IoZC5nZXRIb3VycygpIC8gc2VsZi5fZG9tYWluVHlwZS5ob3VyLnJvdyhkKSkgK1xyXG4gICAgICAgICAgICAgIHNlbGYuZ2V0V2Vla0RheShkKSAqIDRcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGQuZ2V0SG91cnMoKSAvIHNlbGYuX2RvbWFpblR5cGUuaG91ci5yb3coZCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeTogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHZhciBwID0gZC5nZXRIb3VycygpO1xyXG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jb2xMaW1pdCA+IDAgfHwgc2VsZi5vcHRpb25zLnJvd0xpbWl0ID4gMCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHNlbGYub3B0aW9ucy5kb21haW4pIHtcclxuICAgICAgICAgICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgICAgICAgICAgICBwICs9IChkLmdldERhdGUoKSAtIDEpICogMjQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICd3ZWVrJzpcclxuICAgICAgICAgICAgICAgIHAgKz0gc2VsZi5nZXRXZWVrRGF5KGQpICogMjQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocCAlIHNlbGYuX2RvbWFpblR5cGUuaG91ci5yb3coZCkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIGZvcm1hdDoge1xyXG4gICAgICAgIGRhdGU6ICclSGgsICVBICVCICUtZSwgJVknLFxyXG4gICAgICAgIGxlZ2VuZDogJyVIOjAwJyxcclxuICAgICAgICBjb25uZWN0b3I6ICdhdCcsXHJcbiAgICAgIH0sXHJcbiAgICAgIGV4dHJhY3RVbml0OiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShcclxuICAgICAgICAgIGQuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgICAgIGQuZ2V0TW9udGgoKSxcclxuICAgICAgICAgIGQuZ2V0RGF0ZSgpLFxyXG4gICAgICAgICAgZC5nZXRIb3VycygpLFxyXG4gICAgICAgICkuZ2V0VGltZSgpO1xyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIGRheToge1xyXG4gICAgICBuYW1lOiAnZGF5JyxcclxuICAgICAgbGV2ZWw6IDMwLFxyXG4gICAgICBtYXhJdGVtTnVtYmVyOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHN3aXRjaCAoc2VsZi5vcHRpb25zLmRvbWFpbikge1xyXG4gICAgICAgICAgY2FzZSAnd2Vlayc6XHJcbiAgICAgICAgICAgIHJldHVybiA3O1xyXG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLmRvbWFpbkR5bmFtaWNEaW1lbnNpb25cclxuICAgICAgICAgICAgICA/IHNlbGYuZ2V0RGF5Q291bnRJbk1vbnRoKGQpXHJcbiAgICAgICAgICAgICAgOiAzMTtcclxuICAgICAgICAgIGNhc2UgJ3llYXInOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLmRvbWFpbkR5bmFtaWNEaW1lbnNpb25cclxuICAgICAgICAgICAgICA/IHNlbGYuZ2V0RGF5Q291bnRJblllYXIoZClcclxuICAgICAgICAgICAgICA6IDM2NjtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGRlZmF1bHRDb2x1bW5OdW1iZXI6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgZCA9IG5ldyBEYXRlKGQpO1xyXG4gICAgICAgIHN3aXRjaCAoc2VsZi5vcHRpb25zLmRvbWFpbikge1xyXG4gICAgICAgICAgY2FzZSAnd2Vlayc6XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLmRvbWFpbkR5bmFtaWNEaW1lbnNpb24gJiZcclxuICAgICAgICAgICAgICAhc2VsZi5vcHRpb25zLnZlcnRpY2FsT3JpZW50YXRpb25cclxuICAgICAgICAgICAgICA/IHNlbGYuZ2V0V2Vla051bWJlcihcclxuICAgICAgICAgICAgICAgICAgbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkgKyAxLCAwKSxcclxuICAgICAgICAgICAgICAgICkgLVxyXG4gICAgICAgICAgICAgICAgICBzZWxmLmdldFdlZWtOdW1iZXIoZCkgK1xyXG4gICAgICAgICAgICAgICAgICAxXHJcbiAgICAgICAgICAgICAgOiA2O1xyXG4gICAgICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLm9wdGlvbnMuZG9tYWluRHluYW1pY0RpbWVuc2lvblxyXG4gICAgICAgICAgICAgID8gc2VsZi5nZXRXZWVrTnVtYmVyKG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMTEsIDMxKSkgLVxyXG4gICAgICAgICAgICAgICAgICBzZWxmLmdldFdlZWtOdW1iZXIobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCAwKSkgK1xyXG4gICAgICAgICAgICAgICAgICAxXHJcbiAgICAgICAgICAgICAgOiA1NDtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIGRlZmF1bHRSb3dOdW1iZXI6IDcsXHJcbiAgICAgIHJvdzogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5nZXRTdWJEb21haW5Sb3dOdW1iZXIoZCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbHVtbjogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5nZXRTdWJEb21haW5Db2x1bW5OdW1iZXIoZCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgeDogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHN3aXRjaCAoc2VsZi5vcHRpb25zLmRvbWFpbikge1xyXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcclxuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihcclxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0V2Vla0RheShkKSAvIHNlbGYuX2RvbWFpblR5cGUuZGF5LnJvdyhkKSxcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jb2xMaW1pdCA+IDAgfHwgc2VsZi5vcHRpb25zLnJvd0xpbWl0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoXHJcbiAgICAgICAgICAgICAgICAgIChkLmdldERhdGUoKSAtIDEpIC8gc2VsZi5fZG9tYWluVHlwZS5kYXkucm93KGQpLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0V2Vla051bWJlcihkKSAtXHJcbiAgICAgICAgICAgICAgICBzZWxmLmdldFdlZWtOdW1iZXIobmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkpKVxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxyXG4gICAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuY29sTGltaXQgPiAwIHx8IHNlbGYub3B0aW9ucy5yb3dMaW1pdCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKFxyXG4gICAgICAgICAgICAgICAgICAoc2VsZi5nZXREYXlPZlllYXIoZCkgLSAxKSAvIHNlbGYuX2RvbWFpblR5cGUuZGF5LnJvdyhkKSxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldFdlZWtOdW1iZXIoZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICB5OiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgdmFyIHAgPSBzZWxmLmdldFdlZWtEYXkoZCk7XHJcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbExpbWl0ID4gMCB8fCBzZWxmLm9wdGlvbnMucm93TGltaXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2VsZi5vcHRpb25zLmRvbWFpbikge1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxyXG4gICAgICAgICAgICAgICAgcCA9IHNlbGYuZ2V0RGF5T2ZZZWFyKGQpIC0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgICAgICAgICAgcCA9IHNlbGYuZ2V0V2Vla0RheShkKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgICAgICAgIHAgPSBkLmdldERhdGUoKSAtIDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IocCAlIHNlbGYuX2RvbWFpblR5cGUuZGF5LnJvdyhkKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgICAgZm9ybWF0OiB7XHJcbiAgICAgICAgZGF0ZTogJyVBICVCICUtZSwgJVknLFxyXG4gICAgICAgIGxlZ2VuZDogJyVlICViJyxcclxuICAgICAgICBjb25uZWN0b3I6ICdvbicsXHJcbiAgICAgIH0sXHJcbiAgICAgIGV4dHJhY3RVbml0OiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpLmdldFRpbWUoKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICB3ZWVrOiB7XHJcbiAgICAgIG5hbWU6ICd3ZWVrJyxcclxuICAgICAgbGV2ZWw6IDQwLFxyXG4gICAgICBtYXhJdGVtTnVtYmVyOiA1NCxcclxuICAgICAgZGVmYXVsdENvbHVtbk51bWJlcjogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBkID0gbmV3IERhdGUoZCk7XHJcbiAgICAgICAgc3dpdGNoIChzZWxmLm9wdGlvbnMuZG9tYWluKSB7XHJcbiAgICAgICAgICBjYXNlICd5ZWFyJzpcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2RvbWFpblR5cGUud2Vlay5tYXhJdGVtTnVtYmVyO1xyXG4gICAgICAgICAgY2FzZSAnbW9udGgnOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLmRvbWFpbkR5bmFtaWNEaW1lbnNpb25cclxuICAgICAgICAgICAgICA/IHNlbGYuZ2V0V2Vla051bWJlcihcclxuICAgICAgICAgICAgICAgICAgbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkgKyAxLCAwKSxcclxuICAgICAgICAgICAgICAgICkgLSBzZWxmLmdldFdlZWtOdW1iZXIoZClcclxuICAgICAgICAgICAgICA6IDU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBkZWZhdWx0Um93TnVtYmVyOiAxLFxyXG4gICAgICByb3c6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluUm93TnVtYmVyKGQpO1xyXG4gICAgICB9LFxyXG4gICAgICBjb2x1bW46IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluQ29sdW1uTnVtYmVyKGQpO1xyXG4gICAgICB9LFxyXG4gICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgIHg6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKHNlbGYub3B0aW9ucy5kb21haW4pIHtcclxuICAgICAgICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoXHJcbiAgICAgICAgICAgICAgICBzZWxmLmdldFdlZWtOdW1iZXIoZCkgLyBzZWxmLl9kb21haW5UeXBlLndlZWsucm93KGQpLFxyXG4gICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihcclxuICAgICAgICAgICAgICAgIHNlbGYuZ2V0TW9udGhXZWVrTnVtYmVyKGQpIC8gc2VsZi5fZG9tYWluVHlwZS53ZWVrLnJvdyhkKSxcclxuICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgeTogZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgIHJldHVybiBzZWxmLmdldFdlZWtOdW1iZXIoZCkgJSBzZWxmLl9kb21haW5UeXBlLndlZWsucm93KGQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIGZvcm1hdDoge1xyXG4gICAgICAgIGRhdGU6ICclQiBXZWVrICMlVycsXHJcbiAgICAgICAgbGVnZW5kOiAnJUIgV2VlayAjJVcnLFxyXG4gICAgICAgIGNvbm5lY3RvcjogJ2luJyxcclxuICAgICAgfSxcclxuICAgICAgZXh0cmFjdFVuaXQ6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdmFyIGR0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcclxuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gSVNPLTg2MDEsIHdlZWsgbnVtYmVyIGNvbXB1dGF0aW9uIGFyZSBiYXNlZCBvbiB3ZWVrIHN0YXJ0aW5nIG9uIE1vbmRheVxyXG4gICAgICAgIHZhciB3ZWVrRGF5ID0gZHQuZ2V0RGF5KCkgLSAoc2VsZi5vcHRpb25zLndlZWtTdGFydE9uTW9uZGF5ID8gMSA6IDApO1xyXG4gICAgICAgIGlmICh3ZWVrRGF5IDwgMCkge1xyXG4gICAgICAgICAgd2Vla0RheSA9IDY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGR0LnNldERhdGUoZHQuZ2V0RGF0ZSgpIC0gd2Vla0RheSk7XHJcbiAgICAgICAgcmV0dXJuIGR0LmdldFRpbWUoKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgICBtb250aDoge1xyXG4gICAgICBuYW1lOiAnbW9udGgnLFxyXG4gICAgICBsZXZlbDogNTAsXHJcbiAgICAgIG1heEl0ZW1OdW1iZXI6IDEyLFxyXG4gICAgICBkZWZhdWx0Q29sdW1uTnVtYmVyOiAxMixcclxuICAgICAgZGVmYXVsdFJvd051bWJlcjogMSxcclxuICAgICAgcm93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYuZ2V0U3ViRG9tYWluUm93TnVtYmVyKCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGNvbHVtbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLmdldFN1YkRvbWFpbkNvbHVtbk51bWJlcigpO1xyXG4gICAgICB9LFxyXG4gICAgICBwb3NpdGlvbjoge1xyXG4gICAgICAgIHg6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkLmdldE1vbnRoKCkgLyBzZWxmLl9kb21haW5UeXBlLm1vbnRoLnJvdyhkKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB5OiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGQuZ2V0TW9udGgoKSAlIHNlbGYuX2RvbWFpblR5cGUubW9udGgucm93KGQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIGZvcm1hdDoge1xyXG4gICAgICAgIGRhdGU6ICclQiAlWScsXHJcbiAgICAgICAgbGVnZW5kOiAnJUInLFxyXG4gICAgICAgIGNvbm5lY3RvcjogJ2luJyxcclxuICAgICAgfSxcclxuICAgICAgZXh0cmFjdFVuaXQ6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpKS5nZXRUaW1lKCk7XHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgeWVhcjoge1xyXG4gICAgICBuYW1lOiAneWVhcicsXHJcbiAgICAgIGxldmVsOiA2MCxcclxuICAgICAgcm93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYub3B0aW9ucy5yb3dMaW1pdCB8fCAxO1xyXG4gICAgICB9LFxyXG4gICAgICBjb2x1bW46IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5vcHRpb25zLmNvbExpbWl0IHx8IDE7XHJcbiAgICAgIH0sXHJcbiAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgeDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICB5OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICBmb3JtYXQ6IHtcclxuICAgICAgICBkYXRlOiAnJVknLFxyXG4gICAgICAgIGxlZ2VuZDogJyVZJyxcclxuICAgICAgICBjb25uZWN0b3I6ICdpbicsXHJcbiAgICAgIH0sXHJcbiAgICAgIGV4dHJhY3RVbml0OiBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCkpLmdldFRpbWUoKTtcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLl9kb21haW5UeXBlKSB7XHJcbiAgICBpZiAodGhpcy5fZG9tYWluVHlwZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xyXG4gICAgICB2YXIgZCA9IHRoaXMuX2RvbWFpblR5cGVbdHlwZV07XHJcbiAgICAgIHRoaXMuX2RvbWFpblR5cGVbJ3hfJyArIHR5cGVdID0ge1xyXG4gICAgICAgIG5hbWU6ICd4XycgKyB0eXBlLFxyXG4gICAgICAgIGxldmVsOiBkLnR5cGUsXHJcbiAgICAgICAgbWF4SXRlbU51bWJlcjogZC5tYXhJdGVtTnVtYmVyLFxyXG4gICAgICAgIGRlZmF1bHRSb3dOdW1iZXI6IGQuZGVmYXVsdFJvd051bWJlcixcclxuICAgICAgICBkZWZhdWx0Q29sdW1uTnVtYmVyOiBkLmRlZmF1bHRDb2x1bW5OdW1iZXIsXHJcbiAgICAgICAgcm93OiBkLmNvbHVtbixcclxuICAgICAgICBjb2x1bW46IGQucm93LFxyXG4gICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICB4OiBkLnBvc2l0aW9uLnksXHJcbiAgICAgICAgICB5OiBkLnBvc2l0aW9uLngsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmb3JtYXQ6IGQuZm9ybWF0LFxyXG4gICAgICAgIGV4dHJhY3RVbml0OiBkLmV4dHJhY3RVbml0LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVjb3JkIHRoZSBhZGRyZXNzIG9mIHRoZSBsYXN0IGluc2VydGVkIGRvbWFpbiB3aGVuIGJyb3dzaW5nXHJcbiAgdGhpcy5sYXN0SW5zZXJ0ZWRTdmcgPSBudWxsO1xyXG5cclxuICB0aGlzLl9jb21wbGV0ZWQgPSBmYWxzZTtcclxuXHJcbiAgLy8gUmVjb3JkIGFsbCB0aGUgdmFsaWQgZG9tYWluc1xyXG4gIC8vIEVhY2ggZG9tYWluIHZhbHVlIGlzIGEgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xyXG4gIHRoaXMuX2RvbWFpbnMgPSBkMy5tYXAoKTtcclxuXHJcbiAgdGhpcy5ncmFwaERpbSA9IHtcclxuICAgIHdpZHRoOiAwLFxyXG4gICAgaGVpZ2h0OiAwLFxyXG4gIH07XHJcblxyXG4gIHRoaXMubGVnZW5kRGltID0ge1xyXG4gICAgd2lkdGg6IDAsXHJcbiAgICBoZWlnaHQ6IDAsXHJcbiAgfTtcclxuXHJcbiAgdGhpcy5OQVZJR0FURV9MRUZUID0gMTtcclxuICB0aGlzLk5BVklHQVRFX1JJR0hUID0gMjtcclxuXHJcbiAgLy8gVmFyaW91cyB1cGRhdGUgbW9kZSB3aGVuIHVzaW5nIHRoZSB1cGRhdGUoKSBBUElcclxuICB0aGlzLlJFU0VUX0FMTF9PTl9VUERBVEUgPSAwO1xyXG4gIHRoaXMuUkVTRVRfU0lOR0xFX09OX1VQREFURSA9IDE7XHJcbiAgdGhpcy5BUFBFTkRfT05fVVBEQVRFID0gMjtcclxuXHJcbiAgdGhpcy5ERUZBVUxUX0xFR0VORF9NQVJHSU4gPSAxMDtcclxuXHJcbiAgdGhpcy5yb290ID0gbnVsbDtcclxuICB0aGlzLnRvb2x0aXAgPSBudWxsO1xyXG5cclxuICB0aGlzLl9tYXhEb21haW5SZWFjaGVkID0gZmFsc2U7XHJcbiAgdGhpcy5fbWluRG9tYWluUmVhY2hlZCA9IGZhbHNlO1xyXG5cclxuICB0aGlzLmRvbWFpblBvc2l0aW9uID0gbmV3IERvbWFpblBvc2l0aW9uKCk7XHJcbiAgdGhpcy5MZWdlbmQgPSBudWxsO1xyXG4gIHRoaXMubGVnZW5kU2NhbGUgPSBudWxsO1xyXG5cclxuICAvLyBMaXN0IG9mIGRvbWFpbnMgdGhhdCBhcmUgc2tpcHBlZCBiZWNhdXNlIG9mIERTVFxyXG4gIC8vIEFsbCB0aW1lcyBiZWxvbmdpbmcgdG8gdGhlc2UgZG9tYWlucyBzaG91bGQgYmUgcmUtYXNzaWduZWQgdG8gdGhlIHByZXZpb3VzIGRvbWFpblxyXG4gIHRoaXMuRFNURG9tYWluID0gW107XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BsYXkgdGhlIGdyYXBoIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAqIEByZXR1cm4gYm9vbCBUcnVlIGlmIHRoZSBjYWxlbmRhciBpcyBjcmVhdGVkXHJcbiAgICovXHJcbiAgdGhpcy5faW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHNlbGZcclxuICAgICAgLmdldERvbWFpbihzZWxmLm9wdGlvbnMuc3RhcnQpXHJcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gZC5nZXRUaW1lKCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBzZWxmLl9kb21haW5zLnNldChcclxuICAgICAgICAgIGQsXHJcbiAgICAgICAgICBzZWxmLmdldFN1YkRvbWFpbihkKS5tYXAoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICB0OiBzZWxmLl9kb21haW5UeXBlW3NlbGYub3B0aW9ucy5zdWJEb21haW5dLmV4dHJhY3RVbml0KGQpLFxyXG4gICAgICAgICAgICAgIHY6IG51bGwsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICApO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICBzZWxmLnJvb3QgPSBkM1xyXG4gICAgICAuc2VsZWN0KHNlbGYub3B0aW9ucy5pdGVtU2VsZWN0b3IpXHJcbiAgICAgIC5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsICdjYWwtaGVhdG1hcC1jb250YWluZXInKTtcclxuXHJcbiAgICBzZWxmLnJvb3QuYXR0cigneCcsIDApLmF0dHIoJ3knLCAwKS5hcHBlbmQoJ3N2ZycpLmF0dHIoJ2NsYXNzJywgJ2dyYXBoJyk7XHJcblxyXG4gICAgc2VsZi5MZWdlbmQgPSBuZXcgTGVnZW5kKHNlbGYpO1xyXG5cclxuICAgIGlmIChzZWxmLm9wdGlvbnMucGFpbnRPbkxvYWQpIHtcclxuICAgICAgX2luaXRDYWxlbmRhcigpO1xyXG4gICAgfVxyXG4gICAgc2VsZi5yb290LmNhbGwoc2VsZi50aXApO1xyXG4gICAgc2VsZi5yb290LmNhbGwoc2VsZi5sZWdlbmRUaXApO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIF9pbml0Q2FsZW5kYXIoKSB7XHJcbiAgICBzZWxmLnZlcnRpY2FsRG9tYWluTGFiZWwgPVxyXG4gICAgICBzZWxmLm9wdGlvbnMubGFiZWwucG9zaXRpb24gPT09ICd0b3AnIHx8XHJcbiAgICAgIHNlbGYub3B0aW9ucy5sYWJlbC5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XHJcblxyXG4gICAgc2VsZi5kb21haW5WZXJ0aWNhbExhYmVsSGVpZ2h0ID1cclxuICAgICAgc2VsZi5vcHRpb25zLmxhYmVsLmhlaWdodCA9PT0gbnVsbFxyXG4gICAgICAgID8gTWF0aC5tYXgoMjUsIHNlbGYub3B0aW9ucy5jZWxsU2l6ZSAqIDIpXHJcbiAgICAgICAgOiBzZWxmLm9wdGlvbnMubGFiZWwuaGVpZ2h0O1xyXG4gICAgc2VsZi5kb21haW5Ib3Jpem9udGFsTGFiZWxXaWR0aCA9IDA7XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBzZWxmLm9wdGlvbnMuZG9tYWluTGFiZWxGb3JtYXQgPT09ICcnICYmXHJcbiAgICAgIHNlbGYub3B0aW9ucy5sYWJlbC5oZWlnaHQgPT09IG51bGxcclxuICAgICkge1xyXG4gICAgICBzZWxmLmRvbWFpblZlcnRpY2FsTGFiZWxIZWlnaHQgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghc2VsZi52ZXJ0aWNhbERvbWFpbkxhYmVsKSB7XHJcbiAgICAgIHNlbGYuZG9tYWluVmVydGljYWxMYWJlbEhlaWdodCA9IDA7XHJcbiAgICAgIHNlbGYuZG9tYWluSG9yaXpvbnRhbExhYmVsV2lkdGggPSBzZWxmLm9wdGlvbnMubGFiZWwud2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5wYWludCgpO1xyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG4gICAgLy8gQVRUQUNISU5HIERPTUFJTiBOQVZJR0FUSU9OIEVWRU5UICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcbiAgICBpZiAoc2VsZi5vcHRpb25zLm5leHRTZWxlY3RvciAhPT0gZmFsc2UpIHtcclxuICAgICAgZDMuc2VsZWN0KHNlbGYub3B0aW9ucy5uZXh0U2VsZWN0b3IpLm9uKFxyXG4gICAgICAgICdjbGljay4nICsgc2VsZi5vcHRpb25zLml0ZW1OYW1lc3BhY2UsXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIHJldHVybiBzZWxmLmxvYWROZXh0RG9tYWluKDEpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNlbGYub3B0aW9ucy5wcmV2aW91c1NlbGVjdG9yICE9PSBmYWxzZSkge1xyXG4gICAgICBkMy5zZWxlY3Qoc2VsZi5vcHRpb25zLnByZXZpb3VzU2VsZWN0b3IpLm9uKFxyXG4gICAgICAgICdjbGljay4nICsgc2VsZi5vcHRpb25zLml0ZW1OYW1lc3BhY2UsXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIHJldHVybiBzZWxmLmxvYWRQcmV2aW91c0RvbWFpbigxKTtcclxuICAgICAgICB9LFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGYuTGVnZW5kLnJlZHJhdyhcclxuICAgICAgc2VsZi5ncmFwaERpbS53aWR0aCAtXHJcbiAgICAgICAgc2VsZi5vcHRpb25zLmRvbWFpbkd1dHRlciAtXHJcbiAgICAgICAgc2VsZi5vcHRpb25zLmNlbGxQYWRkaW5nLFxyXG4gICAgKTtcclxuICAgIHNlbGYuYWZ0ZXJMb2FkKCk7XHJcblxyXG4gICAgdmFyIGRvbWFpbnMgPSBzZWxmLmdldERvbWFpbktleXMoKTtcclxuXHJcbiAgICAvLyBGaWxsIHRoZSBncmFwaCB3aXRoIHNvbWUgZGF0YXNcclxuICAgIGlmIChzZWxmLm9wdGlvbnMubG9hZE9uSW5pdCkge1xyXG4gICAgICBzZWxmLmdldERhdGFzKFxyXG4gICAgICAgIHNlbGYub3B0aW9ucy5kYXRhLFxyXG4gICAgICAgIG5ldyBEYXRlKGRvbWFpbnNbMF0pLFxyXG4gICAgICAgIHNlbGYuZ2V0U3ViRG9tYWluKGRvbWFpbnNbZG9tYWlucy5sZW5ndGggLSAxXSkucG9wKCksXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgc2VsZi5maWxsKCk7XHJcbiAgICAgICAgICBzZWxmLm9uQ29tcGxldGUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VsZi5vbkNvbXBsZXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZi5jaGVja0lmTWluRG9tYWluSXNSZWFjaGVkKGRvbWFpbnNbMF0pO1xyXG4gICAgc2VsZi5jaGVja0lmTWF4RG9tYWluSXNSZWFjaGVkKHNlbGYuZ2V0TmV4dERvbWFpbigpLmdldFRpbWUoKSk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSBkb21haW4gYmxvY2ssIHdpdGhvdXQgdGhlIGRvbWFpbiBndXR0ZXJcclxuICAvLyBAcGFyYW0gaW50IGQgRG9tYWluIHN0YXJ0IHRpbWVzdGFtcFxyXG4gIGZ1bmN0aW9uIHcoZCwgb3V0ZXIpIHtcclxuICAgIHZhciB3aWR0aCA9XHJcbiAgICAgIHNlbGYub3B0aW9ucy5jZWxsU2l6ZSAqXHJcbiAgICAgICAgc2VsZi5fZG9tYWluVHlwZVtzZWxmLm9wdGlvbnMuc3ViRG9tYWluXS5jb2x1bW4oZCkgK1xyXG4gICAgICBzZWxmLm9wdGlvbnMuY2VsbFBhZGRpbmcgKlxyXG4gICAgICAgIHNlbGYuX2RvbWFpblR5cGVbc2VsZi5vcHRpb25zLnN1YkRvbWFpbl0uY29sdW1uKGQpO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgb3V0ZXIgPT09IHRydWUpIHtcclxuICAgICAgcmV0dXJuICh3aWR0aCArPVxyXG4gICAgICAgIHNlbGYuZG9tYWluSG9yaXpvbnRhbExhYmVsV2lkdGggK1xyXG4gICAgICAgIHNlbGYub3B0aW9ucy5kb21haW5HdXR0ZXIgK1xyXG4gICAgICAgIHNlbGYub3B0aW9ucy5kb21haW5NYXJnaW5bMV0gK1xyXG4gICAgICAgIHNlbGYub3B0aW9ucy5kb21haW5NYXJnaW5bM10pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIGRvbWFpbiBibG9jaywgd2l0aG91dCB0aGUgZG9tYWluIGd1dHRlclxyXG4gIGZ1bmN0aW9uIGgoZCwgb3V0ZXIpIHtcclxuICAgIHZhciBoZWlnaHQgPVxyXG4gICAgICBzZWxmLm9wdGlvbnMuY2VsbFNpemUgKiBzZWxmLl9kb21haW5UeXBlW3NlbGYub3B0aW9ucy5zdWJEb21haW5dLnJvdyhkKSArXHJcbiAgICAgIHNlbGYub3B0aW9ucy5jZWxsUGFkZGluZyAqXHJcbiAgICAgICAgc2VsZi5fZG9tYWluVHlwZVtzZWxmLm9wdGlvbnMuc3ViRG9tYWluXS5yb3coZCk7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiBvdXRlciA9PT0gdHJ1ZSkge1xyXG4gICAgICBoZWlnaHQgKz1cclxuICAgICAgICBzZWxmLm9wdGlvbnMuZG9tYWluR3V0dGVyICtcclxuICAgICAgICBzZWxmLmRvbWFpblZlcnRpY2FsTGFiZWxIZWlnaHQgK1xyXG4gICAgICAgIHNlbGYub3B0aW9ucy5kb21haW5NYXJnaW5bMF0gK1xyXG4gICAgICAgIHNlbGYub3B0aW9ucy5kb21haW5NYXJnaW5bMl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGVpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICpcclxuICAgKlxyXG4gICAqIEBwYXJhbSBpbnQgbmF2aWdhdGlvbkRpclxyXG4gICAqL1xyXG4gIHRoaXMucGFpbnQgPSBmdW5jdGlvbiAobmF2aWdhdGlvbkRpcikge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBzZWxmLm9wdGlvbnM7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgbmF2aWdhdGlvbkRpciA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBhaW50aW5nIGFsbCB0aGUgZG9tYWluc1xyXG4gICAgdmFyIGRvbWFpblN2ZyA9IHNlbGYucm9vdFxyXG4gICAgICAuc2VsZWN0KCcuZ3JhcGgnKVxyXG4gICAgICAuc2VsZWN0QWxsKCcuZ3JhcGgtZG9tYWluJylcclxuICAgICAgLmRhdGEoXHJcbiAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgdmFyIGRhdGEgPSBzZWxmLmdldERvbWFpbktleXMoKTtcclxuICAgICAgICAgIHJldHVybiBuYXZpZ2F0aW9uRGlyID09PSBzZWxmLk5BVklHQVRFX0xFRlQgPyBkYXRhLnJldmVyc2UoKSA6IGRhdGE7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIGQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgKTtcclxuICAgIHZhciBlbnRlcmluZ0RvbWFpbkRpbSA9IDA7XHJcbiAgICB2YXIgZXhpdGluZ0RvbWFpbkRpbSA9IDA7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcbiAgICAvLyBQQUlOVElORyBET01BSU4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcblxyXG4gICAgdmFyIHN2ZyA9IGRvbWFpblN2Z1xyXG4gICAgICAuZW50ZXIoKVxyXG4gICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiB3KGQsIHRydWUpO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gaChkLCB0cnVlKTtcclxuICAgICAgfSlcclxuICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmIChvcHRpb25zLnZlcnRpY2FsT3JpZW50YXRpb24pIHtcclxuICAgICAgICAgIHNlbGYuZ3JhcGhEaW0ud2lkdGggPSBNYXRoLm1heChzZWxmLmdyYXBoRGltLndpZHRoLCB3KGQsIHRydWUpKTtcclxuICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZ2V0RG9tYWluUG9zaXRpb24oZCwgc2VsZi5ncmFwaERpbSwgJ3dpZHRoJywgdyhkLCB0cnVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmVydGljYWxPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgcmV0dXJuIGdldERvbWFpblBvc2l0aW9uKGQsIHNlbGYuZ3JhcGhEaW0sICdoZWlnaHQnLCBoKGQsIHRydWUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgc2VsZi5ncmFwaERpbS5oZWlnaHQgPSBNYXRoLm1heChzZWxmLmdyYXBoRGltLmhlaWdodCwgaChkLCB0cnVlKSk7XHJcbiAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdmFyIGNsYXNzbmFtZSA9ICdncmFwaC1kb21haW4nO1xyXG4gICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoZCk7XHJcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLmRvbWFpbikge1xyXG4gICAgICAgICAgY2FzZSAnaG91cic6XHJcbiAgICAgICAgICAgIGNsYXNzbmFtZSArPSAnIGhfJyArIGRhdGUuZ2V0SG91cnMoKTtcclxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgICAgIGNsYXNzbmFtZSArPSAnIGRfJyArIGRhdGUuZ2V0RGF0ZSgpICsgJyBkeV8nICsgZGF0ZS5nZXREYXkoKTtcclxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgICAgICBjbGFzc25hbWUgKz0gJyB3XycgKyBzZWxmLmdldFdlZWtOdW1iZXIoZGF0ZSk7XHJcbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgICAgICAgIGNsYXNzbmFtZSArPSAnIG1fJyArIChkYXRlLmdldE1vbnRoKCkgKyAxKTtcclxuICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICAgIGNhc2UgJ3llYXInOlxyXG4gICAgICAgICAgICBjbGFzc25hbWUgKz0gJyB5XycgKyBkYXRlLmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc25hbWU7XHJcbiAgICAgIH0pO1xyXG4gICAgc2VsZi5sYXN0SW5zZXJ0ZWRTdmcgPSBzdmc7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RG9tYWluUG9zaXRpb24oZG9tYWluSW5kZXgsIGdyYXBoRGltLCBheGlzLCBkb21haW5EaW0pIHtcclxuICAgICAgdmFyIHRtcCA9IDA7XHJcbiAgICAgIHN3aXRjaCAobmF2aWdhdGlvbkRpcikge1xyXG4gICAgICAgIGNhc2UgZmFsc2U6XHJcbiAgICAgICAgICB0bXAgPSBncmFwaERpbVtheGlzXTtcclxuXHJcbiAgICAgICAgICBncmFwaERpbVtheGlzXSArPSBkb21haW5EaW07XHJcbiAgICAgICAgICBzZWxmLmRvbWFpblBvc2l0aW9uLnNldFBvc2l0aW9uKGRvbWFpbkluZGV4LCB0bXApO1xyXG4gICAgICAgICAgcmV0dXJuIHRtcDtcclxuXHJcbiAgICAgICAgY2FzZSBzZWxmLk5BVklHQVRFX1JJR0hUOlxyXG4gICAgICAgICAgc2VsZi5kb21haW5Qb3NpdGlvbi5zZXRQb3NpdGlvbihkb21haW5JbmRleCwgZ3JhcGhEaW1bYXhpc10pO1xyXG5cclxuICAgICAgICAgIGVudGVyaW5nRG9tYWluRGltID0gZG9tYWluRGltO1xyXG4gICAgICAgICAgZXhpdGluZ0RvbWFpbkRpbSA9IHNlbGYuZG9tYWluUG9zaXRpb24uZ2V0UG9zaXRpb25Gcm9tSW5kZXgoMSk7XHJcblxyXG4gICAgICAgICAgc2VsZi5kb21haW5Qb3NpdGlvbi5zaGlmdFJpZ2h0QnkoZXhpdGluZ0RvbWFpbkRpbSk7XHJcbiAgICAgICAgICByZXR1cm4gZ3JhcGhEaW1bYXhpc107XHJcblxyXG4gICAgICAgIGNhc2Ugc2VsZi5OQVZJR0FURV9MRUZUOlxyXG4gICAgICAgICAgdG1wID0gLWRvbWFpbkRpbTtcclxuXHJcbiAgICAgICAgICBlbnRlcmluZ0RvbWFpbkRpbSA9IC10bXA7XHJcbiAgICAgICAgICBleGl0aW5nRG9tYWluRGltID0gZ3JhcGhEaW1bYXhpc10gLSBzZWxmLmRvbWFpblBvc2l0aW9uLmdldExhc3QoKTtcclxuXHJcbiAgICAgICAgICBzZWxmLmRvbWFpblBvc2l0aW9uLnNldFBvc2l0aW9uKGRvbWFpbkluZGV4LCB0bXApO1xyXG4gICAgICAgICAgc2VsZi5kb21haW5Qb3NpdGlvbi5zaGlmdExlZnRCeShlbnRlcmluZ0RvbWFpbkRpbSk7XHJcbiAgICAgICAgICByZXR1cm4gdG1wO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3ZnXHJcbiAgICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgICAuYXR0cignd2lkdGgnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiB3KGQsIHRydWUpIC0gb3B0aW9ucy5kb21haW5HdXR0ZXIgLSBvcHRpb25zLmNlbGxQYWRkaW5nO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gaChkLCB0cnVlKSAtIG9wdGlvbnMuZG9tYWluR3V0dGVyIC0gb3B0aW9ucy5jZWxsUGFkZGluZztcclxuICAgICAgfSlcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2RvbWFpbi1iYWNrZ3JvdW5kJyk7XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcbiAgICAvLyBQQUlOVElORyBTVUJET01BSU5TICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cclxuICAgIHZhciBzdWJEb21haW5TdmdHcm91cCA9IHN2Z1xyXG4gICAgICAuYXBwZW5kKCdzdmcnKVxyXG4gICAgICAuYXR0cigneCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5sYWJlbC5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2VsZi5kb21haW5Ib3Jpem9udGFsTGFiZWxXaWR0aCArIG9wdGlvbnMuZG9tYWluTWFyZ2luWzNdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kb21haW5NYXJnaW5bM107XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cigneScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5sYWJlbC5wb3NpdGlvbiA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgIHJldHVybiBzZWxmLmRvbWFpblZlcnRpY2FsTGFiZWxIZWlnaHQgKyBvcHRpb25zLmRvbWFpbk1hcmdpblswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZG9tYWluTWFyZ2luWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLmF0dHIoJ2NsYXNzJywgJ2dyYXBoLXN1YmRvbWFpbi1ncm91cCcpO1xyXG4gICAgdmFyIHJlY3QgPSBzdWJEb21haW5TdmdHcm91cFxyXG4gICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgLmRhdGEoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5fZG9tYWlucy5nZXQoZCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5lbnRlcigpXHJcbiAgICAgIC5hcHBlbmQoJ2cnKTtcclxuICAgIHJlY3RcclxuICAgICAgLmFwcGVuZCgncmVjdCcpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICdncmFwaC1yZWN0JyArXHJcbiAgICAgICAgICBzZWxmLmdldEhpZ2hsaWdodENsYXNzTmFtZShkLnQpICtcclxuICAgICAgICAgIChvcHRpb25zLm9uQ2xpY2sgIT09IG51bGwgPyAnIGhvdmVyX2N1cnNvcicgOiAnJylcclxuICAgICAgICApO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cignd2lkdGgnLCBvcHRpb25zLmNlbGxTaXplKVxyXG4gICAgICAuYXR0cignaGVpZ2h0Jywgb3B0aW9ucy5jZWxsU2l6ZSlcclxuICAgICAgLmF0dHIoJ3gnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLnBvc2l0aW9uU3ViRG9tYWluWChkLnQpO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlbGYucG9zaXRpb25TdWJEb21haW5ZKGQudCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIGlmIChvcHRpb25zLm9uQ2xpY2sgIT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiBzZWxmLm9uQ2xpY2sobmV3IERhdGUoZC50KSwgZC52KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5jYWxsKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5jZWxsUmFkaXVzID4gMCkge1xyXG4gICAgICAgICAgc2VsZWN0aW9uXHJcbiAgICAgICAgICAgIC5hdHRyKCdyeCcsIG9wdGlvbnMuY2VsbFJhZGl1cylcclxuICAgICAgICAgICAgLmF0dHIoJ3J5Jywgb3B0aW9ucy5jZWxsUmFkaXVzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHNlbGYubGVnZW5kU2NhbGUgIT09IG51bGwgJiZcclxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzICE9PSBudWxsICYmXHJcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZENvbG9ycy5oYXNPd25Qcm9wZXJ0eSgnYmFzZScpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICBzZWxlY3Rpb24uYXR0cignZmlsbCcsIG9wdGlvbnMubGVnZW5kQ29sb3JzLmJhc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcCkge1xyXG4gICAgICAgICAgc2VsZWN0aW9uXHJcbiAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICBzZWxmLnRpcC5zaG93KGQsIHRoaXMpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgIHNlbGYudGlwLmhpZGUoZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgLy8gQXBwZW5kaW5nIGEgdGl0bGUgdG8gZWFjaCBzdWJkb21haW5cclxuICAgIGlmICghb3B0aW9ucy50b29sdGlwKSB7XHJcbiAgICAgIHJlY3QuYXBwZW5kKCd0aXRsZScpLnRleHQoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXREYXRlKG5ldyBEYXRlKGQudCksIG9wdGlvbnMuc3ViRG9tYWluRGF0ZUZvcm1hdCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG4gICAgLy8gUEFJTlRJTkcgTEFCRUwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcbiAgICBpZiAob3B0aW9ucy5kb21haW5MYWJlbEZvcm1hdCAhPT0gJycpIHtcclxuICAgICAgc3ZnXHJcbiAgICAgICAgLmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2dyYXBoLWxhYmVsJylcclxuICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICB2YXIgeSA9IG9wdGlvbnMuZG9tYWluTWFyZ2luWzBdO1xyXG4gICAgICAgICAgc3dpdGNoIChvcHRpb25zLmxhYmVsLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgeSArPSBzZWxmLmRvbWFpblZlcnRpY2FsTGFiZWxIZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgIHkgKz0gaChkKSArIHNlbGYuZG9tYWluVmVydGljYWxMYWJlbEhlaWdodCAvIDI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgeSArXHJcbiAgICAgICAgICAgIG9wdGlvbnMubGFiZWwub2Zmc2V0LnkgKlxyXG4gICAgICAgICAgICAgICgob3B0aW9ucy5sYWJlbC5yb3RhdGUgPT09ICdyaWdodCcgJiZcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubGFiZWwucG9zaXRpb24gPT09ICdyaWdodCcpIHx8XHJcbiAgICAgICAgICAgICAgKG9wdGlvbnMubGFiZWwucm90YXRlID09PSAnbGVmdCcgJiZcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubGFiZWwucG9zaXRpb24gPT09ICdsZWZ0JylcclxuICAgICAgICAgICAgICAgID8gLTFcclxuICAgICAgICAgICAgICAgIDogMSlcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICB2YXIgeCA9IG9wdGlvbnMuZG9tYWluTWFyZ2luWzNdO1xyXG4gICAgICAgICAgc3dpdGNoIChvcHRpb25zLmxhYmVsLnBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICB4ICs9IHcoZCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgeCArPSB3KGQpIC8gMjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAob3B0aW9ucy5sYWJlbC5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgIHggK1xyXG4gICAgICAgICAgICAgIHNlbGYuZG9tYWluSG9yaXpvbnRhbExhYmVsV2lkdGggLVxyXG4gICAgICAgICAgICAgIG9wdGlvbnMubGFiZWwub2Zmc2V0LnggKlxyXG4gICAgICAgICAgICAgICAgKG9wdGlvbnMubGFiZWwucm90YXRlID09PSAncmlnaHQnID8gLTEgOiAxKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHggKyBvcHRpb25zLmxhYmVsLm9mZnNldC54O1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3RleHQtYW5jaG9yJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgc3dpdGNoIChvcHRpb25zLmxhYmVsLmFsaWduKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcclxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgcmV0dXJuICdzdGFydCc7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VuZCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICByZXR1cm4gJ2VuZCc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuICdtaWRkbGUnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ2RvbWluYW50LWJhc2VsaW5lJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgcmV0dXJuIHNlbGYudmVydGljYWxEb21haW5MYWJlbCA/ICdtaWRkbGUnIDogJ3RvcCc7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0RGF0ZShuZXcgRGF0ZShkKSwgb3B0aW9ucy5kb21haW5MYWJlbEZvcm1hdCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuY2FsbChkb21haW5Sb3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRvbWFpblJvdGF0ZShzZWxlY3Rpb24pIHtcclxuICAgICAgc3dpdGNoIChvcHRpb25zLmxhYmVsLnJvdGF0ZSkge1xyXG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgIHNlbGVjdGlvbi5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgcyA9ICdyb3RhdGUoOTApLCAnO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMubGFiZWwucG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICBzICs9ICd0cmFuc2xhdGUoLScgKyB3KGQpICsgJyAsIC0nICsgdyhkKSArICcpJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxyXG4gICAgICAgICAgICAgICAgcyArPSAndHJhbnNsYXRlKDAsIC0nICsgc2VsZi5kb21haW5Ib3Jpem9udGFsTGFiZWxXaWR0aCArICcpJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICBzZWxlY3Rpb24uYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSAncm90YXRlKDI3MCksICc7XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3B0aW9ucy5sYWJlbC5wb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgICAgIHMgKz1cclxuICAgICAgICAgICAgICAgICAgJ3RyYW5zbGF0ZSgtJyArXHJcbiAgICAgICAgICAgICAgICAgICh3KGQpICsgc2VsZi5kb21haW5Ib3Jpem9udGFsTGFiZWxXaWR0aCkgK1xyXG4gICAgICAgICAgICAgICAgICAnICwgJyArXHJcbiAgICAgICAgICAgICAgICAgIHcoZCkgK1xyXG4gICAgICAgICAgICAgICAgICAnKSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgIHMgKz1cclxuICAgICAgICAgICAgICAgICAgJ3RyYW5zbGF0ZSgtJyArXHJcbiAgICAgICAgICAgICAgICAgIHNlbGYuZG9tYWluSG9yaXpvbnRhbExhYmVsV2lkdGggK1xyXG4gICAgICAgICAgICAgICAgICAnICwgJyArXHJcbiAgICAgICAgICAgICAgICAgIHNlbGYuZG9tYWluSG9yaXpvbnRhbExhYmVsV2lkdGggK1xyXG4gICAgICAgICAgICAgICAgICAnKSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHM7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcbiAgICAvLyBQQUlOVElORyBET01BSU4gU1VCRE9NQUlOIENPTlRFTlQgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cclxuICAgIGlmIChvcHRpb25zLnN1YkRvbWFpblRleHRGb3JtYXQgIT09IG51bGwpIHtcclxuICAgICAgcmVjdFxyXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gJ3N1YmRvbWFpbi10ZXh0JyArIHNlbGYuZ2V0SGlnaGxpZ2h0Q2xhc3NOYW1lKGQudCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2VsZi5wb3NpdGlvblN1YkRvbWFpblgoZC50KSArIG9wdGlvbnMuY2VsbFNpemUgLyAyO1xyXG4gICAgICAgIH0pXHJcbiAgICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHNlbGYucG9zaXRpb25TdWJEb21haW5ZKGQudCkgKyBvcHRpb25zLmNlbGxTaXplIC8gMjtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5hdHRyKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxyXG4gICAgICAgIC5hdHRyKCdkb21pbmFudC1iYXNlbGluZScsICdjZW50cmFsJylcclxuICAgICAgICAudGV4dChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0RGF0ZShuZXcgRGF0ZShkLnQpLCBvcHRpb25zLnN1YkRvbWFpblRleHRGb3JtYXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG4gICAgLy8gQU5JTUFUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcblxyXG4gICAgaWYgKG5hdmlnYXRpb25EaXIgIT09IGZhbHNlKSB7XHJcbiAgICAgIGRvbWFpblN2Z1xyXG4gICAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgICAuZHVyYXRpb24ob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbilcclxuICAgICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy52ZXJ0aWNhbE9yaWVudGF0aW9uXHJcbiAgICAgICAgICAgID8gMFxyXG4gICAgICAgICAgICA6IHNlbGYuZG9tYWluUG9zaXRpb24uZ2V0UG9zaXRpb24oZCk7XHJcbiAgICAgICAgfSlcclxuICAgICAgICAuYXR0cigneScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy52ZXJ0aWNhbE9yaWVudGF0aW9uXHJcbiAgICAgICAgICAgID8gc2VsZi5kb21haW5Qb3NpdGlvbi5nZXRQb3NpdGlvbihkKVxyXG4gICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRlbXBXaWR0aCA9IHNlbGYuZ3JhcGhEaW0ud2lkdGg7XHJcbiAgICB2YXIgdGVtcEhlaWdodCA9IHNlbGYuZ3JhcGhEaW0uaGVpZ2h0O1xyXG5cclxuICAgIGlmIChvcHRpb25zLnZlcnRpY2FsT3JpZW50YXRpb24pIHtcclxuICAgICAgc2VsZi5ncmFwaERpbS5oZWlnaHQgKz0gZW50ZXJpbmdEb21haW5EaW0gLSBleGl0aW5nRG9tYWluRGltO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VsZi5ncmFwaERpbS53aWR0aCArPSBlbnRlcmluZ0RvbWFpbkRpbSAtIGV4aXRpbmdEb21haW5EaW07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXQgdGhlIHRpbWUgb2YgZXhpdCwgZG9tYWluc1dpZHRoIGFuZCBkb21haW5zSGVpZ2h0IGFscmVhZHkgYXV0b21hdGljYWxseSBzaGlmdGVkXHJcbiAgICBkb21haW5TdmdcclxuICAgICAgLmV4aXQoKVxyXG4gICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgIC5kdXJhdGlvbihvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKVxyXG4gICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmVydGljYWxPcmllbnRhdGlvbikge1xyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN3aXRjaCAobmF2aWdhdGlvbkRpcikge1xyXG4gICAgICAgICAgICBjYXNlIHNlbGYuTkFWSUdBVEVfTEVGVDpcclxuICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oc2VsZi5ncmFwaERpbS53aWR0aCwgdGVtcFdpZHRoKTtcclxuICAgICAgICAgICAgY2FzZSBzZWxmLk5BVklHQVRFX1JJR0hUOlxyXG4gICAgICAgICAgICAgIHJldHVybiAtdyhkLCB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0pXHJcbiAgICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBpZiAob3B0aW9ucy52ZXJ0aWNhbE9yaWVudGF0aW9uKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKG5hdmlnYXRpb25EaXIpIHtcclxuICAgICAgICAgICAgY2FzZSBzZWxmLk5BVklHQVRFX0xFRlQ6XHJcbiAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHNlbGYuZ3JhcGhEaW0uaGVpZ2h0LCB0ZW1wSGVpZ2h0KTtcclxuICAgICAgICAgICAgY2FzZSBzZWxmLk5BVklHQVRFX1JJR0hUOlxyXG4gICAgICAgICAgICAgIHJldHVybiAtaChkLCB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAucmVtb3ZlKCk7XHJcblxyXG4gICAgLy8gUmVzaXplIHRoZSByb290IGNvbnRhaW5lclxyXG4gICAgc2VsZi5yZXNpemUoKTtcclxuICB9O1xyXG59O1xyXG5cclxuQ2FsSGVhdE1hcC5wcm90b3R5cGUgPSB7XHJcbiAgLyoqXHJcbiAgICogVmFsaWRhdGUgYW5kIG1lcmdlIHVzZXIgc2V0dGluZ3Mgd2l0aCBkZWZhdWx0IHNldHRpbmdzXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IHNldHRpbmdzIFVzZXIgc2V0dGluZ3NcclxuICAgKiBAcmV0dXJuIHtib29sfSBGYWxzZSBpZiBzZXR0aW5ncyBjb250YWlucyBlcnJvclxyXG4gICAqL1xyXG4gIC8qIGpzaGludCBtYXhzdGF0ZW1lbnRzOmZhbHNlICovXHJcbiAgaW5pdDogZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XHJcblxyXG4gICAgdmFyIG9wdGlvbnMgPSAocGFyZW50Lm9wdGlvbnMgPSBtZXJnZVJlY3Vyc2l2ZShwYXJlbnQub3B0aW9ucywgc2V0dGluZ3MpKTtcclxuXHJcbiAgICAvLyBGYXRhbCBlcnJvcnNcclxuICAgIC8vIFN0b3Agc2NyaXB0IGV4ZWN1dGlvbiBvbiBlcnJvclxyXG4gICAgdmFsaWRhdGVEb21haW5UeXBlKCk7XHJcbiAgICB2YWxpZGF0ZVNlbGVjdG9yKG9wdGlvbnMuaXRlbVNlbGVjdG9yLCBmYWxzZSwgJ2l0ZW1TZWxlY3RvcicpO1xyXG5cclxuICAgIGlmIChwYXJlbnQuYWxsb3dlZERhdGFUeXBlLmluZGV4T2Yob3B0aW9ucy5kYXRhVHlwZSkgPT09IC0xKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBcIlRoZSBkYXRhIHR5cGUgJ1wiICsgb3B0aW9ucy5kYXRhVHlwZSArIFwiJyBpcyBub3QgdmFsaWQgZGF0YSB0eXBlXCIsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGQzLnNlbGVjdChvcHRpb25zLml0ZW1TZWxlY3RvcilbMF1bMF0gPT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIFwiVGhlIG5vZGUgJ1wiICtcclxuICAgICAgICAgIG9wdGlvbnMuaXRlbVNlbGVjdG9yICtcclxuICAgICAgICAgIFwiJyBzcGVjaWZpZWQgaW4gaXRlbVNlbGVjdG9yIGRvZXMgbm90IGV4aXN0c1wiLFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgIHZhbGlkYXRlU2VsZWN0b3Iob3B0aW9ucy5uZXh0U2VsZWN0b3IsIHRydWUsICduZXh0U2VsZWN0b3InKTtcclxuICAgICAgdmFsaWRhdGVTZWxlY3RvcihvcHRpb25zLnByZXZpb3VzU2VsZWN0b3IsIHRydWUsICdwcmV2aW91c1NlbGVjdG9yJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmxvZyhlcnJvci5tZXNzYWdlKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIG90aGVyIHNldHRpbmdzIGNvbnRhaW5zIGVycm9yLCB3aWxsIGZhbGxiYWNrIHRvIGRlZmF1bHRcclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLmhhc093blByb3BlcnR5KCdzdWJEb21haW4nKSkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMuc3ViRG9tYWluID0gZ2V0T3B0aW1hbFN1YkRvbWFpbihzZXR0aW5ncy5kb21haW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcclxuICAgICAgdHlwZW9mIG9wdGlvbnMuaXRlbU5hbWVzcGFjZSAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgb3B0aW9ucy5pdGVtTmFtZXNwYWNlID09PSAnJ1xyXG4gICAgKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxyXG4gICAgICAgICdpdGVtTmFtZXNwYWNlIGNhbiBub3QgYmUgZW1wdHksIGZhbGxpbmcgYmFjayB0byBjYWwtaGVhdG1hcCcsXHJcbiAgICAgICk7XHJcbiAgICAgIG9wdGlvbnMuaXRlbU5hbWVzcGFjZSA9ICdjYWwtaGVhdG1hcCc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG9uJ3QgdG91Y2ggdGhlc2Ugc2V0dGluZ3NcclxuICAgIHZhciBzID0gW1xyXG4gICAgICAnZGF0YScsXHJcbiAgICAgICdvbkNvbXBsZXRlJyxcclxuICAgICAgJ29uQ2xpY2snLFxyXG4gICAgICAnYWZ0ZXJMb2FkJyxcclxuICAgICAgJ2FmdGVyTG9hZERhdGEnLFxyXG4gICAgICAnYWZ0ZXJMb2FkUHJldmlvdXNEb21haW4nLFxyXG4gICAgICAnYWZ0ZXJMb2FkTmV4dERvbWFpbicsXHJcbiAgICAgICdhZnRlclVwZGF0ZScsXHJcbiAgICBdO1xyXG5cclxuICAgIGZvciAodmFyIGsgaW4gcykge1xyXG4gICAgICBpZiAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoc1trXSkpIHtcclxuICAgICAgICBvcHRpb25zW3Nba11dID0gc2V0dGluZ3Nbc1trXV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvcHRpb25zLnN1YkRvbWFpbkRhdGVGb3JtYXQgPVxyXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5zdWJEb21haW5EYXRlRm9ybWF0ID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5zdWJEb21haW5EYXRlRm9ybWF0ID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgPyBvcHRpb25zLnN1YkRvbWFpbkRhdGVGb3JtYXRcclxuICAgICAgICA6IHRoaXMuX2RvbWFpblR5cGVbb3B0aW9ucy5zdWJEb21haW5dLmZvcm1hdC5kYXRlO1xyXG4gICAgb3B0aW9ucy5kb21haW5MYWJlbEZvcm1hdCA9XHJcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRvbWFpbkxhYmVsRm9ybWF0ID09PSAnc3RyaW5nJyB8fFxyXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5kb21haW5MYWJlbEZvcm1hdCA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgID8gb3B0aW9ucy5kb21haW5MYWJlbEZvcm1hdFxyXG4gICAgICAgIDogdGhpcy5fZG9tYWluVHlwZVtvcHRpb25zLmRvbWFpbl0uZm9ybWF0LmxlZ2VuZDtcclxuICAgIG9wdGlvbnMuc3ViRG9tYWluVGV4dEZvcm1hdCA9XHJcbiAgICAgICh0eXBlb2Ygb3B0aW9ucy5zdWJEb21haW5UZXh0Rm9ybWF0ID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIG9wdGlvbnMuc3ViRG9tYWluVGV4dEZvcm1hdCAhPT0gJycpIHx8XHJcbiAgICAgIHR5cGVvZiBvcHRpb25zLnN1YkRvbWFpblRleHRGb3JtYXQgPT09ICdmdW5jdGlvbidcclxuICAgICAgICA/IG9wdGlvbnMuc3ViRG9tYWluVGV4dEZvcm1hdFxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIG9wdGlvbnMuZG9tYWluTWFyZ2luID0gZXhwYW5kTWFyZ2luU2V0dGluZyhvcHRpb25zLmRvbWFpbk1hcmdpbik7XHJcbiAgICBvcHRpb25zLmxlZ2VuZE1hcmdpbiA9IGV4cGFuZE1hcmdpblNldHRpbmcob3B0aW9ucy5sZWdlbmRNYXJnaW4pO1xyXG4gICAgb3B0aW9ucy5oaWdobGlnaHQgPSBwYXJlbnQuZXhwYW5kRGF0ZVNldHRpbmcob3B0aW9ucy5oaWdobGlnaHQpO1xyXG4gICAgb3B0aW9ucy5pdGVtTmFtZSA9IGV4cGFuZEl0ZW1OYW1lKG9wdGlvbnMuaXRlbU5hbWUpO1xyXG4gICAgb3B0aW9ucy5jb2xMaW1pdCA9IHBhcnNlQ29sTGltaXQob3B0aW9ucy5jb2xMaW1pdCk7XHJcbiAgICBvcHRpb25zLnJvd0xpbWl0ID0gcGFyc2VSb3dMaW1pdChvcHRpb25zLnJvd0xpbWl0KTtcclxuICAgIGlmICghc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2xlZ2VuZE1hcmdpbicpKSB7XHJcbiAgICAgIGF1dG9BZGRMZWdlbmRNYXJnaW4oKTtcclxuICAgIH1cclxuICAgIGF1dG9BbGlnbkxhYmVsKCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSB0aGF0IGEgcXVlcnlTdHJpbmcgaXMgdmFsaWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtFbGVtZW50fHN0cmluZ3xib29sfSBzZWxlY3RvciAgIFRoZSBxdWVyeVN0cmluZyB0byB0ZXN0XHJcbiAgICAgKiBAcGFyYW0gIHtib29sfSAgY2FuQmVGYWxzZSAgV2hldGhlciBmYWxzZSBpcyBhbiBhY2NlcHRlZCBhbmQgdmFsaWQgdmFsdWVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgICBOYW1lIG9mIHRoZSB0ZXN0ZWQgc2VsZWN0b3JcclxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSAgICAgICAgSWYgdGhlIHNlbGVjdG9yIGlzIG5vdCB2YWxpZFxyXG4gICAgICogQHJldHVybiB7Ym9vbH0gICAgICAgIFRydWUgaWYgdGhlIHNlbGVjdG9yIGlzIGEgdmFsaWQgcXVlcnlTdHJpbmdcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTZWxlY3RvcihzZWxlY3RvciwgY2FuQmVGYWxzZSwgbmFtZSkge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgKChjYW5CZUZhbHNlICYmIHNlbGVjdG9yID09PSBmYWxzZSkgfHxcclxuICAgICAgICAgIHNlbGVjdG9yIGluc3RhbmNlb2YgRWxlbWVudCB8fFxyXG4gICAgICAgICAgdHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykgJiZcclxuICAgICAgICBzZWxlY3RvciAhPT0gJydcclxuICAgICAgKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgJyArIG5hbWUgKyAnIGlzIG5vdCB2YWxpZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBvcHRpbWFsIHN1YkRvbWFpbiBmb3IgdGhlIHNwZWNpZmllZCBkb21haW5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGRvbWFpbiBhIGRvbWFpbiBuYW1lXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICB0aGUgc3ViRG9tYWluIG5hbWVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0T3B0aW1hbFN1YkRvbWFpbihkb21haW4pIHtcclxuICAgICAgc3dpdGNoIChkb21haW4pIHtcclxuICAgICAgICBjYXNlICd5ZWFyJzpcclxuICAgICAgICAgIHJldHVybiAnbW9udGgnO1xyXG4gICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgIHJldHVybiAnZGF5JztcclxuICAgICAgICBjYXNlICd3ZWVrJzpcclxuICAgICAgICAgIHJldHVybiAnZGF5JztcclxuICAgICAgICBjYXNlICdkYXknOlxyXG4gICAgICAgICAgcmV0dXJuICdob3VyJztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuICdtaW4nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGUgZG9tYWluIGFuZCBzdWJkb21haW4gYXJlIHZhbGlkXHJcbiAgICAgKlxyXG4gICAgICogQHRocm93IHtFcnJvcn0gd2hlbiBkb21haW4gb3Igc3ViZG9tYWluIGFyZSBub3QgdmFsaWRcclxuICAgICAqIEByZXR1cm4ge2Jvb2x9IFRydWUgaWYgZG9tYWluIGFuZCBzdWJkb21haW4gYXJlIHZhbGlkIGFuZCBjb21wYXRpYmxlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRG9tYWluVHlwZSgpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgICFwYXJlbnQuX2RvbWFpblR5cGUuaGFzT3duUHJvcGVydHkob3B0aW9ucy5kb21haW4pIHx8XHJcbiAgICAgICAgb3B0aW9ucy5kb21haW4gPT09ICdtaW4nIHx8XHJcbiAgICAgICAgb3B0aW9ucy5kb21haW4uc3Vic3RyaW5nKDAsIDIpID09PSAneF8nXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkb21haW4gJ1wiICsgb3B0aW9ucy5kb21haW4gKyBcIicgaXMgbm90IHZhbGlkXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIXBhcmVudC5fZG9tYWluVHlwZS5oYXNPd25Qcm9wZXJ0eShvcHRpb25zLnN1YkRvbWFpbikgfHxcclxuICAgICAgICBvcHRpb25zLnN1YkRvbWFpbiA9PT0gJ3llYXInXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgIFwiVGhlIHN1YkRvbWFpbiAnXCIgKyBvcHRpb25zLnN1YkRvbWFpbiArIFwiJyBpcyBub3QgdmFsaWRcIixcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgcGFyZW50Ll9kb21haW5UeXBlW29wdGlvbnMuZG9tYWluXS5sZXZlbCA8PVxyXG4gICAgICAgIHBhcmVudC5fZG9tYWluVHlwZVtvcHRpb25zLnN1YkRvbWFpbl0ubGV2ZWxcclxuICAgICAgKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgXCInXCIgK1xyXG4gICAgICAgICAgICBvcHRpb25zLnN1YkRvbWFpbiArXHJcbiAgICAgICAgICAgIFwiJyBpcyBub3QgYSB2YWxpZCBzdWJEb21haW4gdG8gJ1wiICtcclxuICAgICAgICAgICAgb3B0aW9ucy5kb21haW4gK1xyXG4gICAgICAgICAgICBcIidcIixcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbmUtdHVuZSB0aGUgbGFiZWwgYWxpZ25lbWVudCBkZXBlbmRpbmcgb24gaXRzIHBvc2l0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB2b2lkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGF1dG9BbGlnbkxhYmVsKCkge1xyXG4gICAgICAvLyBBdXRvLWFsaWduIGxhYmVsLCBkZXBlbmRpbmcgb24gaXQncyBwb3NpdGlvblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgIXNldHRpbmdzLmhhc093blByb3BlcnR5KCdsYWJlbCcpIHx8XHJcbiAgICAgICAgKHNldHRpbmdzLmhhc093blByb3BlcnR5KCdsYWJlbCcpICYmXHJcbiAgICAgICAgICAhc2V0dGluZ3MubGFiZWwuaGFzT3duUHJvcGVydHkoJ2FsaWduJykpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5sYWJlbC5wb3NpdGlvbikge1xyXG4gICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgIG9wdGlvbnMubGFiZWwuYWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcclxuICAgICAgICAgICAgb3B0aW9ucy5sYWJlbC5hbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICBvcHRpb25zLmxhYmVsLmFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5sYWJlbC5yb3RhdGUgPT09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgb3B0aW9ucy5sYWJlbC5hbGlnbiA9ICdyaWdodCc7XHJcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmxhYmVsLnJvdGF0ZSA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgb3B0aW9ucy5sYWJlbC5hbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICAhc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2xhYmVsJykgfHxcclxuICAgICAgICAoc2V0dGluZ3MuaGFzT3duUHJvcGVydHkoJ2xhYmVsJykgJiZcclxuICAgICAgICAgICFzZXR0aW5ncy5sYWJlbC5oYXNPd25Qcm9wZXJ0eSgnb2Zmc2V0JykpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIG9wdGlvbnMubGFiZWwucG9zaXRpb24gPT09ICdsZWZ0JyB8fFxyXG4gICAgICAgICAgb3B0aW9ucy5sYWJlbC5wb3NpdGlvbiA9PT0gJ3JpZ2h0J1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgb3B0aW9ucy5sYWJlbC5vZmZzZXQgPSB7XHJcbiAgICAgICAgICAgIHg6IDEwLFxyXG4gICAgICAgICAgICB5OiAxNSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBhZGQgc29tZSBtYXJnaW4gYXJvdW5kIHRoZSBsZWdlbmQgZGVwZW5kaW5nIG9uIGl0cyBwb3NpdGlvblxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gdm9pZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhdXRvQWRkTGVnZW5kTWFyZ2luKCkge1xyXG4gICAgICBzd2l0Y2ggKG9wdGlvbnMubGVnZW5kVmVydGljYWxQb3NpdGlvbikge1xyXG4gICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZE1hcmdpblsyXSA9IHBhcmVudC5ERUZBVUxUX0xFR0VORF9NQVJHSU47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRNYXJnaW5bMF0gPSBwYXJlbnQuREVGQVVMVF9MRUdFTkRfTUFSR0lOO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRNYXJnaW5bXHJcbiAgICAgICAgICAgIG9wdGlvbnMubGVnZW5kSG9yaXpvbnRhbFBvc2l0aW9uID09PSAncmlnaHQnID8gMyA6IDFcclxuICAgICAgICAgIF0gPSBwYXJlbnQuREVGQVVMVF9MRUdFTkRfTUFSR0lOO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHBhbmQgYSBudW1iZXIgb2YgYW4gYXJyYXkgb2YgbnVtYmVycyB0byBhbiB1c2FibGUgNCB2YWx1ZXMgYXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtpbnRlZ2VyfGFycmF5fSB2YWx1ZVxyXG4gICAgICogQHJldHVybiB7YXJyYXl9ICAgICAgICBhcnJheVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBleHBhbmRNYXJnaW5TZXR0aW5nKHZhbHVlKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdmFsdWUgPSBbdmFsdWVdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ01hcmdpbiBvbmx5IHRha2VzIGFuIGludGVnZXIgb3IgYW4gYXJyYXkgb2YgaW50ZWdlcnMnKTtcclxuICAgICAgICB2YWx1ZSA9IFswXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3dpdGNoICh2YWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICByZXR1cm4gW3ZhbHVlWzBdLCB2YWx1ZVswXSwgdmFsdWVbMF0sIHZhbHVlWzBdXTtcclxuICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICByZXR1cm4gW3ZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMF0sIHZhbHVlWzFdXTtcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICByZXR1cm4gW3ZhbHVlWzBdLCB2YWx1ZVsxXSwgdmFsdWVbMl0sIHZhbHVlWzFdXTtcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgwLCA0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydCBhIHN0cmluZyB0byBhbiBhcnJheSBsaWtlIFtzaW5ndWxhci1mb3JtLCBwbHVyYWwtZm9ybV1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl9IHZhbHVlIERhdGUgdG8gY29udmVydFxyXG4gICAgICogQHJldHVybiB7YXJyYXl9ICAgICAgIEFuIGFycmF5IGxpa2UgW3Npbmd1bGFyLWZvcm0sIHBsdXJhbC1mb3JtXVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBleHBhbmRJdGVtTmFtZSh2YWx1ZSkge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBbdmFsdWUsIHZhbHVlICsgKHZhbHVlICE9PSAnJyA/ICdzJyA6ICcnKV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIHJldHVybiBbdmFsdWVbMF0sIHZhbHVlWzBdICsgJ3MnXTtcclxuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgwLCAyKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIFsnaXRlbScsICdpdGVtcyddO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhcnNlQ29sTGltaXQodmFsdWUpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVJvd0xpbWl0KHZhbHVlKSB7XHJcbiAgICAgIGlmICh2YWx1ZSA+IDAgJiYgb3B0aW9ucy5jb2xMaW1pdCA+IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICdjb2xMaW1pdCBhbmQgcm93TGltaXQgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgcm93TGltaXQgd2lsbCBiZSBpZ25vcmVkJyxcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2luaXQoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDb252ZXJ0IGEga2V5d29yZCBvciBhbiBhcnJheSBvZiBrZXl3b3JkL2RhdGUgdG8gYW4gYXJyYXkgb2YgZGF0ZSBvYmplY3RzXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8YXJyYXl8RGF0ZX0gdmFsdWUgRGF0YSB0byBjb252ZXJ0XHJcbiAgICogQHJldHVybiB7YXJyYXl9ICAgICAgIEFuIGFycmF5IG9mIERhdGVzXHJcbiAgICovXHJcbiAgZXhwYW5kRGF0ZVNldHRpbmc6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgdmFsdWUgPSBbdmFsdWVdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICAubWFwKGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEgPT09ICdub3cnKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9KVxyXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGQgIT09IGZhbHNlO1xyXG4gICAgICB9KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBGaWxsIHRoZSBjYWxlbmRhciBieSBjb2xvcmluZyB0aGUgY2VsbHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhcnJheSBzdmcgQW4gYXJyYXkgb2YgaHRtbCBub2RlIHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm1hdGlvbiB0byAob3B0aW9uYWwpXHJcbiAgICogICAgICAgICAgICAgICAgICBJdCdzIHVzZWQgdG8gbGltaXQgdGhlIHBhaW50aW5nIHRvIG9ubHkgYSBzdWJzZXQgb2YgdGhlIGNhbGVuZGFyXHJcbiAgICogQHJldHVybiB2b2lkXHJcbiAgICovXHJcbiAgZmlsbDogZnVuY3Rpb24gKHN2Zykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gICAgdmFyIG9wdGlvbnMgPSBwYXJlbnQub3B0aW9ucztcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBzdmcgPSBwYXJlbnQucm9vdC5zZWxlY3RBbGwoJy5ncmFwaC1kb21haW4nKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVjdCA9IHN2Z1xyXG4gICAgICAuc2VsZWN0QWxsKCdzdmcnKVxyXG4gICAgICAuc2VsZWN0QWxsKCdnJylcclxuICAgICAgLmRhdGEoZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50Ll9kb21haW5zLmdldChkKTtcclxuICAgICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIENvbG9yaXplIHRoZSBjZWxsIHZpYSBhIHN0eWxlIGF0dHJpYnV0ZSBpZiBlbmFibGVkXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFkZFN0eWxlKGVsZW1lbnQpIHtcclxuICAgICAgaWYgKHBhcmVudC5sZWdlbmRTY2FsZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZWxlbWVudC5hdHRyKCdmaWxsJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBkLnYgPT09IG51bGwgJiZcclxuICAgICAgICAgIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm8nKSAmJlxyXG4gICAgICAgICAgIW9wdGlvbnMuY29uc2lkZXJNaXNzaW5nRGF0YUFzWmVyb1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaWYgKG9wdGlvbnMubGVnZW5kQ29sb3JzLmhhc093blByb3BlcnR5KCdiYXNlJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubGVnZW5kQ29sb3JzLmJhc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZENvbG9ycyAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRDb2xvcnMuaGFzT3duUHJvcGVydHkoJ2VtcHR5JykgJiZcclxuICAgICAgICAgIChkLnYgPT09IDAgfHxcclxuICAgICAgICAgICAgKGQudiA9PT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm8nKSAmJlxyXG4gICAgICAgICAgICAgIG9wdGlvbnMuY29uc2lkZXJNaXNzaW5nRGF0YUFzWmVybykpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5sZWdlbmRDb2xvcnMuZW1wdHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBkLnYgPCAwICYmXHJcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZFswXSA+IDAgJiZcclxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzICE9PSBudWxsICYmXHJcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZENvbG9ycy5oYXNPd25Qcm9wZXJ0eSgnb3ZlcmZsb3cnKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMubGVnZW5kQ29sb3JzLm92ZXJmbG93O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5sZWdlbmRTY2FsZShcclxuICAgICAgICAgIE1hdGgubWluKGQudiwgb3B0aW9ucy5sZWdlbmRbb3B0aW9ucy5sZWdlbmQubGVuZ3RoIC0gMV0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlY3RcclxuICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAuZHVyYXRpb24ob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbilcclxuICAgICAgLnNlbGVjdCgncmVjdCcpXHJcbiAgICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdmFyIGh0bWxDbGFzcyA9IHBhcmVudC5nZXRIaWdobGlnaHRDbGFzc05hbWUoZC50KS50cmltKCkuc3BsaXQoJyAnKTtcclxuICAgICAgICB2YXIgcGFzdERhdGUgPSBwYXJlbnQuZGF0ZUlzTGVzc1RoYW4oZC50LCBuZXcgRGF0ZSgpKTtcclxuICAgICAgICB2YXIgc2FtZURhdGUgPSBwYXJlbnQuZGF0ZUlzRXF1YWwoZC50LCBuZXcgRGF0ZSgpKTtcclxuXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgcGFyZW50LmxlZ2VuZFNjYWxlID09PSBudWxsIHx8XHJcbiAgICAgICAgICAoZC52ID09PSBudWxsICYmXHJcbiAgICAgICAgICAgIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2NvbnNpZGVyTWlzc2luZ0RhdGFBc1plcm8nKSAmJlxyXG4gICAgICAgICAgICAhb3B0aW9ucy5jb25zaWRlck1pc3NpbmdEYXRhQXNaZXJvICYmXHJcbiAgICAgICAgICAgICFvcHRpb25zLmxlZ2VuZENvbG9ycy5oYXNPd25Qcm9wZXJ0eSgnYmFzZScpKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgaHRtbENsYXNzLnB1c2goJ2dyYXBoLXJlY3QnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzYW1lRGF0ZSkge1xyXG4gICAgICAgICAgaHRtbENsYXNzLnB1c2goJ25vdycpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIXBhc3REYXRlKSB7XHJcbiAgICAgICAgICBodG1sQ2xhc3MucHVzaCgnZnV0dXJlJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZC52ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICBodG1sQ2xhc3MucHVzaChcclxuICAgICAgICAgICAgcGFyZW50LkxlZ2VuZC5nZXRDbGFzcyhkLnYsIHBhcmVudC5sZWdlbmRTY2FsZSA9PT0gbnVsbCksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jb25zaWRlck1pc3NpbmdEYXRhQXNaZXJvICYmIHBhc3REYXRlKSB7XHJcbiAgICAgICAgICBodG1sQ2xhc3MucHVzaChcclxuICAgICAgICAgICAgcGFyZW50LkxlZ2VuZC5nZXRDbGFzcygwLCBwYXJlbnQubGVnZW5kU2NhbGUgPT09IG51bGwpLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLm9uQ2xpY2sgIT09IG51bGwpIHtcclxuICAgICAgICAgIGh0bWxDbGFzcy5wdXNoKCdob3Zlcl9jdXJzb3InKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBodG1sQ2xhc3Muam9pbignICcpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2FsbChhZGRTdHlsZSk7XHJcblxyXG4gICAgcmVjdFxyXG4gICAgICAudHJhbnNpdGlvbigpXHJcbiAgICAgIC5kdXJhdGlvbihvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKVxyXG4gICAgICAuc2VsZWN0KCd0aXRsZScpXHJcbiAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudC5nZXRTdWJEb21haW5UaXRsZShkKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gZm9ybWF0U3ViRG9tYWluVGV4dChlbGVtZW50KSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zdWJEb21haW5UZXh0Rm9ybWF0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgZWxlbWVudC50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICByZXR1cm4gb3B0aW9ucy5zdWJEb21haW5UZXh0Rm9ybWF0KGQudCwgZC52KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIHRoZSBzdWJEb21haW5UZXh0IGNsYXNzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICogQWxzbyBjaGFuZ2UgdGhlIHRleHQsIGUuZyB3aGVuIHRleHQgaXMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZVxyXG4gICAgICogaW5zdGVhZCBvZiB0aGUgZGF0ZVxyXG4gICAgICovXHJcbiAgICByZWN0XHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pXHJcbiAgICAgIC5zZWxlY3QoJ3RleHQnKVxyXG4gICAgICAuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiAnc3ViZG9tYWluLXRleHQnICsgcGFyZW50LmdldEhpZ2hsaWdodENsYXNzTmFtZShkLnQpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2FsbChmb3JtYXRTdWJEb21haW5UZXh0KVxyXG4gICAgICAuYXR0cignZmlsbCcsIGQgPT4ge1xyXG4gICAgICAgIGlmICghZC52KSByZXR1cm4gJyMwMDAnO1xyXG4gICAgICAgIGNvbnN0IHJnYiA9IHBhcmVudC5sZWdlbmRTY2FsZShcclxuICAgICAgICAgIE1hdGgubWluKGQudiwgb3B0aW9ucy5sZWdlbmRbb3B0aW9ucy5sZWdlbmQubGVuZ3RoIC0gMV0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGdldENvbnRyYXN0aW5nQ29sb3IocmdiLCAxMzUpO1xyXG4gICAgICB9KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBTcHJpbnRmIGxpa2UgZnVuY3Rpb24uXHJcbiAgICogUmVwbGFjZXMgcGxhY2Vob2xkZXJzIHswfSBpbiBzdHJpbmcgd2l0aCB2YWx1ZXMgZnJvbSBwcm92aWRlZCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RyaW5nIGZvcm1hdHRlZCBTdHJpbmcgY29udGFpbmluZyBwbGFjZWhvbGRlcnMuXHJcbiAgICogQHBhcmFtIG9iamVjdCBhcmdzIE9iamVjdCB3aXRoIHByb3BlcnRpZXMgdG8gcmVwbGFjZSBwbGFjZWhvbGRlcnMgaW4gc3RyaW5nLlxyXG4gICAqXHJcbiAgICogQHJldHVybiBTdHJpbmdcclxuICAgKi9cclxuICBmb3JtYXRTdHJpbmdXaXRoT2JqZWN0OiBmdW5jdGlvbiAoZm9ybWF0dGVkLCBhcmdzKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcbiAgICBmb3IgKHZhciBwcm9wIGluIGFyZ3MpIHtcclxuICAgICAgaWYgKGFyZ3MuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXFxcXHsnICsgcHJvcCArICdcXFxcfScsICdnaScpO1xyXG4gICAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKHJlZ2V4cCwgYXJnc1twcm9wXSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmb3JtYXR0ZWQ7XHJcbiAgfSxcclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcbiAgLy8gRVZFTlRTIENBTExCQUNLICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cclxuXHJcbiAgLyoqXHJcbiAgICogSGVscGVyIG1ldGhvZCBmb3IgdHJpZ2dlcmluZyBldmVudCBjYWxsYmFja1xyXG4gICAqXHJcbiAgICogQHBhcmFtICBzdHJpbmcgIGV2ZW50TmFtZSAgICAgICBOYW1lIG9mIHRoZSBldmVudCB0byB0cmlnZ2VyXHJcbiAgICogQHBhcmFtICBhcnJheSAgc3VjY2Vzc0FyZ3MgICAgIExpc3Qgb2YgYXJndW1lbnQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2tcclxuICAgKiBAcGFyYW0gIGJvb2xlYW4gIHNraXAgICAgICBXaGV0aGVyIHRvIHNraXAgdGhlIGV2ZW50IHRyaWdnZXJpbmdcclxuICAgKiBAcmV0dXJuIG1peGVkICBUcnVlIHdoZW4gdGhlIHRyaWdnZXJpbmcgd2FzIHNraXBwZWQsIGZhbHNlIG9uIGVycm9yLCBlbHNlIHRoZSBjYWxsYmFjayBmdW5jdGlvblxyXG4gICAqL1xyXG4gIHRyaWdnZXJFdmVudDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgc3VjY2Vzc0FyZ3MsIHNraXApIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBpZiAoKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgc2tpcCkgfHwgdGhpcy5vcHRpb25zW2V2ZW50TmFtZV0gPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnNbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBpZiAodHlwZW9mIHN1Y2Nlc3NBcmdzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgc3VjY2Vzc0FyZ3MgPSBzdWNjZXNzQXJncygpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbZXZlbnROYW1lXS5hcHBseSh0aGlzLCBzdWNjZXNzQXJncyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLmxvZygnUHJvdmlkZWQgY2FsbGJhY2sgZm9yICcgKyBldmVudE5hbWUgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uLicpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRXZlbnQgdHJpZ2dlcmVkIG9uIGEgbW91c2UgY2xpY2sgb24gYSBzdWJEb21haW4gY2VsbFxyXG4gICAqXHJcbiAgICogQHBhcmFtICBEYXRlICAgIGQgICAgRGF0ZSBvZiB0aGUgc3ViZG9tYWluIGJsb2NrXHJcbiAgICogQHBhcmFtICBpbnQgICAgaXRlbU5iICBOdW1iZXIgb2YgaXRlbXMgaW4gdGhhdCBkYXRlXHJcbiAgICovXHJcbiAgb25DbGljazogZnVuY3Rpb24gKGQsIGl0ZW1OYikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnRyaWdnZXJFdmVudCgnb25DbGljaycsIFtkLCBpdGVtTmJdKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFdmVudCB0cmlnZ2VyZWQgYWZ0ZXIgZHJhd2luZyB0aGUgY2FsZW5kYXIsIGJ5dCBiZWZvcmUgZmlsbGluZyBpdCB3aXRoIGRhdGFcclxuICAgKi9cclxuICBhZnRlckxvYWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyRXZlbnQoJ2FmdGVyTG9hZCcpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IHRyaWdnZXJlZCBhZnRlciBjb21wbGV0aW5nIGRyYXdpbmcgYW5kIGZpbGxpbmcgdGhlIGNhbGVuZGFyXHJcbiAgICovXHJcbiAgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciByZXNwb25zZSA9IHRoaXMudHJpZ2dlckV2ZW50KCdvbkNvbXBsZXRlJywgW10sIHRoaXMuX2NvbXBsZXRlZCk7XHJcbiAgICB0aGlzLl9jb21wbGV0ZWQgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEV2ZW50IHRyaWdnZXJlZCBhZnRlciBzaGlmdGluZyB0aGUgY2FsZW5kYXIgb25lIGRvbWFpbiBiYWNrXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIERhdGUgICAgc3RhcnQgIERvbWFpbiBzdGFydCBkYXRlXHJcbiAgICogQHBhcmFtICBEYXRlICAgIGVuZCAgICBEb21haW4gZW5kIGRhdGVcclxuICAgKi9cclxuICBhZnRlckxvYWRQcmV2aW91c0RvbWFpbjogZnVuY3Rpb24gKHN0YXJ0KSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XHJcbiAgICByZXR1cm4gdGhpcy50cmlnZ2VyRXZlbnQoJ2FmdGVyTG9hZFByZXZpb3VzRG9tYWluJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc3ViRG9tYWluID0gcGFyZW50LmdldFN1YkRvbWFpbihzdGFydCk7XHJcbiAgICAgIHJldHVybiBbc3ViRG9tYWluLnNoaWZ0KCksIHN1YkRvbWFpbi5wb3AoKV07XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFdmVudCB0cmlnZ2VyZWQgYWZ0ZXIgc2hpZnRpbmcgdGhlIGNhbGVuZGFyIG9uZSBkb21haW4gYWJvdmVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgRGF0ZSAgICBzdGFydCAgRG9tYWluIHN0YXJ0IGRhdGVcclxuICAgKiBAcGFyYW0gIERhdGUgICAgZW5kICAgIERvbWFpbiBlbmQgZGF0ZVxyXG4gICAqL1xyXG4gIGFmdGVyTG9hZE5leHREb21haW46IGZ1bmN0aW9uIChzdGFydCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlckV2ZW50KCdhZnRlckxvYWROZXh0RG9tYWluJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgc3ViRG9tYWluID0gcGFyZW50LmdldFN1YkRvbWFpbihzdGFydCk7XHJcbiAgICAgIHJldHVybiBbc3ViRG9tYWluLnNoaWZ0KCksIHN1YkRvbWFpbi5wb3AoKV07XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFdmVudCB0cmlnZ2VyZWQgYWZ0ZXIgbG9hZGluZyB0aGUgbGVmdG1vc3QgZG9tYWluIGFsbG93ZWQgYnkgbWluRGF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtICBib29sZWFuICByZWFjaGVkIFRydWUgaWYgdGhlIGxlZnRtb3N0IGRvbWFpbiB3YXMgcmVhY2hlZFxyXG4gICAqL1xyXG4gIG9uTWluRG9tYWluUmVhY2hlZDogZnVuY3Rpb24gKHJlYWNoZWQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB0aGlzLl9taW5Eb21haW5SZWFjaGVkID0gcmVhY2hlZDtcclxuICAgIHJldHVybiB0aGlzLnRyaWdnZXJFdmVudCgnb25NaW5Eb21haW5SZWFjaGVkJywgW3JlYWNoZWRdKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFdmVudCB0cmlnZ2VyZWQgYWZ0ZXIgbG9hZGluZyB0aGUgcmlnaHRtb3N0IGRvbWFpbiBhbGxvd2VkIGJ5IG1heERhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgYm9vbGVhbiAgcmVhY2hlZCBUcnVlIGlmIHRoZSByaWdodG1vc3QgZG9tYWluIHdhcyByZWFjaGVkXHJcbiAgICovXHJcbiAgb25NYXhEb21haW5SZWFjaGVkOiBmdW5jdGlvbiAocmVhY2hlZCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHRoaXMuX21heERvbWFpblJlYWNoZWQgPSByZWFjaGVkO1xyXG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlckV2ZW50KCdvbk1heERvbWFpblJlYWNoZWQnLCBbcmVhY2hlZF0pO1xyXG4gIH0sXHJcblxyXG4gIGNoZWNrSWZNaW5Eb21haW5Jc1JlYWNoZWQ6IGZ1bmN0aW9uIChkYXRlLCB1cHBlckJvdW5kKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKHRoaXMubWluRG9tYWluSXNSZWFjaGVkKGRhdGUpKSB7XHJcbiAgICAgIHRoaXMub25NaW5Eb21haW5SZWFjaGVkKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIGlmICh0aGlzLl9tYXhEb21haW5SZWFjaGVkICYmICF0aGlzLm1heERvbWFpbklzUmVhY2hlZCh1cHBlckJvdW5kKSkge1xyXG4gICAgICAgIHRoaXMub25NYXhEb21haW5SZWFjaGVkKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGNoZWNrSWZNYXhEb21haW5Jc1JlYWNoZWQ6IGZ1bmN0aW9uIChkYXRlLCBsb3dlckJvdW5kKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKHRoaXMubWF4RG9tYWluSXNSZWFjaGVkKGRhdGUpKSB7XHJcbiAgICAgIHRoaXMub25NYXhEb21haW5SZWFjaGVkKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgIGlmICh0aGlzLl9taW5Eb21haW5SZWFjaGVkICYmICF0aGlzLm1pbkRvbWFpbklzUmVhY2hlZChsb3dlckJvdW5kKSkge1xyXG4gICAgICAgIHRoaXMub25NaW5Eb21haW5SZWFjaGVkKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGFmdGVyVXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudHJpZ2dlckV2ZW50KCdhZnRlclVwZGF0ZScpO1xyXG4gIH0sXHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG4gIC8vIEZPUk1BVFRFUiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cclxuXHJcbiAgZm9ybWF0TnVtYmVyOiBkMy5mb3JtYXQoJyxnJyksXHJcblxyXG4gIGZvcm1hdERhdGU6IGZ1bmN0aW9uIChkLCBmb3JtYXQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgZm9ybWF0ID0gJ3RpdGxlJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICByZXR1cm4gZm9ybWF0KGQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIGYgPSBkMy50aW1lLmZvcm1hdChmb3JtYXQpO1xyXG4gICAgICByZXR1cm4gZihkKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXRTdWJEb21haW5UaXRsZTogZnVuY3Rpb24gKGQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBpZiAoZC52ID09PSBudWxsICYmICF0aGlzLm9wdGlvbnMuY29uc2lkZXJNaXNzaW5nRGF0YUFzWmVybykge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRTdHJpbmdXaXRoT2JqZWN0KFxyXG4gICAgICAgIHRoaXMub3B0aW9ucy5zdWJEb21haW5UaXRsZUZvcm1hdC5lbXB0eSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBkYXRlOiB0aGlzLmZvcm1hdERhdGUoXHJcbiAgICAgICAgICAgIG5ldyBEYXRlKGQudCksXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdWJEb21haW5EYXRlRm9ybWF0LFxyXG4gICAgICAgICAgKSxcclxuICAgICAgICB9LFxyXG4gICAgICApO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFyIHZhbHVlID0gZC52O1xyXG4gICAgICAvLyBDb25zaWRlciBudWxsIGFzIDBcclxuICAgICAgaWYgKHZhbHVlID09PSBudWxsICYmIHRoaXMub3B0aW9ucy5jb25zaWRlck1pc3NpbmdEYXRhQXNaZXJvKSB7XHJcbiAgICAgICAgdmFsdWUgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5mb3JtYXRTdHJpbmdXaXRoT2JqZWN0KFxyXG4gICAgICAgIHRoaXMub3B0aW9ucy5zdWJEb21haW5UaXRsZUZvcm1hdC5maWxsZWQsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgY291bnQ6IHRoaXMuZm9ybWF0TnVtYmVyKHZhbHVlKSxcclxuICAgICAgICAgIG5hbWU6IHRoaXMub3B0aW9ucy5pdGVtTmFtZVt2YWx1ZSAhPT0gMSA/IDEgOiAwXSxcclxuICAgICAgICAgIGNvbm5lY3RvcjogdGhpcy5fZG9tYWluVHlwZVt0aGlzLm9wdGlvbnMuc3ViRG9tYWluXS5mb3JtYXQuY29ubmVjdG9yLFxyXG4gICAgICAgICAgZGF0ZTogdGhpcy5mb3JtYXREYXRlKFxyXG4gICAgICAgICAgICBuZXcgRGF0ZShkLnQpLFxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3ViRG9tYWluRGF0ZUZvcm1hdCxcclxuICAgICAgICAgICksXHJcbiAgICAgICAgfSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cclxuICAvLyBET01BSU4gTkFWSUdBVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG5cclxuICAvKipcclxuICAgKiBTaGlmdCB0aGUgY2FsZW5kYXIgb25lIGRvbWFpbiBmb3J3YXJkXHJcbiAgICpcclxuICAgKiBUaGUgbmV3IGRvbWFpbiBpcyBsb2FkZWQgb25seSBpZiBpdCdzIG5vdCBiZXlvbmQgbWF4RGF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIGludCBuIE51bWJlciBvZiBkb21haW5zIHRvIGxvYWRcclxuICAgKiBAcmV0dXJuIGJvb2wgVHJ1ZSBpZiB0aGUgbmV4dCBkb21haW4gd2FzIGxvYWRlZCwgZWxzZSBmYWxzZVxyXG4gICAqL1xyXG4gIGxvYWROZXh0RG9tYWluOiBmdW5jdGlvbiAobikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmICh0aGlzLl9tYXhEb21haW5SZWFjaGVkIHx8IG4gPT09IDApIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBib3VuZCA9IHRoaXMubG9hZE5ld0RvbWFpbnMoXHJcbiAgICAgIHRoaXMuTkFWSUdBVEVfUklHSFQsXHJcbiAgICAgIHRoaXMuZ2V0RG9tYWluKHRoaXMuZ2V0TmV4dERvbWFpbigpLCBuKSxcclxuICAgICk7XHJcblxyXG4gICAgdGhpcy5hZnRlckxvYWROZXh0RG9tYWluKGJvdW5kLmVuZCk7XHJcbiAgICB0aGlzLmNoZWNrSWZNYXhEb21haW5Jc1JlYWNoZWQodGhpcy5nZXROZXh0RG9tYWluKCkuZ2V0VGltZSgpLCBib3VuZC5zdGFydCk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2hpZnQgdGhlIGNhbGVuZGFyIG9uZSBkb21haW4gYmFja3dhcmRcclxuICAgKlxyXG4gICAqIFRoZSBwcmV2aW91cyBkb21haW4gaXMgbG9hZGVkIG9ubHkgaWYgaXQncyBub3QgYmV5b25kIHRoZSBtaW5EYXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaW50IG4gTnVtYmVyIG9mIGRvbWFpbnMgdG8gbG9hZFxyXG4gICAqIEByZXR1cm4gYm9vbCBUcnVlIGlmIHRoZSBwcmV2aW91cyBkb21haW4gd2FzIGxvYWRlZCwgZWxzZSBmYWxzZVxyXG4gICAqL1xyXG4gIGxvYWRQcmV2aW91c0RvbWFpbjogZnVuY3Rpb24gKG4pIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBpZiAodGhpcy5fbWluRG9tYWluUmVhY2hlZCB8fCBuID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYm91bmQgPSB0aGlzLmxvYWROZXdEb21haW5zKFxyXG4gICAgICB0aGlzLk5BVklHQVRFX0xFRlQsXHJcbiAgICAgIHRoaXMuZ2V0RG9tYWluKHRoaXMuZ2V0RG9tYWluS2V5cygpWzBdLCAtbikucmV2ZXJzZSgpLFxyXG4gICAgKTtcclxuXHJcbiAgICB0aGlzLmFmdGVyTG9hZFByZXZpb3VzRG9tYWluKGJvdW5kLnN0YXJ0KTtcclxuICAgIHRoaXMuY2hlY2tJZk1pbkRvbWFpbklzUmVhY2hlZChib3VuZC5zdGFydCwgYm91bmQuZW5kKTtcclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9LFxyXG5cclxuICBsb2FkTmV3RG9tYWluczogZnVuY3Rpb24gKGRpcmVjdGlvbiwgbmV3RG9tYWlucykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gICAgdmFyIGJhY2t3YXJkID0gZGlyZWN0aW9uID09PSB0aGlzLk5BVklHQVRFX0xFRlQ7XHJcbiAgICB2YXIgaSA9IC0xO1xyXG4gICAgdmFyIHRvdGFsID0gbmV3RG9tYWlucy5sZW5ndGg7XHJcbiAgICB2YXIgZG9tYWlucyA9IHRoaXMuZ2V0RG9tYWluS2V5cygpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGJ1aWxkU3ViRG9tYWluKGQpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0OiBwYXJlbnQuX2RvbWFpblR5cGVbcGFyZW50Lm9wdGlvbnMuc3ViRG9tYWluXS5leHRyYWN0VW5pdChkKSxcclxuICAgICAgICB2OiBudWxsLFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBvdXQgb2YgYm91bmQgZG9tYWlucyBmcm9tIGxpc3Qgb2YgbmV3IGRvbWFpbnMgdG8gcHJlcGVuZFxyXG4gICAgd2hpbGUgKCsraSA8IHRvdGFsKSB7XHJcbiAgICAgIGlmIChiYWNrd2FyZCAmJiB0aGlzLm1pbkRvbWFpbklzUmVhY2hlZChuZXdEb21haW5zW2ldKSkge1xyXG4gICAgICAgIG5ld0RvbWFpbnMgPSBuZXdEb21haW5zLnNsaWNlKDAsIGkgKyAxKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWJhY2t3YXJkICYmIHRoaXMubWF4RG9tYWluSXNSZWFjaGVkKG5ld0RvbWFpbnNbaV0pKSB7XHJcbiAgICAgICAgbmV3RG9tYWlucyA9IG5ld0RvbWFpbnMuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBuZXdEb21haW5zID0gbmV3RG9tYWlucy5zbGljZSgtdGhpcy5vcHRpb25zLnJhbmdlKTtcclxuXHJcbiAgICBmb3IgKGkgPSAwLCB0b3RhbCA9IG5ld0RvbWFpbnMubGVuZ3RoOyBpIDwgdG90YWw7IGkgKz0gMSkge1xyXG4gICAgICB0aGlzLl9kb21haW5zLnNldChcclxuICAgICAgICBuZXdEb21haW5zW2ldLmdldFRpbWUoKSxcclxuICAgICAgICB0aGlzLmdldFN1YkRvbWFpbihuZXdEb21haW5zW2ldKS5tYXAoYnVpbGRTdWJEb21haW4pLFxyXG4gICAgICApO1xyXG5cclxuICAgICAgdGhpcy5fZG9tYWlucy5yZW1vdmUoYmFja3dhcmQgPyBkb21haW5zLnBvcCgpIDogZG9tYWlucy5zaGlmdCgpKTtcclxuICAgIH1cclxuXHJcbiAgICBkb21haW5zID0gdGhpcy5nZXREb21haW5LZXlzKCk7XHJcblxyXG4gICAgaWYgKGJhY2t3YXJkKSB7XHJcbiAgICAgIG5ld0RvbWFpbnMgPSBuZXdEb21haW5zLnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnBhaW50KGRpcmVjdGlvbik7XHJcblxyXG4gICAgdGhpcy5nZXREYXRhcyhcclxuICAgICAgdGhpcy5vcHRpb25zLmRhdGEsXHJcbiAgICAgIG5ld0RvbWFpbnNbMF0sXHJcbiAgICAgIHRoaXMuZ2V0U3ViRG9tYWluKG5ld0RvbWFpbnNbbmV3RG9tYWlucy5sZW5ndGggLSAxXSkucG9wKCksXHJcbiAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBwYXJlbnQuZmlsbChwYXJlbnQubGFzdEluc2VydGVkU3ZnKTtcclxuICAgICAgfSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhcnQ6IG5ld0RvbWFpbnNbYmFja3dhcmQgPyAwIDogMV0sXHJcbiAgICAgIGVuZDogZG9tYWluc1tkb21haW5zLmxlbmd0aCAtIDFdLFxyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gd2hldGhlciBhIGRhdGUgaXMgaW5zaWRlIHRoZSBzY29wZSBkZXRlcm1pbmVkIGJ5IG1heERhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSBpbnQgZGF0ZXRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIGluIG1zIHRvIHRlc3RcclxuICAgKiBAcmV0dXJuIGJvb2wgVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGRhdGUgY29ycmVzcG9uZCB0byB0aGUgY2FsZW5kYXIgdXBwZXIgYm91bmRcclxuICAgKi9cclxuICBtYXhEb21haW5Jc1JlYWNoZWQ6IGZ1bmN0aW9uIChkYXRldGltZXN0YW1wKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGhpcy5vcHRpb25zLm1heERhdGUgIT09IG51bGwgJiZcclxuICAgICAgdGhpcy5vcHRpb25zLm1heERhdGUuZ2V0VGltZSgpIDwgZGF0ZXRpbWVzdGFtcFxyXG4gICAgKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gd2hldGhlciBhIGRhdGUgaXMgaW5zaWRlIHRoZSBzY29wZSBkZXRlcm1pbmVkIGJ5IG1pbkRhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSBpbnQgZGF0ZXRpbWVzdGFtcCBUaGUgdGltZXN0YW1wIGluIG1zIHRvIHRlc3RcclxuICAgKiBAcmV0dXJuIGJvb2wgVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIGRhdGUgY29ycmVzcG9uZCB0byB0aGUgY2FsZW5kYXIgbG93ZXIgYm91bmRcclxuICAgKi9cclxuICBtaW5Eb21haW5Jc1JlYWNoZWQ6IGZ1bmN0aW9uIChkYXRldGltZXN0YW1wKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGhpcy5vcHRpb25zLm1pbkRhdGUgIT09IG51bGwgJiZcclxuICAgICAgdGhpcy5vcHRpb25zLm1pbkRhdGUuZ2V0VGltZSgpID49IGRhdGV0aW1lc3RhbXBcclxuICAgICk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIHRoZSBjYWxlbmRhcidzIGRvbWFpbiB0aW1lc3RhbXBcclxuICAgKlxyXG4gICAqIEByZXR1cm4gQXJyYXkgYSBzb3J0ZWQgYXJyYXkgb2YgdGltZXN0YW1wXHJcbiAgICovXHJcbiAgZ2V0RG9tYWluS2V5czogZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9kb21haW5zXHJcbiAgICAgIC5rZXlzKClcclxuICAgICAgLm1hcChmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUludChkLCAxMCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEgLSBiO1xyXG4gICAgICB9KTtcclxuICB9LFxyXG5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cclxuICAvLyBQT1NJVElPTk5JTkcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcblxyXG4gIHBvc2l0aW9uU3ViRG9tYWluWDogZnVuY3Rpb24gKGQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9kb21haW5UeXBlW3RoaXMub3B0aW9ucy5zdWJEb21haW5dLnBvc2l0aW9uLngoXHJcbiAgICAgIG5ldyBEYXRlKGQpLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBpbmRleCAqIHRoaXMub3B0aW9ucy5jZWxsU2l6ZSArIGluZGV4ICogdGhpcy5vcHRpb25zLmNlbGxQYWRkaW5nO1xyXG4gIH0sXHJcblxyXG4gIHBvc2l0aW9uU3ViRG9tYWluWTogZnVuY3Rpb24gKGQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9kb21haW5UeXBlW3RoaXMub3B0aW9ucy5zdWJEb21haW5dLnBvc2l0aW9uLnkoXHJcbiAgICAgIG5ldyBEYXRlKGQpLFxyXG4gICAgKTtcclxuICAgIHJldHVybiBpbmRleCAqIHRoaXMub3B0aW9ucy5jZWxsU2l6ZSArIGluZGV4ICogdGhpcy5vcHRpb25zLmNlbGxQYWRkaW5nO1xyXG4gIH0sXHJcblxyXG4gIGdldFN1YkRvbWFpbkNvbHVtbk51bWJlcjogZnVuY3Rpb24gKGQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnJvd0xpbWl0ID4gMCkge1xyXG4gICAgICB2YXIgaSA9IHRoaXMuX2RvbWFpblR5cGVbdGhpcy5vcHRpb25zLnN1YkRvbWFpbl0ubWF4SXRlbU51bWJlcjtcclxuICAgICAgaWYgKHR5cGVvZiBpID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgaSA9IGkoZCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIE1hdGguY2VpbChpIC8gdGhpcy5vcHRpb25zLnJvd0xpbWl0KTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgaiA9IHRoaXMuX2RvbWFpblR5cGVbdGhpcy5vcHRpb25zLnN1YkRvbWFpbl0uZGVmYXVsdENvbHVtbk51bWJlcjtcclxuICAgIGlmICh0eXBlb2YgaiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBqID0gaihkKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY29sTGltaXQgfHwgajtcclxuICB9LFxyXG5cclxuICBnZXRTdWJEb21haW5Sb3dOdW1iZXI6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb2xMaW1pdCA+IDApIHtcclxuICAgICAgdmFyIGkgPSB0aGlzLl9kb21haW5UeXBlW3RoaXMub3B0aW9ucy5zdWJEb21haW5dLm1heEl0ZW1OdW1iZXI7XHJcbiAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGkgPSBpKGQpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBNYXRoLmNlaWwoaSAvIHRoaXMub3B0aW9ucy5jb2xMaW1pdCk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGogPSB0aGlzLl9kb21haW5UeXBlW3RoaXMub3B0aW9ucy5zdWJEb21haW5dLmRlZmF1bHRSb3dOdW1iZXI7XHJcbiAgICBpZiAodHlwZW9mIGogPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgaiA9IGooZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJvd0xpbWl0IHx8IGo7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgY2xhc3NuYW1lIGlmIHRoZSBzcGVjaWZpZWQgZGF0ZSBzaG91bGQgYmUgaGlnaGxpZ2h0ZWRcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgdGltZXN0YW1wIGRhdGUgRGF0ZSBvZiB0aGUgY3VycmVudCBzdWJEb21haW5cclxuICAgKiBAcmV0dXJuIFN0cmluZyB0aGUgaGlnaGxpZ2h0IGNsYXNzXHJcbiAgICovXHJcbiAgZ2V0SGlnaGxpZ2h0Q2xhc3NOYW1lOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGQgPSBuZXcgRGF0ZShkKTtcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLmhpZ2hsaWdodC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5vcHRpb25zLmhpZ2hsaWdodCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGVJc0VxdWFsKHRoaXMub3B0aW9ucy5oaWdobGlnaHRbaV0sIGQpKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5pc05vdyh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0W2ldKVxyXG4gICAgICAgICAgICA/ICcgaGlnaGxpZ2h0LW5vdydcclxuICAgICAgICAgICAgOiAnIGhpZ2hsaWdodCc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBkYXRlIGlzIG5vdyxcclxuICAgKiBhY2NvcmRpbmcgdG8gdGhlIHR5cGUgb2Ygc3ViZG9tYWluXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIERhdGUgZCBUaGUgZGF0ZSB0byBjb21wYXJlXHJcbiAgICogQHJldHVybiBib29sIFRydWUgaWYgdGhlIGRhdGUgY29ycmVzcG9uZCB0byBhIHN1YmRvbWFpbiBjZWxsXHJcbiAgICovXHJcbiAgaXNOb3c6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZGF0ZUlzRXF1YWwoZCwgbmV3IERhdGUoKSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHdoZXRoZXIgMiBkYXRlcyBhcmUgZXF1YWxzXHJcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBzdWJkb21haW4tYXdhcmUsXHJcbiAgICogYW5kIGRhdGVzIGNvbXBhcmlzb24gYXJlIGRlcGVuZGVudCBvZiB0aGUgc3ViZG9tYWluXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIERhdGUgZGF0ZUEgRmlyc3QgZGF0ZSB0byBjb21wYXJlXHJcbiAgICogQHBhcmFtICBEYXRlIGRhdGVCIFNlY29uIGRhdGUgdG8gY29tcGFyZVxyXG4gICAqIEByZXR1cm4gYm9vbCB0cnVlIGlmIHRoZSAyIGRhdGVzIGFyZSBlcXVhbHNcclxuICAgKi9cclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogZmFsc2UgKi9cclxuICBkYXRlSXNFcXVhbDogZnVuY3Rpb24gKGRhdGVBLCBkYXRlQikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmICghKGRhdGVBIGluc3RhbmNlb2YgRGF0ZSkpIHtcclxuICAgICAgZGF0ZUEgPSBuZXcgRGF0ZShkYXRlQSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoZGF0ZUIgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gICAgICBkYXRlQiA9IG5ldyBEYXRlKGRhdGVCKTtcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zdWJEb21haW4pIHtcclxuICAgICAgY2FzZSAneF9taW4nOlxyXG4gICAgICBjYXNlICdtaW4nOlxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICBkYXRlQS5nZXRGdWxsWWVhcigpID09PSBkYXRlQi5nZXRGdWxsWWVhcigpICYmXHJcbiAgICAgICAgICBkYXRlQS5nZXRNb250aCgpID09PSBkYXRlQi5nZXRNb250aCgpICYmXHJcbiAgICAgICAgICBkYXRlQS5nZXREYXRlKCkgPT09IGRhdGVCLmdldERhdGUoKSAmJlxyXG4gICAgICAgICAgZGF0ZUEuZ2V0SG91cnMoKSA9PT0gZGF0ZUIuZ2V0SG91cnMoKSAmJlxyXG4gICAgICAgICAgZGF0ZUEuZ2V0TWludXRlcygpID09PSBkYXRlQi5nZXRNaW51dGVzKClcclxuICAgICAgICApO1xyXG4gICAgICBjYXNlICd4X2hvdXInOlxyXG4gICAgICBjYXNlICdob3VyJzpcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgZGF0ZUEuZ2V0RnVsbFllYXIoKSA9PT0gZGF0ZUIuZ2V0RnVsbFllYXIoKSAmJlxyXG4gICAgICAgICAgZGF0ZUEuZ2V0TW9udGgoKSA9PT0gZGF0ZUIuZ2V0TW9udGgoKSAmJlxyXG4gICAgICAgICAgZGF0ZUEuZ2V0RGF0ZSgpID09PSBkYXRlQi5nZXREYXRlKCkgJiZcclxuICAgICAgICAgIGRhdGVBLmdldEhvdXJzKCkgPT09IGRhdGVCLmdldEhvdXJzKClcclxuICAgICAgICApO1xyXG4gICAgICBjYXNlICd4X2RheSc6XHJcbiAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIGRhdGVBLmdldEZ1bGxZZWFyKCkgPT09IGRhdGVCLmdldEZ1bGxZZWFyKCkgJiZcclxuICAgICAgICAgIGRhdGVBLmdldE1vbnRoKCkgPT09IGRhdGVCLmdldE1vbnRoKCkgJiZcclxuICAgICAgICAgIGRhdGVBLmdldERhdGUoKSA9PT0gZGF0ZUIuZ2V0RGF0ZSgpXHJcbiAgICAgICAgKTtcclxuICAgICAgY2FzZSAneF93ZWVrJzpcclxuICAgICAgY2FzZSAnd2Vlayc6XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgIGRhdGVBLmdldEZ1bGxZZWFyKCkgPT09IGRhdGVCLmdldEZ1bGxZZWFyKCkgJiZcclxuICAgICAgICAgIHRoaXMuZ2V0V2Vla051bWJlcihkYXRlQSkgPT09IHRoaXMuZ2V0V2Vla051bWJlcihkYXRlQilcclxuICAgICAgICApO1xyXG4gICAgICBjYXNlICd4X21vbnRoJzpcclxuICAgICAgY2FzZSAnbW9udGgnOlxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICBkYXRlQS5nZXRGdWxsWWVhcigpID09PSBkYXRlQi5nZXRGdWxsWWVhcigpICYmXHJcbiAgICAgICAgICBkYXRlQS5nZXRNb250aCgpID09PSBkYXRlQi5nZXRNb250aCgpXHJcbiAgICAgICAgKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3ZXRoZXIgb3Igbm90IGRhdGVBIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBkYXRlQi4gVGhpcyBmdW5jdGlvbiBpcyBzdWJkb21haW4gYXdhcmUuXHJcbiAgICogUGVyZm9ybXMgYXV0b21hdGljIGNvbnZlcnNpb24gb2YgdmFsdWVzLlxyXG4gICAqIEBwYXJhbSBkYXRlQSBtYXkgYmUgYSBudW1iZXIgb3IgYSBEYXRlXHJcbiAgICogQHBhcmFtIGRhdGVCIG1heSBiZSBhIG51bWJlciBvciBhIERhdGVcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBkYXRlSXNMZXNzVGhhbjogZnVuY3Rpb24gKGRhdGVBLCBkYXRlQikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmICghKGRhdGVBIGluc3RhbmNlb2YgRGF0ZSkpIHtcclxuICAgICAgZGF0ZUEgPSBuZXcgRGF0ZShkYXRlQSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCEoZGF0ZUIgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gICAgICBkYXRlQiA9IG5ldyBEYXRlKGRhdGVCKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpemVkTWlsbGlzKGRhdGUsIHN1YmRvbWFpbikge1xyXG4gICAgICBzd2l0Y2ggKHN1YmRvbWFpbikge1xyXG4gICAgICAgIGNhc2UgJ3hfbWluJzpcclxuICAgICAgICBjYXNlICdtaW4nOlxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxyXG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0TW9udGgoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXREYXRlKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0SG91cnMoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXRNaW51dGVzKCksXHJcbiAgICAgICAgICApLmdldFRpbWUoKTtcclxuICAgICAgICBjYXNlICd4X2hvdXInOlxyXG4gICAgICAgIGNhc2UgJ2hvdXInOlxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxyXG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0TW9udGgoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXREYXRlKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0SG91cnMoKSxcclxuICAgICAgICAgICkuZ2V0VGltZSgpO1xyXG4gICAgICAgIGNhc2UgJ3hfZGF5JzpcclxuICAgICAgICBjYXNlICdkYXknOlxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxyXG4gICAgICAgICAgICBkYXRlLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgICAgIGRhdGUuZ2V0TW9udGgoKSxcclxuICAgICAgICAgICAgZGF0ZS5nZXREYXRlKCksXHJcbiAgICAgICAgICApLmdldFRpbWUoKTtcclxuICAgICAgICBjYXNlICd4X3dlZWsnOlxyXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgIGNhc2UgJ3hfbW9udGgnOlxyXG4gICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSkuZ2V0VGltZSgpO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICByZXR1cm4gZGF0ZS5nZXRUaW1lKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBub3JtYWxpemVkTWlsbGlzKGRhdGVBLCB0aGlzLm9wdGlvbnMuc3ViRG9tYWluKSA8XHJcbiAgICAgIG5vcm1hbGl6ZWRNaWxsaXMoZGF0ZUIsIHRoaXMub3B0aW9ucy5zdWJEb21haW4pXHJcbiAgICApO1xyXG4gIH0sXHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG4gIC8vIERBVEUgQ09NUFVUQVRJT04gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGRheSBvZiB0aGUgeWVhciBmb3IgdGhlIGRhdGVcclxuICAgKiBAcGFyYW0gIERhdGVcclxuICAgKiBAcmV0dXJuICBpbnQgRGF5IG9mIHRoZSB5ZWFyIFsxLDM2Nl1cclxuICAgKi9cclxuICBnZXREYXlPZlllYXI6IGQzLnRpbWUuZm9ybWF0KCclaicpLFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHdlZWsgbnVtYmVyIG9mIHRoZSB5ZWFyXHJcbiAgICogTW9uZGF5IGFzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWtcclxuICAgKiBAcmV0dXJuIGludCAgV2VlayBudW1iZXIgWzAtNTNdXHJcbiAgICovXHJcbiAgZ2V0V2Vla051bWJlcjogZnVuY3Rpb24gKGQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICB2YXIgZiA9XHJcbiAgICAgIHRoaXMub3B0aW9ucy53ZWVrU3RhcnRPbk1vbmRheSA9PT0gdHJ1ZVxyXG4gICAgICAgID8gZDMudGltZS5mb3JtYXQoJyVXJylcclxuICAgICAgICA6IGQzLnRpbWUuZm9ybWF0KCclVScpO1xyXG4gICAgcmV0dXJuIGYoZCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSB3ZWVrIG51bWJlciwgcmVsYXRpdmUgdG8gaXRzIG1vbnRoXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIGludHxEYXRlIGQgRGF0ZSBvciB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICogQHJldHVybiBpbnQgV2VlayBudW1iZXIsIHJlbGF0aXZlIHRvIHRoZSBtb250aCBbMC01XVxyXG4gICAqL1xyXG4gIGdldE1vbnRoV2Vla051bWJlcjogZnVuY3Rpb24gKGQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGQgPSBuZXcgRGF0ZShkKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbW9udGhGaXJzdFdlZWtOdW1iZXIgPSB0aGlzLmdldFdlZWtOdW1iZXIoXHJcbiAgICAgIG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpKSxcclxuICAgICk7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRXZWVrTnVtYmVyKGQpIC0gbW9udGhGaXJzdFdlZWtOdW1iZXIgLSAxO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoZSBkYXRlcycgeWVhclxyXG4gICAqXHJcbiAgICogQHBhcmFtICBpbnR8RGF0ZSBkIERhdGUgb3IgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xyXG4gICAqIEByZXR1cm4gaW50IE51bWJlciBvZiB3ZWVrcyBpbiB0aGUgZGF0ZSdzIHllYXJcclxuICAgKi9cclxuICBnZXRXZWVrTnVtYmVySW5ZZWFyOiBmdW5jdGlvbiAoZCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgZCA9IG5ldyBEYXRlKGQpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGRheXMgaW4gdGhlIGRhdGUncyBtb250aFxyXG4gICAqXHJcbiAgICogQHBhcmFtICBpbnR8RGF0ZSBkIERhdGUgb3IgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xyXG4gICAqIEByZXR1cm4gaW50IE51bWJlciBvZiBkYXlzIGluIHRoZSBkYXRlJ3MgbW9udGhcclxuICAgKi9cclxuICBnZXREYXlDb3VudEluTW9udGg6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RW5kT2ZNb250aChkKS5nZXREYXRlKCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgZGF0ZSdzIHllYXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgaW50fERhdGUgZCBEYXRlIG9yIHRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHNcclxuICAgKiBAcmV0dXJuIGludCBOdW1iZXIgb2YgZGF5cyBpbiB0aGUgZGF0ZSdzIHllYXJcclxuICAgKi9cclxuICBnZXREYXlDb3VudEluWWVhcjogZnVuY3Rpb24gKGQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGQgPSBuZXcgRGF0ZShkKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDEsIDI5KS5nZXRNb250aCgpID09PSAxID8gMzY2IDogMzY1O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgd2Vla2RheSBmcm9tIGEgZGF0ZVxyXG4gICAqXHJcbiAgICogUmV0dXJuIHRoZSB3ZWVrIGRheSBudW1iZXIgKDAtNikgb2YgYSBkYXRlLFxyXG4gICAqIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSB3ZWVrIHN0YXJ0IG9uIG1vbmRheSBvciBzdW5kYXlcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgRGF0ZSBkXHJcbiAgICogQHJldHVybiBpbnQgVGhlIHdlZWsgZGF5IG51bWJlciAoMC02KVxyXG4gICAqL1xyXG4gIGdldFdlZWtEYXk6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy53ZWVrU3RhcnRPbk1vbmRheSA9PT0gZmFsc2UpIHtcclxuICAgICAgcmV0dXJuIGQuZ2V0RGF5KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZC5nZXREYXkoKSA9PT0gMCA/IDYgOiBkLmdldERheSgpIC0gMTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3QgZGF5IG9mIHRoZSBtb250aFxyXG4gICAqIEBwYXJhbSAgRGF0ZXxpbnQgIGQgIERhdGUgb3IgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kc1xyXG4gICAqIEByZXR1cm4gRGF0ZSAgICAgIExhc3QgZGF5IG9mIHRoZSBtb250aFxyXG4gICAqL1xyXG4gIGdldEVuZE9mTW9udGg6IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJykge1xyXG4gICAgICBkID0gbmV3IERhdGUoZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkgKyAxLCAwKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgRGF0ZSBkYXRlXHJcbiAgICogQHBhcmFtICBpbnQgY291bnRcclxuICAgKiBAcGFyYW0gIHN0cmluZyBzdGVwXHJcbiAgICogQHJldHVybiBEYXRlXHJcbiAgICovXHJcbiAganVtcERhdGU6IGZ1bmN0aW9uIChkYXRlLCBjb3VudCwgc3RlcCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBkID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgICBzd2l0Y2ggKHN0ZXApIHtcclxuICAgICAgY2FzZSAnaG91cic6XHJcbiAgICAgICAgZC5zZXRIb3VycyhkLmdldEhvdXJzKCkgKyBjb3VudCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgZC5zZXRIb3VycyhkLmdldEhvdXJzKCkgKyBjb3VudCAqIDI0KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAnd2Vlayc6XHJcbiAgICAgICAgZC5zZXRIb3VycyhkLmdldEhvdXJzKCkgKyBjb3VudCAqIDI0ICogNyk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICBkLnNldE1vbnRoKGQuZ2V0TW9udGgoKSArIGNvdW50KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgZC5zZXRGdWxsWWVhcihkLmdldEZ1bGxZZWFyKCkgKyBjb3VudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5ldyBEYXRlKGQpO1xyXG4gIH0sXHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG4gIC8vIERPTUFJTiBDT01QVVRBVElPTiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYWxsIHRoZSBtaW51dGVzIGJldHdlZW4gMiBkYXRlc1xyXG4gICAqXHJcbiAgICogQHBhcmFtICBEYXRlICBkICBkYXRlICBBIGRhdGVcclxuICAgKiBAcGFyYW0gIGludHxkYXRlICByYW5nZSAgTnVtYmVyIG9mIG1pbnV0ZXMgaW4gdGhlIHJhbmdlLCBvciBhIHN0b3AgZGF0ZVxyXG4gICAqIEByZXR1cm4gYXJyYXkgIEFuIGFycmF5IG9mIG1pbnV0ZXNcclxuICAgKi9cclxuICBnZXRNaW51dGVEb21haW46IGZ1bmN0aW9uIChkLCByYW5nZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKFxyXG4gICAgICBkLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgIGQuZ2V0TW9udGgoKSxcclxuICAgICAgZC5nZXREYXRlKCksXHJcbiAgICAgIGQuZ2V0SG91cnMoKSxcclxuICAgICk7XHJcbiAgICB2YXIgc3RvcCA9IG51bGw7XHJcbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShcclxuICAgICAgICByYW5nZS5nZXRGdWxsWWVhcigpLFxyXG4gICAgICAgIHJhbmdlLmdldE1vbnRoKCksXHJcbiAgICAgICAgcmFuZ2UuZ2V0RGF0ZSgpLFxyXG4gICAgICAgIHJhbmdlLmdldEhvdXJzKCksXHJcbiAgICAgICk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdG9wID0gbmV3IERhdGUoK3N0YXJ0ICsgcmFuZ2UgKiAxMDAwICogNjApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGQzLnRpbWUubWludXRlcyhNYXRoLm1pbihzdGFydCwgc3RvcCksIE1hdGgubWF4KHN0YXJ0LCBzdG9wKSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGFsbCB0aGUgaG91cnMgYmV0d2VlbiAyIGRhdGVzXHJcbiAgICpcclxuICAgKiBAcGFyYW0gIERhdGUgIGQgIEEgZGF0ZVxyXG4gICAqIEBwYXJhbSAgaW50fGRhdGUgIHJhbmdlICBOdW1iZXIgb2YgaG91cnMgaW4gdGhlIHJhbmdlLCBvciBhIHN0b3AgZGF0ZVxyXG4gICAqIEByZXR1cm4gYXJyYXkgIEFuIGFycmF5IG9mIGhvdXJzXHJcbiAgICovXHJcbiAgZ2V0SG91ckRvbWFpbjogZnVuY3Rpb24gKGQsIHJhbmdlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoXHJcbiAgICAgIGQuZ2V0RnVsbFllYXIoKSxcclxuICAgICAgZC5nZXRNb250aCgpLFxyXG4gICAgICBkLmdldERhdGUoKSxcclxuICAgICAgZC5nZXRIb3VycygpLFxyXG4gICAgKTtcclxuICAgIHZhciBzdG9wID0gbnVsbDtcclxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgc3RvcCA9IG5ldyBEYXRlKFxyXG4gICAgICAgIHJhbmdlLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgcmFuZ2UuZ2V0TW9udGgoKSxcclxuICAgICAgICByYW5nZS5nZXREYXRlKCksXHJcbiAgICAgICAgcmFuZ2UuZ2V0SG91cnMoKSxcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShzdGFydCk7XHJcbiAgICAgIHN0b3Auc2V0SG91cnMoc3RvcC5nZXRIb3VycygpICsgcmFuZ2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkb21haW5zID0gZDMudGltZS5ob3VycyhNYXRoLm1pbihzdGFydCwgc3RvcCksIE1hdGgubWF4KHN0YXJ0LCBzdG9wKSk7XHJcblxyXG4gICAgLy8gUGFzc2luZyBmcm9tIERTVCB0byBzdGFuZGFyZCB0aW1lXHJcbiAgICAvLyBJZiB0aGVyZSBhcmUgMjUgaG91cnMsIGxldCdzIGNvbXByZXNzIHRoZSBkdXBsaWNhdGUgaG91cnNcclxuICAgIHZhciBpID0gMDtcclxuICAgIHZhciB0b3RhbCA9IGRvbWFpbnMubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsOyBpICs9IDEpIHtcclxuICAgICAgaWYgKGkgPiAwICYmIGRvbWFpbnNbaV0uZ2V0SG91cnMoKSA9PT0gZG9tYWluc1tpIC0gMV0uZ2V0SG91cnMoKSkge1xyXG4gICAgICAgIHRoaXMuRFNURG9tYWluLnB1c2goZG9tYWluc1tpXS5nZXRUaW1lKCkpO1xyXG4gICAgICAgIGRvbWFpbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZDMudGltZS5ob3VycyBpcyByZXR1cm5pbmcgbW9yZSBob3VycyB0aGFuIG5lZWRlZCB3aGVuIGNoYW5naW5nXHJcbiAgICAvLyBmcm9tIERTVCB0byBzdGFuZGFyZCB0aW1lLCBiZWNhdXNlIHRoZXJlIGlzIHJlYWxseSAyIGhvdXJzIGJldHdlZW5cclxuICAgIC8vIDFhbSBhbmQgMmFtIVxyXG4gICAgaWYgKHR5cGVvZiByYW5nZSA9PT0gJ251bWJlcicgJiYgZG9tYWlucy5sZW5ndGggPiBNYXRoLmFicyhyYW5nZSkpIHtcclxuICAgICAgZG9tYWlucy5zcGxpY2UoZG9tYWlucy5sZW5ndGggLSAxLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZG9tYWlucztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYWxsIHRoZSBkYXlzIGJldHdlZW4gMiBkYXRlc1xyXG4gICAqXHJcbiAgICogQHBhcmFtICBEYXRlICAgIGQgICAgQSBkYXRlXHJcbiAgICogQHBhcmFtICBpbnR8ZGF0ZSAgcmFuZ2UgIE51bWJlciBvZiBkYXlzIGluIHRoZSByYW5nZSwgb3IgYSBzdG9wIGRhdGVcclxuICAgKiBAcmV0dXJuIGFycmF5ICBBbiBhcnJheSBvZiB3ZWVrc1xyXG4gICAqL1xyXG4gIGdldERheURvbWFpbjogZnVuY3Rpb24gKGQsIHJhbmdlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcclxuICAgIHZhciBzdG9wID0gbnVsbDtcclxuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgc3RvcCA9IG5ldyBEYXRlKHJhbmdlLmdldEZ1bGxZZWFyKCksIHJhbmdlLmdldE1vbnRoKCksIHJhbmdlLmdldERhdGUoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdG9wID0gbmV3IERhdGUoc3RhcnQpO1xyXG4gICAgICBzdG9wID0gbmV3IERhdGUoc3RvcC5zZXREYXRlKHN0b3AuZ2V0RGF0ZSgpICsgcGFyc2VJbnQocmFuZ2UsIDEwKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkMy50aW1lLmRheXMoTWF0aC5taW4oc3RhcnQsIHN0b3ApLCBNYXRoLm1heChzdGFydCwgc3RvcCkpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbGwgdGhlIHdlZWtzIGJldHdlZW4gMiBkYXRlc1xyXG4gICAqXHJcbiAgICogQHBhcmFtICBEYXRlICBkICBBIGRhdGVcclxuICAgKiBAcGFyYW0gIGludHxkYXRlICByYW5nZSAgTnVtYmVyIG9mIG1pbnV0ZXMgaW4gdGhlIHJhbmdlLCBvciBhIHN0b3AgZGF0ZVxyXG4gICAqIEByZXR1cm4gYXJyYXkgIEFuIGFycmF5IG9mIHdlZWtzXHJcbiAgICovXHJcbiAgZ2V0V2Vla0RvbWFpbjogZnVuY3Rpb24gKGQsIHJhbmdlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIHdlZWtTdGFydDtcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLndlZWtTdGFydE9uTW9uZGF5ID09PSBmYWxzZSkge1xyXG4gICAgICB3ZWVrU3RhcnQgPSBuZXcgRGF0ZShcclxuICAgICAgICBkLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgZC5nZXRNb250aCgpLFxyXG4gICAgICAgIGQuZ2V0RGF0ZSgpIC0gZC5nZXREYXkoKSxcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChkLmdldERheSgpID09PSAxKSB7XHJcbiAgICAgICAgd2Vla1N0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcclxuICAgICAgfSBlbHNlIGlmIChkLmdldERheSgpID09PSAwKSB7XHJcbiAgICAgICAgd2Vla1N0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpKTtcclxuICAgICAgICB3ZWVrU3RhcnQuc2V0RGF0ZSh3ZWVrU3RhcnQuZ2V0RGF0ZSgpIC0gNik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgd2Vla1N0YXJ0ID0gbmV3IERhdGUoXHJcbiAgICAgICAgICBkLmdldEZ1bGxZZWFyKCksXHJcbiAgICAgICAgICBkLmdldE1vbnRoKCksXHJcbiAgICAgICAgICBkLmdldERhdGUoKSAtIGQuZ2V0RGF5KCkgKyAxLFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZW5kRGF0ZSA9IG5ldyBEYXRlKHdlZWtTdGFydCk7XHJcblxyXG4gICAgdmFyIHN0b3AgPSByYW5nZTtcclxuICAgIGlmICh0eXBlb2YgcmFuZ2UgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShlbmREYXRlLnNldERhdGUoZW5kRGF0ZS5nZXREYXRlKCkgKyByYW5nZSAqIDcpKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLndlZWtTdGFydE9uTW9uZGF5ID09PSB0cnVlXHJcbiAgICAgID8gZDMudGltZS5tb25kYXlzKE1hdGgubWluKHdlZWtTdGFydCwgc3RvcCksIE1hdGgubWF4KHdlZWtTdGFydCwgc3RvcCkpXHJcbiAgICAgIDogZDMudGltZS5zdW5kYXlzKE1hdGgubWluKHdlZWtTdGFydCwgc3RvcCksIE1hdGgubWF4KHdlZWtTdGFydCwgc3RvcCkpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbGwgdGhlIG1vbnRocyBiZXR3ZWVuIDIgZGF0ZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgRGF0ZSAgICBkICAgIEEgZGF0ZVxyXG4gICAqIEBwYXJhbSAgaW50fGRhdGUgIHJhbmdlICBOdW1iZXIgb2YgbW9udGhzIGluIHRoZSByYW5nZSwgb3IgYSBzdG9wIGRhdGVcclxuICAgKiBAcmV0dXJuIGFycmF5ICBBbiBhcnJheSBvZiBtb250aHNcclxuICAgKi9cclxuICBnZXRNb250aERvbWFpbjogZnVuY3Rpb24gKGQsIHJhbmdlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCkpO1xyXG4gICAgdmFyIHN0b3AgPSBudWxsO1xyXG4gICAgaWYgKHJhbmdlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICBzdG9wID0gbmV3IERhdGUocmFuZ2UuZ2V0RnVsbFllYXIoKSwgcmFuZ2UuZ2V0TW9udGgoKSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdG9wID0gbmV3IERhdGUoc3RhcnQpO1xyXG4gICAgICBzdG9wID0gc3RvcC5zZXRNb250aChzdG9wLmdldE1vbnRoKCkgKyByYW5nZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGQzLnRpbWUubW9udGhzKE1hdGgubWluKHN0YXJ0LCBzdG9wKSwgTWF0aC5tYXgoc3RhcnQsIHN0b3ApKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYWxsIHRoZSB5ZWFycyBiZXR3ZWVuIDIgZGF0ZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgRGF0ZSAgZCAgZGF0ZSAgQSBkYXRlXHJcbiAgICogQHBhcmFtICBpbnR8ZGF0ZSAgcmFuZ2UgIE51bWJlciBvZiBtaW51dGVzIGluIHRoZSByYW5nZSwgb3IgYSBzdG9wIGRhdGVcclxuICAgKiBAcmV0dXJuIGFycmF5ICBBbiBhcnJheSBvZiBob3Vyc1xyXG4gICAqL1xyXG4gIGdldFllYXJEb21haW46IGZ1bmN0aW9uIChkLCByYW5nZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgMCk7XHJcbiAgICB2YXIgc3RvcCA9IG51bGw7XHJcbiAgICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShyYW5nZS5nZXRGdWxsWWVhcigpLCAwKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHN0b3AgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCkgKyByYW5nZSwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGQzLnRpbWUueWVhcnMoTWF0aC5taW4oc3RhcnQsIHN0b3ApLCBNYXRoLm1heChzdGFydCwgc3RvcCkpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBhbiBhcnJheSBvZiBkb21haW4gc3RhcnQgZGF0ZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgaW50fERhdGUgZGF0ZSBBIHJhbmRvbSBkYXRlIGluY2x1ZGVkIGluIHRoZSB3YW50ZWQgZG9tYWluXHJcbiAgICogQHBhcmFtICBpbnR8RGF0ZSByYW5nZSBOdW1iZXIgb2YgZGF0ZXMgdG8gZ2V0LCBvciBhIHN0b3AgZGF0ZVxyXG4gICAqIEByZXR1cm4gQXJyYXkgb2YgZGF0ZXNcclxuICAgKi9cclxuICBnZXREb21haW46IGZ1bmN0aW9uIChkYXRlLCByYW5nZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xyXG4gICAgICByYW5nZSA9IHRoaXMub3B0aW9ucy5yYW5nZTtcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5kb21haW4pIHtcclxuICAgICAgY2FzZSAnaG91cic6XHJcbiAgICAgICAgdmFyIGRvbWFpbnMgPSB0aGlzLmdldEhvdXJEb21haW4oZGF0ZSwgcmFuZ2UpO1xyXG5cclxuICAgICAgICAvLyBDYXNlIHdoZXJlIGFuIGhvdXIgaXMgbWlzc2luZywgd2hlbiBwYXNzaW5nIGZyb20gc3RhbmRhcmQgdGltZSB0byBEU1RcclxuICAgICAgICAvLyBNaXNzaW5nIGhvdXIgaXMgcGVyZmVjdGx5IGFjY2VwdGFibCBpbiBzdWJEb21haW4sIGJ1dCBub3QgaW4gZG9tYWluc1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmFuZ2UgPT09ICdudW1iZXInICYmIGRvbWFpbnMubGVuZ3RoIDwgcmFuZ2UpIHtcclxuICAgICAgICAgIGlmIChyYW5nZSA+IDApIHtcclxuICAgICAgICAgICAgZG9tYWlucy5wdXNoKHRoaXMuZ2V0SG91ckRvbWFpbihkb21haW5zW2RvbWFpbnMubGVuZ3RoIC0gMV0sIDIpWzFdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRvbWFpbnMuc2hpZnQodGhpcy5nZXRIb3VyRG9tYWluKGRvbWFpbnNbMF0sIC0yKVswXSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkb21haW5zO1xyXG4gICAgICBjYXNlICdkYXknOlxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldERheURvbWFpbihkYXRlLCByYW5nZSk7XHJcbiAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdlZWtEb21haW4oZGF0ZSwgcmFuZ2UpO1xyXG4gICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9udGhEb21haW4oZGF0ZSwgcmFuZ2UpO1xyXG4gICAgICBjYXNlICd5ZWFyJzpcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRZZWFyRG9tYWluKGRhdGUsIHJhbmdlKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogZmFsc2UgKi9cclxuICBnZXRTdWJEb21haW46IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykge1xyXG4gICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhcmVudCA9IHRoaXM7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGludFxyXG4gICAgICovXHJcbiAgICB2YXIgY29tcHV0ZURheVN1YkRvbWFpblNpemUgPSBmdW5jdGlvbiAoZGF0ZSwgZG9tYWluKSB7XHJcbiAgICAgIHN3aXRjaCAoZG9tYWluKSB7XHJcbiAgICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmdldERheUNvdW50SW5ZZWFyKGRhdGUpO1xyXG4gICAgICAgIGNhc2UgJ21vbnRoJzpcclxuICAgICAgICAgIHJldHVybiBwYXJlbnQuZ2V0RGF5Q291bnRJbk1vbnRoKGRhdGUpO1xyXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgICAgcmV0dXJuIDc7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGludFxyXG4gICAgICovXHJcbiAgICB2YXIgY29tcHV0ZU1pblN1YkRvbWFpblNpemUgPSBmdW5jdGlvbiAoZGF0ZSwgZG9tYWluKSB7XHJcbiAgICAgIHN3aXRjaCAoZG9tYWluKSB7XHJcbiAgICAgICAgY2FzZSAnaG91cic6XHJcbiAgICAgICAgICByZXR1cm4gNjA7XHJcbiAgICAgICAgY2FzZSAnZGF5JzpcclxuICAgICAgICAgIHJldHVybiA2MCAqIDI0O1xyXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgICAgcmV0dXJuIDYwICogMjQgKiA3O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBpbnRcclxuICAgICAqL1xyXG4gICAgdmFyIGNvbXB1dGVIb3VyU3ViRG9tYWluU2l6ZSA9IGZ1bmN0aW9uIChkYXRlLCBkb21haW4pIHtcclxuICAgICAgc3dpdGNoIChkb21haW4pIHtcclxuICAgICAgICBjYXNlICdkYXknOlxyXG4gICAgICAgICAgcmV0dXJuIDI0O1xyXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgICAgcmV0dXJuIDE2ODtcclxuICAgICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgICAgICByZXR1cm4gcGFyZW50LmdldERheUNvdW50SW5Nb250aChkYXRlKSAqIDI0O1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBpbnRcclxuICAgICAqL1xyXG4gICAgdmFyIGNvbXB1dGVXZWVrU3ViRG9tYWluU2l6ZSA9IGZ1bmN0aW9uIChkYXRlLCBkb21haW4pIHtcclxuICAgICAgaWYgKGRvbWFpbiA9PT0gJ21vbnRoJykge1xyXG4gICAgICAgIHZhciBlbmRPZk1vbnRoID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAwKTtcclxuICAgICAgICB2YXIgZW5kV2Vla05iID0gcGFyZW50LmdldFdlZWtOdW1iZXIoZW5kT2ZNb250aCk7XHJcbiAgICAgICAgdmFyIHN0YXJ0V2Vla05iID0gcGFyZW50LmdldFdlZWtOdW1iZXIoXHJcbiAgICAgICAgICBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSksXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXJ0V2Vla05iID4gZW5kV2Vla05iKSB7XHJcbiAgICAgICAgICBzdGFydFdlZWtOYiA9IDA7XHJcbiAgICAgICAgICBlbmRXZWVrTmIgKz0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbmRXZWVrTmIgLSBzdGFydFdlZWtOYiArIDE7XHJcbiAgICAgIH0gZWxzZSBpZiAoZG9tYWluID09PSAneWVhcicpIHtcclxuICAgICAgICByZXR1cm4gcGFyZW50LmdldFdlZWtOdW1iZXIobmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAxMSwgMzEpKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zdWJEb21haW4pIHtcclxuICAgICAgY2FzZSAneF9taW4nOlxyXG4gICAgICBjYXNlICdtaW4nOlxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1pbnV0ZURvbWFpbihcclxuICAgICAgICAgIGRhdGUsXHJcbiAgICAgICAgICBjb21wdXRlTWluU3ViRG9tYWluU2l6ZShkYXRlLCB0aGlzLm9wdGlvbnMuZG9tYWluKSxcclxuICAgICAgICApO1xyXG4gICAgICBjYXNlICd4X2hvdXInOlxyXG4gICAgICBjYXNlICdob3VyJzpcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRIb3VyRG9tYWluKFxyXG4gICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgIGNvbXB1dGVIb3VyU3ViRG9tYWluU2l6ZShkYXRlLCB0aGlzLm9wdGlvbnMuZG9tYWluKSxcclxuICAgICAgICApO1xyXG4gICAgICBjYXNlICd4X2RheSc6XHJcbiAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF5RG9tYWluKFxyXG4gICAgICAgICAgZGF0ZSxcclxuICAgICAgICAgIGNvbXB1dGVEYXlTdWJEb21haW5TaXplKGRhdGUsIHRoaXMub3B0aW9ucy5kb21haW4pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIGNhc2UgJ3hfd2Vlayc6XHJcbiAgICAgIGNhc2UgJ3dlZWsnOlxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdlZWtEb21haW4oXHJcbiAgICAgICAgICBkYXRlLFxyXG4gICAgICAgICAgY29tcHV0ZVdlZWtTdWJEb21haW5TaXplKGRhdGUsIHRoaXMub3B0aW9ucy5kb21haW4pLFxyXG4gICAgICAgICk7XHJcbiAgICAgIGNhc2UgJ3hfbW9udGgnOlxyXG4gICAgICBjYXNlICdtb250aCc6XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9udGhEb21haW4oZGF0ZSwgMTIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbi10aCBuZXh0IGRvbWFpbiBhZnRlciB0aGUgY2FsZW5kYXIgbmV3ZXN0IChyaWdodG1vc3QpIGRvbWFpblxyXG4gICAqIEBwYXJhbSAgaW50IG5cclxuICAgKiBAcmV0dXJuIERhdGUgVGhlIHN0YXJ0IGRhdGUgb2YgdGhlIHdhbnRlZCBkb21haW5cclxuICAgKi9cclxuICBnZXROZXh0RG9tYWluOiBmdW5jdGlvbiAobikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIG4gPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0RG9tYWluKFxyXG4gICAgICB0aGlzLmp1bXBEYXRlKHRoaXMuZ2V0RG9tYWluS2V5cygpLnBvcCgpLCBuLCB0aGlzLm9wdGlvbnMuZG9tYWluKSxcclxuICAgICAgMSxcclxuICAgIClbMF07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBuLXRoIGRvbWFpbiBiZWZvcmUgdGhlIGNhbGVuZGFyIG9sZGVzdCAobGVmdG1vc3QpIGRvbWFpblxyXG4gICAqIEBwYXJhbSAgaW50IG5cclxuICAgKiBAcmV0dXJuIERhdGUgVGhlIHN0YXJ0IGRhdGUgb2YgdGhlIHdhbnRlZCBkb21haW5cclxuICAgKi9cclxuICBnZXRQcmV2aW91c0RvbWFpbjogZnVuY3Rpb24gKG4pIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBuID0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmdldERvbWFpbihcclxuICAgICAgdGhpcy5qdW1wRGF0ZSh0aGlzLmdldERvbWFpbktleXMoKS5zaGlmdCgpLCAtbiwgdGhpcy5vcHRpb25zLmRvbWFpbiksXHJcbiAgICAgIDEsXHJcbiAgICApWzBdO1xyXG4gIH0sXHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG4gIC8vIERBVEFTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcblxyXG4gIC8qKlxyXG4gICAqIEZldGNoIGFuZCBpbnRlcnByZXQgZGF0YSBmcm9tIHRoZSBkYXRhc291cmNlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc3RyaW5nfG9iamVjdCBzb3VyY2VcclxuICAgKiBAcGFyYW0gRGF0ZSBzdGFydERhdGVcclxuICAgKiBAcGFyYW0gRGF0ZSBlbmREYXRlXHJcbiAgICogQHBhcmFtIGZ1bmN0aW9uIGNhbGxiYWNrXHJcbiAgICogQHBhcmFtIGZ1bmN0aW9ufGJvb2xlYW4gYWZ0ZXJMb2FkIGZ1bmN0aW9uIHVzZWQgdG8gY29udmVydCB0aGUgZGF0YSBpbnRvIGEganNvbiBvYmplY3QuIFVzZSB0cnVlIHRvIHVzZSB0aGUgYWZ0ZXJMb2FkIGNhbGxiYWNrXHJcbiAgICogQHBhcmFtIHVwZGF0ZU1vZGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4gbWl4ZWRcclxuICAgKiAtIFRydWUgaWYgdGhlcmUgYXJlIG5vIGRhdGEgdG8gbG9hZFxyXG4gICAqIC0gRmFsc2UgaWYgZGF0YSBhcmUgbG9hZGVkIGFzeW5jaHJvbm91c2x5XHJcbiAgICovXHJcbiAgZ2V0RGF0YXM6IGZ1bmN0aW9uIChcclxuICAgIHNvdXJjZSxcclxuICAgIHN0YXJ0RGF0ZSxcclxuICAgIGVuZERhdGUsXHJcbiAgICBjYWxsYmFjayxcclxuICAgIGFmdGVyTG9hZCxcclxuICAgIHVwZGF0ZU1vZGUsXHJcbiAgKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA1KSB7XHJcbiAgICAgIGFmdGVyTG9hZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDYpIHtcclxuICAgICAgdXBkYXRlTW9kZSA9IHRoaXMuQVBQRU5EX09OX1VQREFURTtcclxuICAgIH1cclxuICAgIHZhciBfY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyb3IsIGRhdGEpIHtcclxuICAgICAgaWYgKGFmdGVyTG9hZCAhPT0gZmFsc2UpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFmdGVyTG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgZGF0YSA9IGFmdGVyTG9hZChkYXRhKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmLm9wdGlvbnMuYWZ0ZXJMb2FkRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgZGF0YSA9IHNlbGYub3B0aW9ucy5hZnRlckxvYWREYXRhKGRhdGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnUHJvdmlkZWQgY2FsbGJhY2sgZm9yIGFmdGVyTG9hZERhdGEgaXMgbm90IGEgZnVuY3Rpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgIHNlbGYub3B0aW9ucy5kYXRhVHlwZSA9PT0gJ2NzdicgfHxcclxuICAgICAgICBzZWxmLm9wdGlvbnMuZGF0YVR5cGUgPT09ICd0c3YnXHJcbiAgICAgICkge1xyXG4gICAgICAgIGRhdGEgPSB0aGlzLmludGVycHJldENTVihkYXRhKTtcclxuICAgICAgfVxyXG4gICAgICBzZWxmLnBhcnNlRGF0YXMoZGF0YSwgdXBkYXRlTW9kZSwgc3RhcnREYXRlLCBlbmREYXRlKTtcclxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgc3dpdGNoICh0eXBlb2Ygc291cmNlKSB7XHJcbiAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gJycpIHtcclxuICAgICAgICAgIF9jYWxsYmFjayhudWxsLCB7fSk7XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdmFyIHVybCA9IHRoaXMucGFyc2VVUkkoc291cmNlLCBzdGFydERhdGUsIGVuZERhdGUpO1xyXG4gICAgICAgICAgdmFyIHJlcXVlc3RUeXBlID0gJ0dFVCc7XHJcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmRhdGFQb3N0UGF5bG9hZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXF1ZXN0VHlwZSA9ICdQT1NUJztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbnVsbDtcclxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZGF0YVBvc3RQYXlsb2FkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBheWxvYWQgPSB0aGlzLnBhcnNlVVJJKFxyXG4gICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5kYXRhUG9zdFBheWxvYWQsXHJcbiAgICAgICAgICAgICAgc3RhcnREYXRlLFxyXG4gICAgICAgICAgICAgIGVuZERhdGUsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIHhociA9IG51bGw7XHJcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5kYXRhVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdqc29uJzpcclxuICAgICAgICAgICAgICB4aHIgPSBkMy5qc29uKHVybCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Nzdic6XHJcbiAgICAgICAgICAgICAgeGhyID0gZDMuY3N2KHVybCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3Rzdic6XHJcbiAgICAgICAgICAgICAgeGhyID0gZDMudHN2KHVybCk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3R4dCc6XHJcbiAgICAgICAgICAgICAgeGhyID0gZDMudGV4dCh1cmwsICd0ZXh0L3BsYWluJyk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8ganNoaW50IG1heGRlcHRoOjVcclxuICAgICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZGF0YVJlcXVlc3RIZWFkZXJzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGhlYWRlciBpbiBzZWxmLm9wdGlvbnMuZGF0YVJlcXVlc3RIZWFkZXJzKSB7XHJcbiAgICAgICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5kYXRhUmVxdWVzdEhlYWRlcnMuaGFzT3duUHJvcGVydHkoaGVhZGVyKSkge1xyXG4gICAgICAgICAgICAgICAgeGhyLmhlYWRlcihoZWFkZXIsIHNlbGYub3B0aW9ucy5kYXRhUmVxdWVzdEhlYWRlcnNbaGVhZGVyXSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGhyLnNlbmQocmVxdWVzdFR5cGUsIHBheWxvYWQsIF9jYWxsYmFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICBpZiAoc291cmNlID09PSBPYmplY3Qoc291cmNlKSkge1xyXG4gICAgICAgICAgX2NhbGxiYWNrKG51bGwsIHNvdXJjZSk7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgX2NhbGxiYWNrKG51bGwsIHt9KTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBQb3B1bGF0ZSB0aGUgY2FsZW5kYXIgaW50ZXJuYWwgZGF0YVxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9iamVjdCBkYXRhXHJcbiAgICogQHBhcmFtIGNvbnN0YW50IHVwZGF0ZU1vZGVcclxuICAgKiBAcGFyYW0gRGF0ZSBzdGFydERhdGVcclxuICAgKiBAcGFyYW0gRGF0ZSBlbmREYXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHZvaWRcclxuICAgKi9cclxuICBwYXJzZURhdGFzOiBmdW5jdGlvbiAoZGF0YSwgdXBkYXRlTW9kZSwgc3RhcnREYXRlLCBlbmREYXRlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKHVwZGF0ZU1vZGUgPT09IHRoaXMuUkVTRVRfQUxMX09OX1VQREFURSkge1xyXG4gICAgICB0aGlzLl9kb21haW5zLmZvckVhY2goZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgYXJyYXkpIHtcclxuICAgICAgICAgIGFycmF5W2luZGV4XS52ID0gbnVsbDtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRlbXAgPSB7fTtcclxuXHJcbiAgICB2YXIgZXh0cmFjdFRpbWUgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICByZXR1cm4gZC50O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xyXG4gICAgZm9yICh2YXIgZCBpbiBkYXRhKSB7XHJcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoZCAqIDEwMDApO1xyXG4gICAgICB2YXIgZG9tYWluVW5pdCA9IHRoaXMuZ2V0RG9tYWluKGRhdGUpWzBdLmdldFRpbWUoKTtcclxuICAgICAgLy8gVGhlIGN1cnJlbnQgZGF0YSBiZWxvbmdzIHRvIGEgZG9tYWluIHRoYXQgd2FzIGNvbXByZXNzZWRcclxuICAgICAgLy8gQ29tcHJlc3MgdGhlIGRhdGEgZm9yIHRoZSB0d28gZHVwbGljYXRlIGhvdXJzIGludG8gdGhlIHNhbWUgaG91clxyXG4gICAgICBpZiAodGhpcy5EU1REb21haW4uaW5kZXhPZihkb21haW5Vbml0KSA+PSAwKSB7XHJcbiAgICAgICAgLy8gUmUtYXNzaWduIGFsbCBkYXRhIHRvIHRoZSBmaXJzdCBvciB0aGUgc2Vjb25kIGR1cGxpY2F0ZSBob3Vyc1xyXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB3aGljaCBpcyB2aXNpYmxlXHJcbiAgICAgICAgaWYgKHRoaXMuX2RvbWFpbnMuaGFzKGRvbWFpblVuaXQgLSAzNjAwICogMTAwMCkpIHtcclxuICAgICAgICAgIGRvbWFpblVuaXQgLT0gMzYwMCAqIDEwMDA7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTa2lwIGlmIGRhdGEgaXMgbm90IHJlbGV2YW50IHRvIGN1cnJlbnQgZG9tYWluXHJcbiAgICAgIGlmIChcclxuICAgICAgICBpc05hTihkKSB8fFxyXG4gICAgICAgICFkYXRhLmhhc093blByb3BlcnR5KGQpIHx8XHJcbiAgICAgICAgIXRoaXMuX2RvbWFpbnMuaGFzKGRvbWFpblVuaXQpIHx8XHJcbiAgICAgICAgIShkb21haW5Vbml0ID49ICtzdGFydERhdGUgJiYgZG9tYWluVW5pdCA8ICtlbmREYXRlKVxyXG4gICAgICApIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHN1YkRvbWFpbnNEYXRhID0gdGhpcy5fZG9tYWlucy5nZXQoZG9tYWluVW5pdCk7XHJcblxyXG4gICAgICBpZiAoIXRlbXAuaGFzT3duUHJvcGVydHkoZG9tYWluVW5pdCkpIHtcclxuICAgICAgICB0ZW1wW2RvbWFpblVuaXRdID0gc3ViRG9tYWluc0RhdGEubWFwKGV4dHJhY3RUaW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGluZGV4ID0gdGVtcFtkb21haW5Vbml0XS5pbmRleE9mKFxyXG4gICAgICAgIHRoaXMuX2RvbWFpblR5cGVbdGhpcy5vcHRpb25zLnN1YkRvbWFpbl0uZXh0cmFjdFVuaXQoZGF0ZSksXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBpZiAodXBkYXRlTW9kZSA9PT0gdGhpcy5SRVNFVF9TSU5HTEVfT05fVVBEQVRFKSB7XHJcbiAgICAgICAgc3ViRG9tYWluc0RhdGFbaW5kZXhdLnYgPSBkYXRhW2RdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICghaXNOYU4oc3ViRG9tYWluc0RhdGFbaW5kZXhdLnYpKSB7XHJcbiAgICAgICAgICBzdWJEb21haW5zRGF0YVtpbmRleF0udiArPSBkYXRhW2RdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdWJEb21haW5zRGF0YVtpbmRleF0udiA9IGRhdGFbZF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcGFyc2VVUkk6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIC8vIFVzZSBhIHRpbWVzdGFtcCBpbiBzZWNvbmRzXHJcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFx7XFx7dDpzdGFydFxcfVxcfS9nLCBzdGFydERhdGUuZ2V0VGltZSgpIC8gMTAwMCk7XHJcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFx7XFx7dDplbmRcXH1cXH0vZywgZW5kRGF0ZS5nZXRUaW1lKCkgLyAxMDAwKTtcclxuXHJcbiAgICAvLyBVc2UgYSBzdHJpbmcgZGF0ZSwgZm9sbG93aW5nIHRoZSBJU08tODYwMVxyXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xce1xce2Q6c3RhcnRcXH1cXH0vZywgc3RhcnREYXRlLnRvSVNPU3RyaW5nKCkpO1xyXG4gICAgc3RyID0gc3RyLnJlcGxhY2UoL1xce1xce2Q6ZW5kXFx9XFx9L2csIGVuZERhdGUudG9JU09TdHJpbmcoKSk7XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9LFxyXG5cclxuICBpbnRlcnByZXRDU1Y6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIGQgPSB7fTtcclxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YVswXSk7XHJcbiAgICB2YXIgaSwgdG90YWw7XHJcbiAgICBmb3IgKGkgPSAwLCB0b3RhbCA9IGRhdGEubGVuZ3RoOyBpIDwgdG90YWw7IGkgKz0gMSkge1xyXG4gICAgICBkW2RhdGFbaV1ba2V5c1swXV1dID0gK2RhdGFbaV1ba2V5c1sxXV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGUgdGhlIGNhbGVuZGFyIGxheW91dCBhbmQgZGltZW5zaW9uXHJcbiAgICpcclxuICAgKiBFeHBhbmQgYW5kIHNocmluayB0aGUgY29udGFpbmVyIGRlcGVuZGluZyBvbiBpdHMgY2hpbGRyZW4gZGltZW5zaW9uXHJcbiAgICogQWxzbyByZWFycmFuZ2UgdGhlIGNoaWxkcmVuIHBvc2l0aW9uIGRlcGVuZGluZyBvbiB0aGVpciBkaW1lbnNpb24sXHJcbiAgICogYW5kIHRoZSBsZWdlbmQgcG9zaXRpb25cclxuICAgKlxyXG4gICAqIEByZXR1cm4gdm9pZFxyXG4gICAqL1xyXG4gIHJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gICAgdmFyIG9wdGlvbnMgPSBwYXJlbnQub3B0aW9ucztcclxuICAgIHZhciBsZWdlbmRXaWR0aCA9IG9wdGlvbnMuZGlzcGxheUxlZ2VuZFxyXG4gICAgICA/IHBhcmVudC5MZWdlbmQuZ2V0RGltKCd3aWR0aCcpICtcclxuICAgICAgICBvcHRpb25zLmxlZ2VuZE1hcmdpblsxXSArXHJcbiAgICAgICAgb3B0aW9ucy5sZWdlbmRNYXJnaW5bM11cclxuICAgICAgOiAwO1xyXG4gICAgdmFyIGxlZ2VuZEhlaWdodCA9IG9wdGlvbnMuZGlzcGxheUxlZ2VuZFxyXG4gICAgICA/IHBhcmVudC5MZWdlbmQuZ2V0RGltKCdoZWlnaHQnKSArXHJcbiAgICAgICAgb3B0aW9ucy5sZWdlbmRNYXJnaW5bMF0gK1xyXG4gICAgICAgIG9wdGlvbnMubGVnZW5kTWFyZ2luWzJdXHJcbiAgICAgIDogMDtcclxuXHJcbiAgICB2YXIgZ3JhcGhXaWR0aCA9XHJcbiAgICAgIHBhcmVudC5ncmFwaERpbS53aWR0aCAtIG9wdGlvbnMuZG9tYWluR3V0dGVyIC0gb3B0aW9ucy5jZWxsUGFkZGluZztcclxuICAgIHZhciBncmFwaEhlaWdodCA9XHJcbiAgICAgIHBhcmVudC5ncmFwaERpbS5oZWlnaHQgLSBvcHRpb25zLmRvbWFpbkd1dHRlciAtIG9wdGlvbnMuY2VsbFBhZGRpbmc7XHJcblxyXG4gICAgdGhpcy5yb290XHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pXHJcbiAgICAgIC5hdHRyKCd3aWR0aCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdtaWRkbGUnIHx8XHJcbiAgICAgICAgICBvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdjZW50ZXInXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gZ3JhcGhXaWR0aCArIGxlZ2VuZFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZ3JhcGhXaWR0aCwgbGVnZW5kV2lkdGgpO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cignaGVpZ2h0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kVmVydGljYWxQb3NpdGlvbiA9PT0gJ21pZGRsZScgfHxcclxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kVmVydGljYWxQb3NpdGlvbiA9PT0gJ2NlbnRlcidcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiBNYXRoLm1heChncmFwaEhlaWdodCwgbGVnZW5kSGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdyYXBoSGVpZ2h0ICsgbGVnZW5kSGVpZ2h0O1xyXG4gICAgICB9KTtcclxuXHJcbiAgICB0aGlzLnJvb3RcclxuICAgICAgLnNlbGVjdCgnLmdyYXBoJylcclxuICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAuZHVyYXRpb24ob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbilcclxuICAgICAgLmF0dHIoJ3knLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnZW5kVmVydGljYWxQb3NpdGlvbiA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgIHJldHVybiBsZWdlbmRIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgICB9KVxyXG4gICAgICAuYXR0cigneCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAob3B0aW9ucy5sZWdlbmRWZXJ0aWNhbFBvc2l0aW9uID09PSAnbWlkZGxlJyB8fFxyXG4gICAgICAgICAgICBvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdjZW50ZXInKSAmJlxyXG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRIb3Jpem9udGFsUG9zaXRpb24gPT09ICdsZWZ0J1xyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIGxlZ2VuZFdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXHJcbiAgLy8gUFVCTElDIEFQSSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cclxuXHJcbiAgLyoqXHJcbiAgICogU2hpZnQgdGhlIGNhbGVuZGFyIGZvcndhcmRcclxuICAgKi9cclxuICBuZXh0OiBmdW5jdGlvbiAobikge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIG4gPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubG9hZE5leHREb21haW4obik7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2hpZnQgdGhlIGNhbGVuZGFyIGJhY2t3YXJkXHJcbiAgICovXHJcbiAgcHJldmlvdXM6IGZ1bmN0aW9uIChuKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgbiA9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5sb2FkUHJldmlvdXNEb21haW4obik7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogSnVtcCBkaXJlY3RseSB0byBhIHNwZWNpZmljIGRhdGVcclxuICAgKlxyXG4gICAqIEp1bXBUbyB3aWxsIHNjcm9sbCB0aGUgY2FsZW5kYXIgdW50aWwgdGhlIHdhbnRlZCBkb21haW4gd2l0aCB0aGUgc3BlY2lmaWVkXHJcbiAgICogZGF0ZSBpcyB2aXNpYmxlLiBVbmxlc3MgeW91IHNldCByZXNldCB0byB0cnVlLCB0aGUgd2FudGVkIGRvbWFpblxyXG4gICAqIHdpbGwgbm90IG5lY2Vzc2FyaWx5IGJlIHRoZSBmaXJzdCAobGVmdG1vc3QpIGRvbWFpbiBvZiB0aGUgY2FsZW5kYXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gRGF0ZSBkYXRlIEp1bXAgdG8gdGhlIGRvbWFpbiBjb250YWluaW5nIHRoYXQgZGF0ZVxyXG4gICAqIEBwYXJhbSBib29sIHJlc2V0IFdoZXRoZXIgdGhlIHdhbnRlZCBkb21haW4gc2hvdWxkIGJlIHRoZSBmaXJzdCBkb21haW4gb2YgdGhlIGNhbGVuZGFyXHJcbiAgICogQHBhcmFtIGJvb2wgVHJ1ZSBvZiB0aGUgY2FsZW5kYXIgd2FzIHNjcm9sbGVkXHJcbiAgICovXHJcbiAganVtcFRvOiBmdW5jdGlvbiAoZGF0ZSwgcmVzZXQpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcclxuICAgICAgcmVzZXQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBkb21haW5zID0gdGhpcy5nZXREb21haW5LZXlzKCk7XHJcbiAgICB2YXIgZmlyc3REb21haW4gPSBkb21haW5zWzBdO1xyXG4gICAgdmFyIGxhc3REb21haW4gPSBkb21haW5zW2RvbWFpbnMubGVuZ3RoIC0gMV07XHJcblxyXG4gICAgaWYgKGRhdGUgPCBmaXJzdERvbWFpbikge1xyXG4gICAgICByZXR1cm4gdGhpcy5sb2FkUHJldmlvdXNEb21haW4odGhpcy5nZXREb21haW4oZmlyc3REb21haW4sIGRhdGUpLmxlbmd0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocmVzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkTmV4dERvbWFpbih0aGlzLmdldERvbWFpbihmaXJzdERvbWFpbiwgZGF0ZSkubGVuZ3RoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRhdGUgPiBsYXN0RG9tYWluKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZE5leHREb21haW4odGhpcy5nZXREb21haW4obGFzdERvbWFpbiwgZGF0ZSkubGVuZ3RoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBOYXZpZ2F0ZSBiYWNrIHRvIHRoZSBzdGFydCBkYXRlXHJcbiAgICpcclxuICAgKiBAc2luY2UgIDMuMy44XHJcbiAgICogQHJldHVybiB2b2lkXHJcbiAgICovXHJcbiAgcmV3aW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdGhpcy5qdW1wVG8odGhpcy5vcHRpb25zLnN0YXJ0LCB0cnVlKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGNhbGVuZGFyIHdpdGggbmV3IGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSAgb2JqZWN0fHN0cmluZyAgICBkYXRhU291cmNlICAgIFRoZSBjYWxlbmRhcidzIGRhdGFzb3VyY2UsIHNhbWUgdHlwZSBhcyB0aGlzLm9wdGlvbnMuZGF0YVxyXG4gICAqIEBwYXJhbSAgYm9vbGVhbnxmdW5jdGlvbiAgICBhZnRlckxvYWQgICAgV2hldGhlciB0byBleGVjdXRlIGFmdGVyTG9hZCgpIG9uIHRoZSBkYXRhLiBQYXNzIGRpcmVjdGx5IGEgZnVuY3Rpb25cclxuICAgKiBpZiB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgdGhlIGFmdGVyTG9hZCgpIGNhbGxiYWNrXHJcbiAgICovXHJcbiAgdXBkYXRlOiBmdW5jdGlvbiAoZGF0YVNvdXJjZSwgYWZ0ZXJMb2FkLCB1cGRhdGVNb2RlKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgZGF0YVNvdXJjZSA9IHRoaXMub3B0aW9ucy5kYXRhO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgIGFmdGVyTG9hZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgdXBkYXRlTW9kZSA9IHRoaXMuUkVTRVRfQUxMX09OX1VQREFURTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgZG9tYWlucyA9IHRoaXMuZ2V0RG9tYWluS2V5cygpO1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdGhpcy5nZXREYXRhcyhcclxuICAgICAgZGF0YVNvdXJjZSxcclxuICAgICAgbmV3IERhdGUoZG9tYWluc1swXSksXHJcbiAgICAgIHRoaXMuZ2V0U3ViRG9tYWluKGRvbWFpbnNbZG9tYWlucy5sZW5ndGggLSAxXSkucG9wKCksXHJcbiAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLmZpbGwoKTtcclxuICAgICAgICBzZWxmLmFmdGVyVXBkYXRlKCk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGFmdGVyTG9hZCxcclxuICAgICAgdXBkYXRlTW9kZSxcclxuICAgICk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBsZWdlbmRcclxuICAgKlxyXG4gICAqIEBwYXJhbSBhcnJheSBsZWdlbmQgYW4gYXJyYXkgb2YgaW50ZWdlciwgcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgdGhyZXNob2xkIHZhbHVlXHJcbiAgICogQHBhcmFtIGFycmF5IGNvbG9yUmFuZ2UgYW4gYXJyYXkgb2YgMiBoZXggY29sb3JzLCBmb3IgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gY29sb3JzXHJcbiAgICovXHJcbiAgc2V0TGVnZW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdmFyIG9sZExlZ2VuZCA9IHRoaXMub3B0aW9ucy5sZWdlbmQuc2xpY2UoMCk7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xyXG4gICAgICB0aGlzLm9wdGlvbnMubGVnZW5kID0gYXJndW1lbnRzWzBdO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xyXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMV0pICYmIGFyZ3VtZW50c1sxXS5sZW5ndGggPj0gMikge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5sZWdlbmRDb2xvcnMgPSBbYXJndW1lbnRzWzFdWzBdLCBhcmd1bWVudHNbMV1bMV1dO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5sZWdlbmRDb2xvcnMgPSBhcmd1bWVudHNbMV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiAhYXJyYXlFcXVhbHMob2xkTGVnZW5kLCB0aGlzLm9wdGlvbnMubGVnZW5kKSkgfHxcclxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+PSAyXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5MZWdlbmQuYnVpbGRDb2xvcnMoKTtcclxuICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5MZWdlbmQucmVkcmF3KFxyXG4gICAgICB0aGlzLmdyYXBoRGltLndpZHRoIC1cclxuICAgICAgICB0aGlzLm9wdGlvbnMuZG9tYWluR3V0dGVyIC1cclxuICAgICAgICB0aGlzLm9wdGlvbnMuY2VsbFBhZGRpbmcsXHJcbiAgICApO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgbGVnZW5kXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIGJvb2wgRmFsc2UgaWYgdGhlcmUgaXMgbm8gbGVnZW5kIHRvIHJlbW92ZVxyXG4gICAqL1xyXG4gIHJlbW92ZUxlZ2VuZDogZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc3BsYXlMZWdlbmQpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdGhpcy5vcHRpb25zLmRpc3BsYXlMZWdlbmQgPSBmYWxzZTtcclxuICAgIHRoaXMuTGVnZW5kLnJlbW92ZSgpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGlzcGxheSB0aGUgbGVnZW5kXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIGJvb2wgRmFsc2UgaWYgdGhlIGxlZ2VuZCB3YXMgYWxyZWFkeSBkaXNwbGF5ZWRcclxuICAgKi9cclxuICBzaG93TGVnZW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5TGVnZW5kKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMub3B0aW9ucy5kaXNwbGF5TGVnZW5kID0gdHJ1ZTtcclxuICAgIHRoaXMuTGVnZW5kLnJlZHJhdyhcclxuICAgICAgdGhpcy5ncmFwaERpbS53aWR0aCAtXHJcbiAgICAgICAgdGhpcy5vcHRpb25zLmRvbWFpbkd1dHRlciAtXHJcbiAgICAgICAgdGhpcy5vcHRpb25zLmNlbGxQYWRkaW5nLFxyXG4gICAgKTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEhpZ2hsaWdodCBkYXRlc1xyXG4gICAqXHJcbiAgICogQWRkIGEgaGlnaGxpZ2h0IGNsYXNzIHRvIGEgc2V0IG9mIGRhdGVzXHJcbiAgICpcclxuICAgKiBAc2luY2UgIDMuMy41XHJcbiAgICogQHBhcmFtICBhcnJheSBBcnJheSBvZiBkYXRlcyB0byBoaWdobGlnaHRcclxuICAgKiBAcmV0dXJuIGJvb2wgVHJ1ZSBpZiBkYXRlcyB3ZXJlIGhpZ2hsaWdodGVkXHJcbiAgICovXHJcbiAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIGlmICgodGhpcy5vcHRpb25zLmhpZ2hsaWdodCA9IHRoaXMuZXhwYW5kRGF0ZVNldHRpbmcoYXJncykpLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgdGhlIGNhbGVuZGFyXHJcbiAgICpcclxuICAgKiBVc2FnZTogY2FsID0gY2FsLmRlc3Ryb3koKTtcclxuICAgKlxyXG4gICAqIEBzaW5jZSAgMy4zLjZcclxuICAgKiBAcGFyYW0gZnVuY3Rpb24gQSBjYWxsYmFjayBmdW5jdGlvbiB0byB0cmlnZ2VyIGFmdGVyIGRlc3Ryb3lpbmcgdGhlIGNhbGVuZGFyXHJcbiAgICogQHJldHVybiBudWxsXHJcbiAgICovXHJcbiAgZGVzdHJveTogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAndXNlIHN0cmljdCc7XHJcblxyXG4gICAgdGhpcy5yb290XHJcbiAgICAgIC50cmFuc2l0aW9uKClcclxuICAgICAgLmR1cmF0aW9uKHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbilcclxuICAgICAgLmF0dHIoJ3dpZHRoJywgMClcclxuICAgICAgLmF0dHIoJ2hlaWdodCcsIDApXHJcbiAgICAgIC5yZW1vdmUoKVxyXG4gICAgICAuZWFjaCgnZW5kJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnUHJvdmlkZWQgY2FsbGJhY2sgZm9yIGRlc3Ryb3koKSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0sXHJcblxyXG4gIGdldFNWRzogZnVuY3Rpb24gKCkge1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAgIHZhciBzdHlsZXMgPSB7XHJcbiAgICAgICcuY2FsLWhlYXRtYXAtY29udGFpbmVyJzoge30sXHJcbiAgICAgICcuZ3JhcGgnOiB7fSxcclxuICAgICAgJy5ncmFwaC1yZWN0Jzoge30sXHJcbiAgICAgICdyZWN0LmhpZ2hsaWdodCc6IHt9LFxyXG4gICAgICAncmVjdC5ub3cnOiB7fSxcclxuICAgICAgJ3JlY3QuaGlnaGxpZ2h0LW5vdyc6IHt9LFxyXG4gICAgICAndGV4dC5oaWdobGlnaHQnOiB7fSxcclxuICAgICAgJ3RleHQubm93Jzoge30sXHJcbiAgICAgICd0ZXh0LmhpZ2hsaWdodC1ub3cnOiB7fSxcclxuICAgICAgJy5kb21haW4tYmFja2dyb3VuZCc6IHt9LFxyXG4gICAgICAnLmdyYXBoLWxhYmVsJzoge30sXHJcbiAgICAgICcuc3ViZG9tYWluLXRleHQnOiB7fSxcclxuICAgICAgJy5xMCc6IHt9LFxyXG4gICAgICAnLnFpJzoge30sXHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAoXHJcbiAgICAgIHZhciBqID0gMSwgdG90YWwgPSB0aGlzLm9wdGlvbnMubGVnZW5kLmxlbmd0aCArIDE7XHJcbiAgICAgIGogPD0gdG90YWw7XHJcbiAgICAgIGogKz0gMVxyXG4gICAgKSB7XHJcbiAgICAgIHN0eWxlc1snLnEnICsgal0gPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcclxuXHJcbiAgICB2YXIgd2hpdGVsaXN0U3R5bGVzID0gW1xyXG4gICAgICAvLyBTVkcgc3BlY2lmaWMgcHJvcGVydGllc1xyXG4gICAgICAnc3Ryb2tlJyxcclxuICAgICAgJ3N0cm9rZS13aWR0aCcsXHJcbiAgICAgICdzdHJva2Utb3BhY2l0eScsXHJcbiAgICAgICdzdHJva2UtZGFzaGFycmF5JyxcclxuICAgICAgJ3N0cm9rZS1kYXNob2Zmc2V0JyxcclxuICAgICAgJ3N0cm9rZS1saW5lY2FwJyxcclxuICAgICAgJ3N0cm9rZS1taXRlcmxpbWl0JyxcclxuICAgICAgJ2ZpbGwnLFxyXG4gICAgICAnZmlsbC1vcGFjaXR5JyxcclxuICAgICAgJ2ZpbGwtcnVsZScsXHJcbiAgICAgICdtYXJrZXInLFxyXG4gICAgICAnbWFya2VyLXN0YXJ0JyxcclxuICAgICAgJ21hcmtlci1taWQnLFxyXG4gICAgICAnbWFya2VyLWVuZCcsXHJcbiAgICAgICdhbGlnbmVtZW50LWJhc2VsaW5lJyxcclxuICAgICAgJ2Jhc2VsaW5lLXNoaWZ0JyxcclxuICAgICAgJ2RvbWluYW50LWJhc2VsaW5lJyxcclxuICAgICAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLFxyXG4gICAgICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLFxyXG4gICAgICAna2VybmluZycsXHJcbiAgICAgICd0ZXh0LWFuY2hvcicsXHJcbiAgICAgICdzaGFwZS1yZW5kZXJpbmcnLFxyXG5cclxuICAgICAgLy8gVGV4dCBTcGVjaWZpYyBwcm9wZXJ0aWVzXHJcbiAgICAgICd0ZXh0LXRyYW5zZm9ybScsXHJcbiAgICAgICdmb250LWZhbWlseScsXHJcbiAgICAgICdmb250JyxcclxuICAgICAgJ2ZvbnQtc2l6ZScsXHJcbiAgICAgICdmb250LXdlaWdodCcsXHJcbiAgICBdO1xyXG5cclxuICAgIHZhciBmaWx0ZXJTdHlsZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgICAgaWYgKHdoaXRlbGlzdFN0eWxlcy5pbmRleE9mKHByb3BlcnR5KSAhPT0gLTEpIHtcclxuICAgICAgICBzdHlsZXNbYXR0cmlidXRlXVtwcm9wZXJ0eV0gPSB2YWx1ZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIHJldHVybiByb290LnNlbGVjdChlKVswXVswXTtcclxuICAgIH07XHJcblxyXG4gICAgLyoganNoaW50IGZvcmluOmZhbHNlICovXHJcbiAgICBmb3IgKHZhciBlbGVtZW50IGluIHN0eWxlcykge1xyXG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShlbGVtZW50KSkge1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZG9tID0gZ2V0RWxlbWVudChlbGVtZW50KTtcclxuXHJcbiAgICAgIGlmIChkb20gPT09IG51bGwpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVGhlIERPTSBMZXZlbCAyIENTUyB3YXlcclxuICAgICAgLyoganNoaW50IG1heGRlcHRoOiBmYWxzZSAqL1xyXG4gICAgICBpZiAoJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdykge1xyXG4gICAgICAgIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUoZG9tLCBudWxsKTtcclxuICAgICAgICBpZiAoY3MubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGZpbHRlclN0eWxlcyhlbGVtZW50LCBjcy5pdGVtKGkpLCBjcy5nZXRQcm9wZXJ0eVZhbHVlKGNzLml0ZW0oaSkpKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBPcGVyYSB3b3JrYXJvdW5kLiBPcGVyYSBkb2VzblwidCBzdXBwb3J0IGBpdGVtYC9gbGVuZ3RoYFxyXG4gICAgICAgICAgLy8gb24gQ1NTU3R5bGVEZWNsYXJhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9yICh2YXIgayBpbiBjcykge1xyXG4gICAgICAgICAgICBpZiAoY3MuaGFzT3duUHJvcGVydHkoaykpIHtcclxuICAgICAgICAgICAgICBmaWx0ZXJTdHlsZXMoZWxlbWVudCwgaywgY3Nba10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgSUUgd2F5XHJcbiAgICAgIH0gZWxzZSBpZiAoJ2N1cnJlbnRTdHlsZScgaW4gZG9tKSB7XHJcbiAgICAgICAgdmFyIGNzcyA9IGRvbS5jdXJyZW50U3R5bGU7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBjc3MpIHtcclxuICAgICAgICAgIGZpbHRlclN0eWxlcyhlbGVtZW50LCBwLCBjc3NbcF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdHJpbmcgPVxyXG4gICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArXHJcbiAgICAgICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIj48c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+PCFbQ0RBVEFbICc7XHJcblxyXG4gICAgZm9yICh2YXIgc3R5bGUgaW4gc3R5bGVzKSB7XHJcbiAgICAgIHN0cmluZyArPSBzdHlsZSArICcge1xcbic7XHJcbiAgICAgIGZvciAodmFyIGwgaW4gc3R5bGVzW3N0eWxlXSkge1xyXG4gICAgICAgIHN0cmluZyArPSAnXFx0JyArIGwgKyAnOicgKyBzdHlsZXNbc3R5bGVdW2xdICsgJztcXG4nO1xyXG4gICAgICB9XHJcbiAgICAgIHN0cmluZyArPSAnfVxcbic7XHJcbiAgICB9XHJcblxyXG4gICAgc3RyaW5nICs9ICddXT48L3N0eWxlPic7XHJcbiAgICBzdHJpbmcgKz0gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyh0aGlzLnJvb3RbMF1bMF0pO1xyXG4gICAgc3RyaW5nICs9ICc8L3N2Zz4nO1xyXG5cclxuICAgIHJldHVybiBzdHJpbmc7XHJcbiAgfSxcclxufTtcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG4vLyBET01BSU4gUE9TSVRJT04gQ09NUFVUQVRJT04gICAgICAgICAgICAgICAgICAgICAgICAvL1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIHRoZSBwb3NpdGlvbiBvZiBhIGRvbWFpbiwgcmVsYXRpdmUgdG8gdGhlIGNhbGVuZGFyXHJcbiAqL1xyXG52YXIgRG9tYWluUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB0aGlzLnBvc2l0aW9ucyA9IGQzLm1hcCgpO1xyXG59O1xyXG5cclxuRG9tYWluUG9zaXRpb24ucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKGQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHJldHVybiB0aGlzLnBvc2l0aW9ucy5nZXQoZCk7XHJcbn07XHJcblxyXG5Eb21haW5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0UG9zaXRpb25Gcm9tSW5kZXggPSBmdW5jdGlvbiAoaSkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdmFyIGRvbWFpbnMgPSB0aGlzLmdldEtleXMoKTtcclxuICByZXR1cm4gdGhpcy5wb3NpdGlvbnMuZ2V0KGRvbWFpbnNbaV0pO1xyXG59O1xyXG5cclxuRG9tYWluUG9zaXRpb24ucHJvdG90eXBlLmdldExhc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgZG9tYWlucyA9IHRoaXMuZ2V0S2V5cygpO1xyXG4gIHJldHVybiB0aGlzLnBvc2l0aW9ucy5nZXQoZG9tYWluc1tkb21haW5zLmxlbmd0aCAtIDFdKTtcclxufTtcclxuXHJcbkRvbWFpblBvc2l0aW9uLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChkLCBkaW0pIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHRoaXMucG9zaXRpb25zLnNldChkLCBkaW0pO1xyXG59O1xyXG5cclxuRG9tYWluUG9zaXRpb24ucHJvdG90eXBlLnNoaWZ0UmlnaHRCeSA9IGZ1bmN0aW9uIChleGl0aW5nRG9tYWluRGltKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB0aGlzLnBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICB0aGlzLnNldChrZXksIHZhbHVlIC0gZXhpdGluZ0RvbWFpbkRpbSk7XHJcbiAgfSk7XHJcblxyXG4gIHZhciBkb21haW5zID0gdGhpcy5nZXRLZXlzKCk7XHJcbiAgdGhpcy5wb3NpdGlvbnMucmVtb3ZlKGRvbWFpbnNbMF0pO1xyXG59O1xyXG5cclxuRG9tYWluUG9zaXRpb24ucHJvdG90eXBlLnNoaWZ0TGVmdEJ5ID0gZnVuY3Rpb24gKGVudGVyaW5nRG9tYWluRGltKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB0aGlzLnBvc2l0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICB0aGlzLnNldChrZXksIHZhbHVlICsgZW50ZXJpbmdEb21haW5EaW0pO1xyXG4gIH0pO1xyXG5cclxuICB2YXIgZG9tYWlucyA9IHRoaXMuZ2V0S2V5cygpO1xyXG4gIHRoaXMucG9zaXRpb25zLnJlbW92ZShkb21haW5zW2RvbWFpbnMubGVuZ3RoIC0gMV0pO1xyXG59O1xyXG5cclxuRG9tYWluUG9zaXRpb24ucHJvdG90eXBlLmdldEtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICByZXR1cm4gdGhpcy5wb3NpdGlvbnMua2V5cygpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIHJldHVybiBwYXJzZUludChhLCAxMCkgLSBwYXJzZUludChiLCAxMCk7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ly9cclxuLy8gTEVHRU5EICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0vL1xyXG5cclxudmFyIExlZ2VuZCA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gIHRoaXMuY29tcHV0ZURpbSgpO1xyXG5cclxuICBpZiAoY2FsZW5kYXIub3B0aW9ucy5sZWdlbmRDb2xvcnMgIT09IG51bGwpIHtcclxuICAgIHRoaXMuYnVpbGRDb2xvcnMoKTtcclxuICB9XHJcbn07XHJcblxyXG5MZWdlbmQucHJvdG90eXBlLmNvbXB1dGVEaW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICB2YXIgb3B0aW9ucyA9IHRoaXMuY2FsZW5kYXIub3B0aW9uczsgLy8gU2hvcnRlciBhY2Nlc3NvciBmb3IgdmFyaWFibGUgbmFtZSBtYW5nbGluZyB3aGVuIG1pbmlmeWluZ1xyXG4gIHRoaXMuZGltID0ge1xyXG4gICAgd2lkdGg6XHJcbiAgICAgIG9wdGlvbnMubGVnZW5kQ2VsbFNpemUgKiAob3B0aW9ucy5sZWdlbmQubGVuZ3RoICsgMSkgK1xyXG4gICAgICBvcHRpb25zLmxlZ2VuZENlbGxQYWRkaW5nICogb3B0aW9ucy5sZWdlbmQubGVuZ3RoLFxyXG4gICAgaGVpZ2h0OiBvcHRpb25zLmxlZ2VuZENlbGxTaXplLFxyXG4gIH07XHJcbn07XHJcblxyXG5MZWdlbmQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHRoaXMuY2FsZW5kYXIucm9vdC5zZWxlY3QoJy5ncmFwaC1sZWdlbmQnKS5yZW1vdmUoKTtcclxuICB0aGlzLmNhbGVuZGFyLnJlc2l6ZSgpO1xyXG59O1xyXG5cclxuTGVnZW5kLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAod2lkdGgpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmICghdGhpcy5jYWxlbmRhci5vcHRpb25zLmRpc3BsYXlMZWdlbmQpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgdmFyIGxlZ2VuZCA9IGNhbGVuZGFyLnJvb3Q7XHJcbiAgdmFyIGxlZ2VuZEl0ZW07XHJcbiAgdmFyIG9wdGlvbnMgPSBjYWxlbmRhci5vcHRpb25zOyAvLyBTaG9ydGVyIGFjY2Vzc29yIGZvciB2YXJpYWJsZSBuYW1lIG1hbmdsaW5nIHdoZW4gbWluaWZ5aW5nXHJcblxyXG4gIHRoaXMuY29tcHV0ZURpbSgpO1xyXG5cclxuICB2YXIgX2xlZ2VuZCA9IG9wdGlvbnMubGVnZW5kLnNsaWNlKDApO1xyXG4gIF9sZWdlbmQucHVzaChfbGVnZW5kW19sZWdlbmQubGVuZ3RoIC0gMV0gKyAxKTtcclxuXHJcbiAgdmFyIGxlZ2VuZEVsZW1lbnQgPSBjYWxlbmRhci5yb290LnNlbGVjdCgnLmdyYXBoLWxlZ2VuZCcpO1xyXG4gIGlmIChsZWdlbmRFbGVtZW50WzBdWzBdICE9PSBudWxsKSB7XHJcbiAgICBsZWdlbmQgPSBsZWdlbmRFbGVtZW50O1xyXG4gICAgbGVnZW5kSXRlbSA9IGxlZ2VuZC5zZWxlY3QoJ2cnKS5zZWxlY3RBbGwoJ3JlY3QnKS5kYXRhKF9sZWdlbmQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBDcmVhdGluZyB0aGUgbmV3IGxlZ2VuZCBET00gaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0XHJcbiAgICBsZWdlbmQgPVxyXG4gICAgICBvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICd0b3AnXHJcbiAgICAgICAgPyBsZWdlbmQuaW5zZXJ0KCdzdmcnLCAnLmdyYXBoJylcclxuICAgICAgICA6IGxlZ2VuZC5hcHBlbmQoJ3N2ZycpO1xyXG5cclxuICAgIGxlZ2VuZC5hdHRyKCd4JywgZ2V0TGVnZW5kWFBvc2l0aW9uKCkpLmF0dHIoJ3knLCBnZXRMZWdlbmRZUG9zaXRpb24oKSk7XHJcblxyXG4gICAgbGVnZW5kSXRlbSA9IGxlZ2VuZFxyXG4gICAgICAuYXR0cignY2xhc3MnLCAnZ3JhcGgtbGVnZW5kJylcclxuICAgICAgLmF0dHIoJ2hlaWdodCcsIHBhcmVudC5nZXREaW0oJ2hlaWdodCcpKVxyXG4gICAgICAuYXR0cignd2lkdGgnLCBwYXJlbnQuZ2V0RGltKCd3aWR0aCcpKVxyXG4gICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgLnNlbGVjdEFsbCgpXHJcbiAgICAgIC5kYXRhKF9sZWdlbmQpO1xyXG4gIH1cclxuXHJcbiAgbGVnZW5kSXRlbVxyXG4gICAgLmVudGVyKClcclxuICAgIC5hcHBlbmQoJ3JlY3QnKVxyXG4gICAgLmNhbGwobGVnZW5kQ2VsbExheW91dClcclxuICAgIC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgIHJldHVybiBjYWxlbmRhci5MZWdlbmQuZ2V0Q2xhc3MoZCwgY2FsZW5kYXIubGVnZW5kU2NhbGUgPT09IG51bGwpO1xyXG4gICAgfSlcclxuICAgIC5hdHRyKCdmaWxsLW9wYWNpdHknLCAwKVxyXG4gICAgLmNhbGwoZnVuY3Rpb24gKHNlbGVjdGlvbikge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgY2FsZW5kYXIubGVnZW5kU2NhbGUgIT09IG51bGwgJiZcclxuICAgICAgICBvcHRpb25zLmxlZ2VuZENvbG9ycyAhPT0gbnVsbCAmJlxyXG4gICAgICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzLmhhc093blByb3BlcnR5KCdiYXNlJylcclxuICAgICAgKSB7XHJcbiAgICAgICAgc2VsZWN0aW9uLmF0dHIoJ2ZpbGwnLCBvcHRpb25zLmxlZ2VuZENvbG9ycy5iYXNlKTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICAgIC5hcHBlbmQoJ3RpdGxlJyk7XHJcblxyXG4gIGxlZ2VuZEl0ZW1cclxuICAgIC5leGl0KClcclxuICAgIC50cmFuc2l0aW9uKClcclxuICAgIC5kdXJhdGlvbihvcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uKVxyXG4gICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIDApXHJcbiAgICAucmVtb3ZlKCk7XHJcblxyXG4gIGxlZ2VuZEl0ZW1cclxuICAgIC50cmFuc2l0aW9uKClcclxuICAgIC5kZWxheShmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICByZXR1cm4gKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24gKiBpKSAvIDEwO1xyXG4gICAgfSlcclxuICAgIC5jYWxsKGxlZ2VuZENlbGxMYXlvdXQpXHJcbiAgICAuYXR0cignZmlsbC1vcGFjaXR5JywgMSlcclxuICAgIC5jYWxsKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgIGVsZW1lbnQuYXR0cignZmlsbCcsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgaWYgKGNhbGVuZGFyLmxlZ2VuZFNjYWxlID09PSBudWxsKSB7XHJcbiAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgcmV0dXJuIGNhbGVuZGFyLmxlZ2VuZFNjYWxlKGQgLSAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLmxlZ2VuZFNjYWxlKG9wdGlvbnMubGVnZW5kW2kgLSAxXSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZWxlbWVudC5hdHRyKCdjbGFzcycsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyLkxlZ2VuZC5nZXRDbGFzcyhkLCBjYWxlbmRhci5sZWdlbmRTY2FsZSA9PT0gbnVsbCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGxlZ2VuZENlbGxMYXlvdXQoc2VsZWN0aW9uKSB7XHJcbiAgICBzZWxlY3Rpb25cclxuICAgICAgLmF0dHIoJ3dpZHRoJywgb3B0aW9ucy5sZWdlbmRDZWxsU2l6ZSlcclxuICAgICAgLmF0dHIoJ2hlaWdodCcsIG9wdGlvbnMubGVnZW5kQ2VsbFNpemUpXHJcbiAgICAgIC5hdHRyKCdyeCcsIG9wdGlvbnMubGVnZW5kQ2VsbFJhZGl1cylcclxuICAgICAgLmF0dHIoJ3J5Jywgb3B0aW9ucy5sZWdlbmRDZWxsUmFkaXVzKVxyXG4gICAgICAuYXR0cigneCcsIGZ1bmN0aW9uIChkLCBpKSB7XHJcbiAgICAgICAgcmV0dXJuIGkgKiAob3B0aW9ucy5sZWdlbmRDZWxsU2l6ZSArIG9wdGlvbnMubGVnZW5kQ2VsbFBhZGRpbmcpO1xyXG4gICAgICB9KTtcclxuICB9XHJcblxyXG4gIGxlZ2VuZEl0ZW0uc2VsZWN0KCd0aXRsZScpLnRleHQoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBjYWxlbmRhci5mb3JtYXRTdHJpbmdXaXRoT2JqZWN0KG9wdGlvbnMubGVnZW5kVGl0bGVGb3JtYXQubG93ZXIsIHtcclxuICAgICAgICBtaW46IG9wdGlvbnMubGVnZW5kW2ldLFxyXG4gICAgICAgIG5hbWU6IG9wdGlvbnMuaXRlbU5hbWVbMV0sXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmIChpID09PSBfbGVnZW5kLmxlbmd0aCAtIDEpIHtcclxuICAgICAgcmV0dXJuIGNhbGVuZGFyLmZvcm1hdFN0cmluZ1dpdGhPYmplY3Qob3B0aW9ucy5sZWdlbmRUaXRsZUZvcm1hdC51cHBlciwge1xyXG4gICAgICAgIG1heDogb3B0aW9ucy5sZWdlbmRbaSAtIDFdLFxyXG4gICAgICAgIG5hbWU6IG9wdGlvbnMuaXRlbU5hbWVbMV0sXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGNhbGVuZGFyLmZvcm1hdFN0cmluZ1dpdGhPYmplY3Qob3B0aW9ucy5sZWdlbmRUaXRsZUZvcm1hdC5pbm5lciwge1xyXG4gICAgICAgIGRvd246IG9wdGlvbnMubGVnZW5kW2kgLSAxXSxcclxuICAgICAgICB1cDogb3B0aW9ucy5sZWdlbmRbaV0sXHJcbiAgICAgICAgbmFtZTogb3B0aW9ucy5pdGVtTmFtZVsxXSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgbGVnZW5kSXRlbVxyXG4gICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICBjYWxlbmRhci5sZWdlbmRUaXAuc2hvdyhkLCB0aGlzKTtcclxuICAgIH0pXHJcbiAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBjYWxlbmRhci5sZWdlbmRUaXAuaGlkZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gIGxlZ2VuZFxyXG4gICAgLnRyYW5zaXRpb24oKVxyXG4gICAgLmR1cmF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pXHJcbiAgICAuYXR0cigneCcsIGdldExlZ2VuZFhQb3NpdGlvbigpKVxyXG4gICAgLmF0dHIoJ3knLCBnZXRMZWdlbmRZUG9zaXRpb24oKSlcclxuICAgIC5hdHRyKCd3aWR0aCcsIHBhcmVudC5nZXREaW0oJ3dpZHRoJykpXHJcbiAgICAuYXR0cignaGVpZ2h0JywgcGFyZW50LmdldERpbSgnaGVpZ2h0JykpO1xyXG5cclxuICBsZWdlbmRcclxuICAgIC5zZWxlY3QoJ2cnKVxyXG4gICAgLnRyYW5zaXRpb24oKVxyXG4gICAgLmR1cmF0aW9uKG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pXHJcbiAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAob3B0aW9ucy5sZWdlbmRPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAncm90YXRlKDkwICcgK1xyXG4gICAgICAgICAgb3B0aW9ucy5sZWdlbmRDZWxsU2l6ZSAvIDIgK1xyXG4gICAgICAgICAgJyAnICtcclxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kQ2VsbFNpemUgLyAyICtcclxuICAgICAgICAgICcpJ1xyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuICcnO1xyXG4gICAgfSk7XHJcblxyXG4gIGZ1bmN0aW9uIGdldExlZ2VuZFhQb3NpdGlvbigpIHtcclxuICAgIHN3aXRjaCAob3B0aW9ucy5sZWdlbmRIb3Jpem9udGFsUG9zaXRpb24pIHtcclxuICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kVmVydGljYWxQb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHxcclxuICAgICAgICAgIG9wdGlvbnMubGVnZW5kVmVydGljYWxQb3NpdGlvbiA9PT0gJ21pZGRsZSdcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHJldHVybiB3aWR0aCArIG9wdGlvbnMubGVnZW5kTWFyZ2luWzNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2lkdGggLSBwYXJlbnQuZ2V0RGltKCd3aWR0aCcpIC0gb3B0aW9ucy5sZWdlbmRNYXJnaW5bMV07XHJcbiAgICAgIGNhc2UgJ21pZGRsZSc6XHJcbiAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQod2lkdGggLyAyIC0gcGFyZW50LmdldERpbSgnd2lkdGgnKSAvIDIpO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmxlZ2VuZE1hcmdpblszXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldExlZ2VuZFlQb3NpdGlvbigpIHtcclxuICAgIGlmIChvcHRpb25zLmxlZ2VuZFZlcnRpY2FsUG9zaXRpb24gPT09ICdib3R0b20nKSB7XHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgY2FsZW5kYXIuZ3JhcGhEaW0uaGVpZ2h0ICtcclxuICAgICAgICBvcHRpb25zLmxlZ2VuZE1hcmdpblswXSAtXHJcbiAgICAgICAgb3B0aW9ucy5kb21haW5HdXR0ZXIgLVxyXG4gICAgICAgIG9wdGlvbnMuY2VsbFBhZGRpbmdcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvcHRpb25zLmxlZ2VuZE1hcmdpblswXTtcclxuICB9XHJcblxyXG4gIGNhbGVuZGFyLnJlc2l6ZSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgZGltZW5zaW9uIG9mIHRoZSBsZWdlbmRcclxuICpcclxuICogVGFrZXMgaW50byBhY2NvdW50IHJvdGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSAgc3RyaW5nIGF4aXMgV2lkdGggb3IgaGVpZ2h0XHJcbiAqIEByZXR1cm4gaW50IGhlaWdodCBvciB3aWR0aCBpbiBwaXhlbHNcclxuICovXHJcbkxlZ2VuZC5wcm90b3R5cGUuZ2V0RGltID0gZnVuY3Rpb24gKGF4aXMpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHZhciBpc0hvcml6b250YWwgPSB0aGlzLmNhbGVuZGFyLm9wdGlvbnMubGVnZW5kT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJztcclxuXHJcbiAgc3dpdGNoIChheGlzKSB7XHJcbiAgICBjYXNlICd3aWR0aCc6XHJcbiAgICAgIHJldHVybiB0aGlzLmRpbVtpc0hvcml6b250YWwgPyAnd2lkdGgnIDogJ2hlaWdodCddO1xyXG4gICAgY2FzZSAnaGVpZ2h0JzpcclxuICAgICAgcmV0dXJuIHRoaXMuZGltW2lzSG9yaXpvbnRhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJ107XHJcbiAgfVxyXG59O1xyXG5cclxuTGVnZW5kLnByb3RvdHlwZS5idWlsZENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIHZhciBvcHRpb25zID0gdGhpcy5jYWxlbmRhci5vcHRpb25zOyAvLyBTaG9ydGVyIGFjY2Vzc29yIGZvciB2YXJpYWJsZSBuYW1lIG1hbmdsaW5nIHdoZW4gbWluaWZ5aW5nXHJcblxyXG4gIGlmIChvcHRpb25zLmxlZ2VuZENvbG9ycyA9PT0gbnVsbCkge1xyXG4gICAgdGhpcy5jYWxlbmRhci5sZWdlbmRTY2FsZSA9IG51bGw7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICB2YXIgX2NvbG9yUmFuZ2UgPSBbXTtcclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5sZWdlbmRDb2xvcnMpKSB7XHJcbiAgICBfY29sb3JSYW5nZSA9IG9wdGlvbnMubGVnZW5kQ29sb3JzO1xyXG4gIH0gZWxzZSBpZiAoXHJcbiAgICBvcHRpb25zLmxlZ2VuZENvbG9ycy5oYXNPd25Qcm9wZXJ0eSgnbWluJykgJiZcclxuICAgIG9wdGlvbnMubGVnZW5kQ29sb3JzLmhhc093blByb3BlcnR5KCdtYXgnKVxyXG4gICkge1xyXG4gICAgX2NvbG9yUmFuZ2UgPSBbb3B0aW9ucy5sZWdlbmRDb2xvcnMubWluLCBvcHRpb25zLmxlZ2VuZENvbG9ycy5tYXhdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBvcHRpb25zLmxlZ2VuZENvbG9ycyA9IG51bGw7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICB2YXIgX2xlZ2VuZCA9IG9wdGlvbnMubGVnZW5kLnNsaWNlKDApO1xyXG5cclxuICBpZiAoX2xlZ2VuZFswXSA+IDApIHtcclxuICAgIF9sZWdlbmQudW5zaGlmdCgwKTtcclxuICB9IGVsc2UgaWYgKF9sZWdlbmRbMF0gPD0gMCkge1xyXG4gICAgLy8gTGV0J3MgZ3Vlc3MgdGhlIGxlZnRtb3N0IHZhbHVlLCBpdCB3ZSBoYXZlIHRvIGFkZCBvbmVcclxuICAgIF9sZWdlbmQudW5zaGlmdChcclxuICAgICAgX2xlZ2VuZFswXSAtIChfbGVnZW5kW19sZWdlbmQubGVuZ3RoIC0gMV0gLSBfbGVnZW5kWzBdKSAvIF9sZWdlbmQubGVuZ3RoLFxyXG4gICAgKTtcclxuICB9XHJcbiAgdmFyIGNvbG9yU2NhbGU7XHJcbiAgaWYgKG9wdGlvbnMubGVnZW5kQ29sb3JzLmhhc093blByb3BlcnR5KCdjb2xvclNjYWxlJykpIHtcclxuICAgIGNvbG9yU2NhbGUgPSBvcHRpb25zLmxlZ2VuZENvbG9ycy5jb2xvclNjYWxlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb2xvclNjYWxlID0gZDMuc2NhbGVcclxuICAgICAgLmxpbmVhcigpXHJcbiAgICAgIC5yYW5nZShfY29sb3JSYW5nZSlcclxuICAgICAgLmludGVycG9sYXRlKGQzLmludGVycG9sYXRlSGNsKVxyXG4gICAgICAuZG9tYWluKFtkMy5taW4oX2xlZ2VuZCksIGQzLm1heChfbGVnZW5kKV0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIGxlZ2VuZENvbG9ycyA9IF9sZWdlbmQubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gY29sb3JTY2FsZShlbGVtZW50KTtcclxuICB9KTtcclxuICB0aGlzLmNhbGVuZGFyLmxlZ2VuZFNjYWxlID0gZDMuc2NhbGVcclxuICAgIC50aHJlc2hvbGQoKVxyXG4gICAgLmRvbWFpbihvcHRpb25zLmxlZ2VuZClcclxuICAgIC5yYW5nZShsZWdlbmRDb2xvcnMpO1xyXG5cclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGNsYXNzbmFtZSBvbiB0aGUgbGVnZW5kIGZvciB0aGUgc3BlY2lmaWVkIHZhbHVlXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnRlZ2VyIG4gVmFsdWUgYXNzb2NpYXRlZCB0byBhIGRhdGVcclxuICogQHBhcmFtIGJvb2wgd2l0aENzc0NsYXNzIFdoZXRoZXIgdG8gZGlzcGxheSB0aGUgY3NzIGNsYXNzIHVzZWQgdG8gc3R5bGUgdGhlIGNlbGwuXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBEaXNhYmxpbmcgd2lsbCBhbGxvdyBzdHlsaW5nIGRpcmVjdGx5IHZpYSBodG1sIGZpbGwgYXR0cmlidXRlXHJcbiAqXHJcbiAqIEByZXR1cm4gc3RyaW5nIENsYXNzbmFtZSBhY2NvcmRpbmcgdG8gdGhlIGxlZ2VuZFxyXG4gKi9cclxuTGVnZW5kLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIChuLCB3aXRoQ3NzQ2xhc3MpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIGlmIChuID09PSBudWxsIHx8IGlzTmFOKG4pKSB7XHJcbiAgICByZXR1cm4gJyc7XHJcbiAgfVxyXG5cclxuICB2YXIgaW5kZXggPSBbdGhpcy5jYWxlbmRhci5vcHRpb25zLmxlZ2VuZC5sZW5ndGggKyAxXTtcclxuXHJcbiAgZm9yIChcclxuICAgIHZhciBpID0gMCwgdG90YWwgPSB0aGlzLmNhbGVuZGFyLm9wdGlvbnMubGVnZW5kLmxlbmd0aCAtIDE7XHJcbiAgICBpIDw9IHRvdGFsO1xyXG4gICAgaSArPSAxXHJcbiAgKSB7XHJcbiAgICBpZiAodGhpcy5jYWxlbmRhci5vcHRpb25zLmxlZ2VuZFswXSA+IDAgJiYgbiA8IDApIHtcclxuICAgICAgaW5kZXggPSBbJzEnLCAnaSddO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBpZiAobiA8PSB0aGlzLmNhbGVuZGFyLm9wdGlvbnMubGVnZW5kW2ldKSB7XHJcbiAgICAgIGluZGV4ID0gW2kgKyAxXTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAobiA9PT0gMCkge1xyXG4gICAgaW5kZXgucHVzaCgwKTtcclxuICB9XHJcblxyXG4gIGluZGV4LnVuc2hpZnQoJycpO1xyXG4gIHJldHVybiAoaW5kZXguam9pbignIHInKSArICh3aXRoQ3NzQ2xhc3MgPyBpbmRleC5qb2luKCcgcScpIDogJycpKS50cmltKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogI3NvdXJjZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zODMyNDUvODA1NjQ5XHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZVJlY3Vyc2l2ZShvYmoxLCBvYmoyKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvKmpzaGludCBmb3JpbjpmYWxzZSAqL1xyXG4gIGZvciAodmFyIHAgaW4gb2JqMikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gUHJvcGVydHkgaW4gZGVzdGluYXRpb24gb2JqZWN0IHNldDsgdXBkYXRlIGl0cyB2YWx1ZS5cclxuICAgICAgaWYgKG9iajJbcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xyXG4gICAgICAgIG9iajFbcF0gPSBtZXJnZVJlY3Vyc2l2ZShvYmoxW3BdLCBvYmoyW3BdKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvYmoxW3BdID0gb2JqMltwXTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAvLyBQcm9wZXJ0eSBpbiBkZXN0aW5hdGlvbiBvYmplY3Qgbm90IHNldDsgY3JlYXRlIGl0IGFuZCBzZXQgaXRzIHZhbHVlLlxyXG4gICAgICBvYmoxW3BdID0gb2JqMltwXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBvYmoxO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgMiBhcnJheXMgYXJlIGVxdWFsc1xyXG4gKlxyXG4gKiBAbGluayBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNDg1Mzk3NC84MDU2NDlcclxuICogQHBhcmFtICBhcnJheSBhcnJheSB0aGUgYXJyYXkgdG8gY29tcGFyZSB0b1xyXG4gKiBAcmV0dXJuIGJvb2wgdHJ1ZSBvZiB0aGUgMiBhcnJheXMgYXJlIGVxdWFsc1xyXG4gKi9cclxuZnVuY3Rpb24gYXJyYXlFcXVhbHMoYXJyYXlBLCBhcnJheUIpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8vIGlmIHRoZSBvdGhlciBhcnJheSBpcyBhIGZhbHN5IHZhbHVlLCByZXR1cm5cclxuICBpZiAoIWFycmF5QiB8fCAhYXJyYXlBKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICAvLyBjb21wYXJlIGxlbmd0aHMgLSBjYW4gc2F2ZSBhIGxvdCBvZiB0aW1lXHJcbiAgaWYgKGFycmF5QS5sZW5ndGggIT09IGFycmF5Qi5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlBLmxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIG5lc3RlZCBhcnJheXNcclxuICAgIGlmIChhcnJheUFbaV0gaW5zdGFuY2VvZiBBcnJheSAmJiBhcnJheUJbaV0gaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAvLyByZWN1cnNlIGludG8gdGhlIG5lc3RlZCBhcnJheXNcclxuICAgICAgaWYgKCFhcnJheUVxdWFscyhhcnJheUFbaV0sIGFycmF5QltpXSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoYXJyYXlBW2ldICE9PSBhcnJheUJbaV0pIHtcclxuICAgICAgLy8gV2FybmluZyAtIHR3byBkaWZmZXJlbnQgb2JqZWN0IGluc3RhbmNlcyB3aWxsIG5ldmVyIGJlIGVxdWFsOiB7eDoyMH0gIT0ge3g6MjB9XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IENhbEhlYXRNYXA7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./plugins/legacy-plugin-chart-calendar/src/vendor/cal-heatmap.js\n");

/***/ }),

/***/ "./packages/superset-ui-core/src/chart/components/reactify.tsx":
/*!*********************************************************************!*\
  !*** ./packages/superset-ui-core/src/chart/components/reactify.tsx ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ reactify)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /*\r\n * Licensed to the Apache Software Foundation (ASF) under one\r\n * or more contributor license agreements.  See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership.  The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the\r\n * \"License\"); you may not use this file except in compliance\r\n * with the License.  You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing,\r\n * software distributed under the License is distributed on an\r\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n * KIND, either express or implied.  See the License for the\r\n * specific language governing permissions and limitations\r\n * under the License.\r\n */\n\nfunction reactify(renderFn, callbacks) {\n  class ReactifiedComponent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n\n    constructor(props) {\n      super(props);this.container = void 0;\n      this.setContainerRef = this.setContainerRef.bind(this);\n    }\n    componentDidMount() {\n      this.execute();\n    }\n    componentDidUpdate() {\n      this.execute();\n    }\n    componentWillUnmount() {\n      this.container = undefined;\n      if (callbacks != null && callbacks.componentWillUnmount) {\n        callbacks.componentWillUnmount.bind(this)();\n      }\n    }\n    setContainerRef(ref) {\n      this.container = ref;\n    }\n    execute() {\n      if (this.container) {\n        renderFn(this.container, this.props);\n      }\n    }\n    render() {\n      const { id, className } = this.props;\n      return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: this.setContainerRef, id: id, className: className });\n    } // @ts-ignore\n    __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n      this[key] = eval(code);}}const ReactifiedClass = ReactifiedComponent;\n  if (renderFn.displayName) {\n    ReactifiedClass.displayName = renderFn.displayName;\n  }\n  // eslint-disable-next-line react/forbid-foreign-prop-types\n  if (renderFn.propTypes) {\n    ReactifiedClass.propTypes = {\n      ...ReactifiedClass.propTypes,\n      ...renderFn.propTypes };\n\n  }\n  if (renderFn.defaultProps) {\n    ReactifiedClass.defaultProps = renderFn.defaultProps;\n  }\n  return ReactifiedComponent;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(reactify, \"reactify\", \"D:\\\\work\\\\PublicProject\\\\superset\\\\superset-frontend\\\\packages\\\\superset-ui-core\\\\src\\\\chart\\\\components\\\\reactify.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWNrYWdlcy9zdXBlcnNldC11aS1jb3JlL3NyYy9jaGFydC9jb21wb25lbnRzL3JlYWN0aWZ5LnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFFQTtBQStCQTtBQUlBOztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBckNBO0FBQUE7QUEyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3BhY2thZ2VzL3N1cGVyc2V0LXVpLWNvcmUvc3JjL2NoYXJ0L2NvbXBvbmVudHMvcmVhY3RpZnkudHN4P2VjYTQiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuICogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4gKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuICogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5cclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcclxuXHJcbi8vIFRPRE86IE5vdGUgdGhhdCBpZCBhbmQgY2xhc3NOYW1lIGNhbiBjb2xsaWRlIGJldHdlZW4gUHJvcHMgYW5kIFJlYWN0aWZ5UHJvcHNcclxuLy8gbGVhZGluZyB0byAobGlrZWx5KSB1bmV4cGVjdGVkIGJlaGF2aW9ycy4gV2Ugc2hvdWxkIGVpdGhlciByZXF1aXJlIFByb3BzIHRvIG5vdFxyXG4vLyBjb250YWluIGFuIGlkL2NsYXNzTmFtZSwgb3Igbm90IGNvbWJpbmUgdGhlbSAodmlhIGludGVyc2VjdGlvbiksIGluc3RlYWQgcHJlZmVycmluZ1xyXG4vLyB3cmFwcGluZyAoY29tcG9zaXRpb24pLiBBcyBhbiBleGFtcGxlOlxyXG4vLyBpbnRlcmZhY2UgTXlQcm9wcyB7XHJcbi8vICAgaWQ6IG51bWJlcjtcclxuLy8gfVxyXG4vLyBmdW5jdGlvbiBteVJlbmRlcihjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBwcm9wczogUmVhZG9ubHk8TXlQcm9wcz4pOiB2b2lkIHtcclxuLy8gICBwcm9wcy5pZCAvLyB1bnVzYWJsZTogaWQgaXMgc3RyaW5nICYgbnVtYmVyXHJcbi8vIH1cclxuLy8gbmV3IChyZWFjdGlmeShteVJlbmRlcikpKHsgaWQ6IDUgfSk7IC8vIGVycm9yOiBpZCBoYXMgdG8gYmUgc3RyaW5nICYgbnVtYmVyXHJcblxyXG5leHBvcnQgdHlwZSBSZWFjdGlmeVByb3BzID0ge1xyXG4gIGlkPzogc3RyaW5nO1xyXG4gIGNsYXNzTmFtZT86IHN0cmluZztcclxufTtcclxuXHJcbi8vIFRPRE86IGFkZCBtb3JlIFJlYWN0IGxpZmVjeWNsZSBjYWxsYmFja3MgYXMgbmVlZGVkXHJcbmV4cG9ydCB0eXBlIExpZmVDeWNsZUNhbGxiYWNrcyA9IHtcclxuICBjb21wb25lbnRXaWxsVW5tb3VudD86ICgpID0+IHZvaWQ7XHJcbn07XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlbmRlckZ1bmNUeXBlPFByb3BzPiB7XHJcbiAgKGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIHByb3BzOiBSZWFkb25seTxQcm9wcyAmIFJlYWN0aWZ5UHJvcHM+KTogdm9pZDtcclxuICBkaXNwbGF5TmFtZT86IHN0cmluZztcclxuICBkZWZhdWx0UHJvcHM/OiBQYXJ0aWFsPFByb3BzICYgUmVhY3RpZnlQcm9wcz47XHJcbiAgcHJvcFR5cGVzPzogUmVhY3QuV2Vha1ZhbGlkYXRpb25NYXA8UHJvcHMgJiBSZWFjdGlmeVByb3BzPjtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVhY3RpZnk8UHJvcHMgZXh0ZW5kcyBvYmplY3Q+KFxyXG4gIHJlbmRlckZuOiBSZW5kZXJGdW5jVHlwZTxQcm9wcz4sXHJcbiAgY2FsbGJhY2tzPzogTGlmZUN5Y2xlQ2FsbGJhY2tzLFxyXG4pOiBSZWFjdC5Db21wb25lbnRDbGFzczxQcm9wcyAmIFJlYWN0aWZ5UHJvcHM+IHtcclxuICBjbGFzcyBSZWFjdGlmaWVkQ29tcG9uZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PFByb3BzICYgUmVhY3RpZnlQcm9wcz4ge1xyXG4gICAgY29udGFpbmVyPzogSFRNTERpdkVsZW1lbnQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJvcHM6IFByb3BzICYgUmVhY3RpZnlQcm9wcykge1xyXG4gICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyUmVmID0gdGhpcy5zZXRDb250YWluZXJSZWYuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgdGhpcy5leGVjdXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xyXG4gICAgICB0aGlzLmV4ZWN1dGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgdGhpcy5jb250YWluZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGlmIChjYWxsYmFja3M/LmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XHJcbiAgICAgICAgY2FsbGJhY2tzLmNvbXBvbmVudFdpbGxVbm1vdW50LmJpbmQodGhpcykoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldENvbnRhaW5lclJlZihyZWY6IEhUTUxEaXZFbGVtZW50KSB7XHJcbiAgICAgIHRoaXMuY29udGFpbmVyID0gcmVmO1xyXG4gICAgfVxyXG5cclxuICAgIGV4ZWN1dGUoKSB7XHJcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xyXG4gICAgICAgIHJlbmRlckZuKHRoaXMuY29udGFpbmVyLCB0aGlzLnByb3BzKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgY29uc3QgeyBpZCwgY2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgcmV0dXJuIDxkaXYgcmVmPXt0aGlzLnNldENvbnRhaW5lclJlZn0gaWQ9e2lkfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gLz47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBSZWFjdGlmaWVkQ2xhc3M6IFJlYWN0LkNvbXBvbmVudENsYXNzPFByb3BzICYgUmVhY3RpZnlQcm9wcz4gPVxyXG4gICAgUmVhY3RpZmllZENvbXBvbmVudDtcclxuXHJcbiAgaWYgKHJlbmRlckZuLmRpc3BsYXlOYW1lKSB7XHJcbiAgICBSZWFjdGlmaWVkQ2xhc3MuZGlzcGxheU5hbWUgPSByZW5kZXJGbi5kaXNwbGF5TmFtZTtcclxuICB9XHJcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L2ZvcmJpZC1mb3JlaWduLXByb3AtdHlwZXNcclxuICBpZiAocmVuZGVyRm4ucHJvcFR5cGVzKSB7XHJcbiAgICBSZWFjdGlmaWVkQ2xhc3MucHJvcFR5cGVzID0ge1xyXG4gICAgICAuLi5SZWFjdGlmaWVkQ2xhc3MucHJvcFR5cGVzLFxyXG4gICAgICAuLi5yZW5kZXJGbi5wcm9wVHlwZXMsXHJcbiAgICB9O1xyXG4gIH1cclxuICBpZiAocmVuZGVyRm4uZGVmYXVsdFByb3BzKSB7XHJcbiAgICBSZWFjdGlmaWVkQ2xhc3MuZGVmYXVsdFByb3BzID0gcmVuZGVyRm4uZGVmYXVsdFByb3BzO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIFJlYWN0aWZpZWRDb21wb25lbnQ7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./packages/superset-ui-core/src/chart/components/reactify.tsx\n");

/***/ })

}]);